# Episode 11: "Packet Analysis" 📡

> *"Every packet tells a story. Learn to listen."*

---

## 🎬 BRIEFING

```
╔══════════════════════════════════════════════════════════╗
║  ЛОКАЦИЯ: Safe House (неизвестный адрес), Москва        ║
║  ВРЕМЯ:   18:20, среда, 1 октября                       ║
║  СТАТУС:  🔴 COUNTER-SURVEILLANCE DETECTED!              ║
╚══════════════════════════════════════════════════════════╝
```

После успешного подключения к серверу V., вы получили доступ.  
Координаты следующего узла: `10.0.0.1:4433`.

**Но в 18:17 ситуация кардинально меняется.**

Новое сообщение от V.:

```
┌─────────────────────────────────────────────┐
│  FROM: V. (ENCRYPTED CHANNEL)               │
│  TIME: 18:17:42 UTC                         │
│  PRIORITY: 🔴 CRITICAL                      │
├─────────────────────────────────────────────┤
│                                             │
│  Подключиться — это полдела.                │
│  Настоящая игра — ПЕРЕХВАТ.                 │
│                                             │
│  На твоём интерфейсе идёт трафик.           │
│  Агенты Z. обмениваются данными на 9999.    │
│                                             │
│  ⚠️ ОПАСНОСТЬ:                              │
│  Они ТОЖЕ используют packet sniffing!       │
│  Возможно, они уже знают о safe house.      │
│                                             │
│  ЗАДАЧА:                                    │
│  Перехватить их TCP пакеты на порту 9999    │
│  Извлечь payload из каждого пакета          │
│  Найти: что они знают о тебе?               │
│                                             │
│  Используй RAW SOCKETS.                     │
│  Это единственный способ видеть ВСЁ.        │
│                                             │
│  ⚠️ Требуются ROOT права (sudo)             │
│                                             │
│  Будь осторожен. Охотник может стать        │
│  добычей.                                   │
│                                             │
│  — V.                                       │
│                                             │
└─────────────────────────────────────────────┘
```

### ⏱️ Временная линия событий

```
18:17 → 📧 Сообщение от V.: перехватить трафик агентов Z.
        Порт 9999 — их канал коммуникации
        
18:20 → 🔍 Запуск netstat для анализа
        $ netstat -an | grep 9999
        
        Active Internet connections:
        TCP  127.0.0.1:9999   127.0.0.1:54321  ESTABLISHED
        TCP  127.0.0.1:54321  127.0.0.1:9999   ESTABLISHED
        
        💡 Обнаружено: Активная коммуникация!
        
18:25 → 🛠️ Разработка packet sniffer
        Изучение raw sockets, struct iphdr, struct tcphdr
        
19:45 → 🚀 Первый запуск packet_sniffer
        $ sudo ./packet_sniffer
        
        Listening on all interfaces...
        Filtering for port 9999
        
19:46 → 📡 ПЕРВЫЙ ПАКЕТ перехвачен!
        From: 127.0.0.1:54321 → 127.0.0.1:9999
        Protocol: TCP, Flags: PSH ACK
        Payload (48 bytes):
        "Target confirmed. Location: Safe house."
        
19:47 → 🚨 ВТОРОЙ ПАКЕТ — ШОКИРУЮЩЕЕ СОДЕРЖАНИЕ!
        From: 127.0.0.1:9999 → 127.0.0.1:54321
        Payload (64 bytes):
        "Coordinates: 55.7520°N 37.6175°E"
        "Status: Under surveillance"
        "Agent count: 1"
        
        💀 ЭТО КООРДИНАТЫ ВАШЕГО SAFE HOUSE!!!
        
19:48 → ⚠️ ТРЕТИЙ ПАКЕТ:
        "Order: Continue monitoring. Do not engage."
        "Report to HQ every 30 minutes."
        
20:00 → 💡 ОСОЗНАНИЕ:
        Преследователи Z. ТОЖЕ используют packet sniffing!
        Они перехватывают ВАШ трафик!
        "Охотник" стал "добычей"...
        
20:15 → 📞 SMS от V.:
        "Они следят за тобой.
         Но теперь ТЫ следишь за ними.
         Информационная война.
         Продолжай перехват."

20:18 → 💬 СООБЩЕНИЕ ОТ "ПРИЗРАКА" (РАСКРЫТИЕ!)
        
        FROM: UNKNOWN
        
        "Morpheus.
         
         Пора раскрыть карты.
         Я — Алекс Соколов. Позывной: 'Призрак'.
         
         Ex-FSB, Управление 'K' (контрразведка).
         5 лет искал Виктора.
         6 месяцев назад понял: Виктор — на правильной стороне.
         
         Сейчас я с вами.
         
         ⚠️ КРИТИЧНО:
         Агент Крылов (мой бывший начальник) идёт по твоему следу.
         У него доступ к системам ФСБ.
         Он знает о safe house.
         
         Координаты 55.7520°N 37.6175°E в их логах.
         Это ТВОЙ адрес!
         
         Packet sniffing — отлично, но НЕДОСТАТОЧНО.
         Крылов использует:
         - Физическое наблюдение (2 агента у подъезда)
         - Сотовые вышки (триангуляция)
         - СОРМ (система оперативно-розыскных мероприятий)
         
         Ты в опасности.
         Доверься мне.
         
         — Алекс Соколов ('Призрак')"
        
        🔓 ЛИЧНОСТЬ РАСКРЫТА!
        
20:20 → 📱 ЗВОНОК: Анна Ковалёва

        "Morpheus! Это Анна Ковалёва, forensics specialist.
         Работала с Виктором 2 года назад.
         
         'Призрак' передал мне твой номер.
         У меня информация.
         
         Полковник Крылов ЛИЧНО координирует операцию.
         Видела его имя в перехваченных логах ФСБ.
         
         Два агента наблюдают за safe house:
         - Чёрный седан Lada Granta (номер X999XX77)
         - Позиция: 100м от подъезда
         - Смена каждые 6 часов
         
         НЕ ВЫХОДИ из safe house!
         Они ждут твоих действий.
         
         Используй VPN. Тор. Всё что есть.
         Не звони по обычной связи.
         
         Будь осторожен.
         
         — Анна"
         
        [Звонок завершён]
        
        ✅ Анна Ковалёва предупредила об опасности
         
20:30 → 🎯 ЧЕТВЁРТЫЙ ПАКЕТ — КЛЮЧЕВАЯ ИНФОРМАЦИЯ:
        
        Вы перехватываете TCP пакет на порту 9999:
        
        From: 127.0.0.1:9999 → 127.0.0.1:54321
        Payload (128 bytes):
        
        "Agent Krylov: En route to target location.
         ETA: 22:00 (2 hours).
         
         Orders: Surveillance only. Do not engage.
         Target is valuable. Capture alive.
         
         Safe house coordinates: 55.7520°N 37.6175°E
         
         Next node: 10.0.0.1:4433
         Protocol: Encrypted TCP
         Objective: Intercept encrypted stream"
        
        💀 КРЫЛОВ ЕДЕТ СЮДА! ETA 22:00!
        ✅ Получены координаты следующего узла
        
20:45 → 📞 SMS от Алекса Соколова ('Призрак'):
        "Видел перехват.
         Крылов будет через 75 минут.
         
         Завершай миссию.
         Готовься к эвакуации.
         
         Виктор организует встречу.
         Доверься процессу.
         
         — A.S."
        
22:35 → ✅ Перехват завершён
        Извлечено: 127 пакетов
        Скрытое сообщение декодировано
        Episode 11 Complete
```

Вы открываете консоль и запускаете `netstat`:

```
Active Internet connections
Proto Local Address    Foreign Address    State
TCP   127.0.0.1:9999   127.0.0.1:54321   ESTABLISHED
TCP   127.0.0.1:54321  127.0.0.1:9999    ESTABLISHED
```

**Что вы понимаете:**
- На порту **9999** идёт активная коммуникация **агентов Z.**
- Обычные сокеты видят только данные **вашего приложения**
- **Raw sockets** видят **все пакеты** на сетевом интерфейсе
- Нужно **парсить IP и TCP заголовки** вручную
- Извлечь **payload** (данные после заголовков)
- **КРИТИЧНО**: В пакетах могут быть данные о ВАШЕМ местоположении!
- **"Охотник становится добычей"** — взаимная слежка
- **Полковник Крылов едет к safe house!** ETA 22:00 (2 часа!)

**Персонажи Episode 11:**
- 👻 **"Призрак" = Алекс Соколов** (20:18) — РАСКРЫТИЕ! Ex-FSB, Управление 'K', теперь с вами
- 🔄 **Анна Ковалёва** (20:20) — forensics specialist, предупредила об агентах (Lada Granta X999XX77)
- ⚔️ **Полковник Крылов** (20:30) — ваш бывший начальник Алекса, едет к safe house (ETA 22:00!)
- 🔄 **Viktor** (20:15) — координирует информационную войну
- ⚔️ **Агенты Z.** (18:20+) — физическое наблюдение + packet sniffing

Это момент истины. Время стать **packet sniffer** и узнать, что враги знают о вас.

### 🎯 ЗАДАЧА

Создать **`packet_sniffer`** — анализатор сетевых пакетов:
1. ✅ Создать raw socket (SOCK_RAW)
2. ✅ Перехватывать все TCP пакеты
3. ✅ Парсить IP заголовок (source, dest, protocol)
4. ✅ Парсить TCP заголовок (ports, flags, seq)
5. ✅ Извлекать payload (данные)
6. ✅ Фильтровать по порту 9999
7. ✅ Hex dump пакетов
8. ✅ Найти скрытое сообщение

**Сложность:** 🔴 Hard  
**Новые навыки:** Raw sockets, packet sniffing, header parsing, hex dump

```
╔══════════════════════════════════════════════╗
║  [!] ВНИМАНИЕ:                               ║
║  Raw sockets — мощный инструмент.            ║
║  Вы видите ВСЁ. Используйте ответственно.    ║
║  Требуется sudo (root права).                ║
╚══════════════════════════════════════════════╝
```

---

## 📚 THEORY BLOCK 1: Packet Sniffing — концепция подслушивания

> *"Raw socket — это подслушивающее устройство. Ты слышишь ВСЁ."* — V.

### 🎭 МЕТАФОРА: Packet Sniffing = Подслушивающее устройство

**Представьте:**  
Вы сидите в кафе. Вокруг много людей, и все они разговаривают. Обычно вы слышите только своего собеседника, а остальные голоса — фоновый шум.

**НО:** Если у вас есть **направленный микрофон** (подслушивающее устройство), вы можете:
- Настроиться на **любой разговор** в кафе
- Слышать **весь разговор** целиком
- **Записывать** каждое слово
- **Фильтровать** по голосу (например, только мужские голоса)

**В сети:**

```
Обычный TCP сокет (socket()):
├─ Вы → Собеседник (203.0.113.42:31337)
└─ Слышите ТОЛЬКО ваш разговор
   ❌ Другие разговоры не видны

Raw socket (SOCK_RAW):
├─ Вы → ВСЯ СЕТЬ
├─ Слышите ВСЕ разговоры на вашем сегменте сети!
│   ├─ 192.168.1.50 → 8.8.8.8:53 (DNS запрос)
│   ├─ 192.168.1.100 → 203.0.113.42:31337 (ваш трафик)
│   └─ 192.168.1.150 → 10.0.0.1:9999 (агенты Z.!)
└─ ✅ Можете фильтровать по IP/порту/протоколу
```

**ASCII-диаграмма:**

```
         КАФЕ (СЕТЬ 192.168.1.0/24)
         
  [Стол 1]        [Стол 2]        [Стол 3]
  A ↔ B           C ↔ D           ВЫ ↔ V.
  (DNS)           (HTTPS)         (TCP:31337)
    ↓               ↓               ↓
    └───────────────┴───────────────┘
                    │
            [Подслушивающее
             устройство]
             (Raw socket)
                    │
           ┌────────┴────────┐
           │  Вы слышите:    │
           │  ✓ A → B        │
           │  ✓ C → D        │
           │  ✓ ВЫ ↔ V.      │
           │  ✓ Агенты Z.!   │
           └─────────────────┘

НО! Агенты Z. тоже имеют подслушивающее устройство:
  → Они слышат ВАШ трафик!
  → Информационная война (взаимный sniffing)
```

**Почему это работает:**

1. **Ethernet = широковещательная среда:**
   - Все пакеты передаются **всем** устройствам на сегменте
   - Обычно: ваша сетевая карта **отбрасывает** чужие пакеты
   - Raw socket: вы говорите карте **НЕ отбрасывать** → видите всё!

2. **Promiscuous mode:**
   ```c
   // Обычный режим:
   NIC: "Этот пакет не для меня (dest MAC != мой MAC) → отбросить"
   
   // Promiscuous mode:
   NIC: "Этот пакет не для меня → ВСЁ РАВНО ПРИНЯТЬ и отдать приложению!"
   ```

3. **Фильтрация:**
   ```c
   // Все пакеты → фильтр → только интересующие
   if (tcp->dest == htons(9999)) {  // Агенты Z. на порту 9999
       printf("Перехвачено сообщение агентов!\n");
   }
   ```

**В миссии:**
```
18:20 → Агенты Z. общаются на порту 9999
        ВЫ (192.168.1.100) запускаете packet_sniffer
        
19:15 → Перехвачен пакет:
        Source: 192.168.1.150 (агент Z.)
        Dest:   10.0.0.1:9999
        Payload: "Coordinates: 55.7520°N 37.6175°E"
        
19:16 → ВЫ УЗНАЛИ координаты safe house!
        Агенты Z. знают, где вы!
        
НО:
        Агенты Z. ТАКЖЕ перехватывают ВАШ трафик!
        → Взаимный sniffing
        → Информационная война
```

**Защита от sniffing:**
- ✅ **Шифрование** (TLS/SSL) — даже если перехватят, не расшифруют
- ✅ **VPN** — туннель, скрывает содержимое
- ✅ **Физическая изоляция** — отдельный сегмент сети
- ❌ **Plaintext** — любой может прочитать (как в миссии!)

**Ключевые концепции THEORY BLOCK 1:**
- Raw socket = подслушивающее устройство
- Promiscuous mode = принимать ВСЕ пакеты
- Ethernet = широковещательная среда
- Взаимный sniffing = информационная война

---

## 🤔 КОНТРОЛЬНЫЕ ВОПРОСЫ (Блок 1)

Проверьте понимание концепции packet sniffing:

**1. Почему агенты Z. в 19:47 смогли узнать координаты вашего safe house (55.7520°N 37.6175°E)?**

<details>
<summary>Ответ</summary>

**ОНИ ТОЖЕ используют packet sniffing!**

**Взаимная слежка:**
```
19:46 → ВЫ перехватываете ИХ пакет:
        "Target confirmed. Location: Safe house."
        
19:47 → ОНИ перехватывают ВАШ пакет:
        (Возможно, вы ранее отправляли координаты V.!)
        "Coordinates: 55.7520°N 37.6175°E"
        
Результат:
├─ ВЫ знаете: они знают о safe house
├─ ОНИ знают: точные координаты!
└─> Информационная война (кто кого переиграет?)
```

**Почему это работает:**
- Ethernet = широковещательная среда
- Все пакеты видны ВСЕМ на сегменте сети
- Raw socket + promiscuous mode = видишь ВСЁ
- Незашифрованный трафик = открытая книга!

**В миссии:**
- Агенты Z. на том же сегменте сети (или имеют доступ к маршрутизатору)
- Они перехватывают ВАШ трафик
- Координаты отправлены в plaintext
- Результат: safe house раскрыт!

**Урок:** "Охотник может стать добычей". Packet sniffing — двусторонний инструмент!
</details>

**2. В чём разница между обычным сокетом (`socket(AF_INET, SOCK_STREAM, 0)`) и raw сокетом для перехвата?**

<details>
<summary>Ответ</summary>

**Обычный сокет = телефонная трубка. Raw сокет = подслушивающее устройство!**

**Обычный TCP сокет:**
```c
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
connect(sockfd, ...);
send(sockfd, "Hello", 5, 0);

ЧТО ВИДИТЕ:
├─ Только ВАШЕ соединение: YOU ↔ SERVER
├─ Только данные приложения: "Hello"
└─ Заголовки обработаны ядром (вы их НЕ видите!)
```

**Raw сокет:**
```c
int raw_fd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
// Promiscuous mode (опционально):
struct ifreq ifr;
ioctl(raw_fd, SIOCGIFFLAGS, &ifr);
ifr.ifr_flags |= IFF_PROMISC;
ioctl(raw_fd, SIOCSIFFLAGS, &ifr);

ЧТО ВИДИТЕ:
├─ ВСЕ пакеты на интерфейсе!
├─ Включая чужие: A ↔ B, C ↔ D, Агенты Z. ↔ HQ
├─ ПОЛНЫЕ пакеты с заголовками:
│   ├─ Ethernet header
│   ├─ IP header (source, dest, protocol)
│   ├─ TCP header (ports, seq, flags)
│   └─ Payload (данные приложения)
└─ Нужно парсить самому!
```

**Аналогия:**
```
Обычный сокет:
  Вы разговариваете по телефону с V.
  Слышите ТОЛЬКО его голос.
  
Raw сокет:
  Вы в кафе с направленным микрофоном.
  Слышите ВСЕ разговоры вокруг!
  Можете настроиться на любой стол (фильтр по IP/порту).
```

**В миссии (19:46):**
```c
// Обычный сокет НЕ СРАБОТАЕТ:
socket(AF_INET, SOCK_STREAM, 0);  // Видит только ваше соединение

// Raw сокет НУЖЕН:
socket(AF_INET, SOCK_RAW, IPPROTO_TCP);  // Видит агентов Z. на порту 9999!
```

**Урок:** Raw socket = полный контроль + полная ответственность. С большой силой приходит большая ответственность!
</details>

**3. Что означает "promiscuous mode" и почему он критичен для перехвата пакетов агентов Z.?**

<details>
<summary>Ответ</summary>

**Promiscuous mode = "принять ВСЁ, даже не для меня"!**

**Нормальный режим сетевой карты:**
```
Пакет прилетает:
  Dest MAC: AA:BB:CC:DD:EE:FF
  
Сетевая карта проверяет:
  Мой MAC: 11:22:33:44:55:66
  
  AA:BB:CC != 11:22:33 → НЕ МОЙ ПАКЕТ!
  
  → ОТБРОСИТЬ (drop)
  → Приложение НЕ ПОЛУЧИТ
```

**Promiscuous mode:**
```
Пакет прилетает:
  Dest MAC: AA:BB:CC:DD:EE:FF
  
Сетевая карта:
  Promiscuous mode = ON
  
  → ПРИНЯТЬ ЛЮБОЙ ПАКЕТ!
  → Даже если dest MAC != мой
  → Отдать raw socket приложению
  
Приложение получает:
  ├─ Свои пакеты (11:22:33...)
  ├─ Пакеты агентов Z. (AA:BB:CC...)
  ├─ Broadcast пакеты (FF:FF:FF...)
  └─ ВСЁ!
```

**Код активации:**
```c
#include <sys/ioctl.h>
#include <net/if.h>

struct ifreq ifr;
strncpy(ifr.ifr_name, "eth0", IFNAMSIZ);

// Получить текущие флаги:
ioctl(sockfd, SIOCGIFFLAGS, &ifr);

// Добавить IFF_PROMISC:
ifr.ifr_flags |= IFF_PROMISC;

// Применить:
ioctl(sockfd, SIOCSIFFLAGS, &ifr);

printf("Promiscuous mode активирован!\n");
```

**В миссии (19:46):**
```
Агенты Z. общаются:
  127.0.0.1:54321 → 127.0.0.1:9999
  Dest MAC: (их сетевая карта)
  
Без promiscuous mode:
  Ваша карта: "Не мой MAC → drop"
  → ВЫ НЕ ВИДИТЕ их трафик!
  
С promiscuous mode:
  Ваша карта: "Принять ЛЮБОЙ пакет!"
  → ВЫ ВИДИТЕ: "Target confirmed. Location: Safe house."
  → ПЕРЕХВАТ УСПЕШЕН!
```

**Почему критичен:**
- Без promiscuous mode = видите ТОЛЬКО свой трафик
- С promiscuous mode = видите ВСЁ (включая агентов Z.!)
- Это разница между слепотой и всевидением

**Требование:** `sudo` (root rights) — только root может включить promiscuous mode!

**Урок:** Promiscuous mode = ключ к подслушиванию. Без него packet sniffer бесполезен!
</details>

---

## 💬 СЮЖЕТНАЯ СЦЕНА: Раскрытие "Призрака" — Алекс Соколов!

```
╔══════════════════════════════════════════════════════════╗
║  ВРЕМЯ:   20:18, среда, 1 октября                       ║
║  СОБЫТИЕ: 👻 "ПРИЗРАК" РАСКРЫВАЕТ ЛИЧНОСТЬ!             ║
╚══════════════════════════════════════════════════════════╝
```

Вы продолжаете перехватывать пакеты агентов Z. Ваш packet sniffer работает. Но вдруг телефон вибрирует.

**Сообщение от UNKNOWN:**

```
┌──────────────────────────────────────────────┐
│  FROM: UNKNOWN                               │
│  TIME: 20:18:47                              │
│  ENCRYPTION: PGP (Viktor's key)              │
├──────────────────────────────────────────────┤
│                                              │
│  Morpheus.                                   │
│                                              │
│  Я наблюдаю за тобой с Episode 02.           │
│  Помогал. Предупреждал. Но анонимно.         │
│                                              │
│  Пора раскрыть карты.                        │
│                                              │
│  🔓 МОЯ ЛИЧНОСТЬ:                            │
│                                              │
│  Имя: Алекс Соколов                          │
│  Позывной: "Призрак" (Ghost)                 │
│  Возраст: 38 лет                             │
│                                              │
│  Бывшая работа:                              │
│  ФСБ России, Управление 'K'                  │
│  (контрразведка)                             │
│  Звание: Майор (в отставке)                  │
│  Опыт: 12 лет оперативной работы             │
│                                              │
│  ═══════════════════════════════════════════ │
│                                              │
│  ИСТОРИЯ:                                    │
│                                              │
│  2019-2024: Искал Виктора Петрова            │
│  Задание ФСБ: найти, захватить, допросить    │
│                                              │
│  5 лет погони. Десятки операций.             │
│  Виктор всегда был на шаг впереди.           │
│                                              │
│  Март 2024 (6 месяцев назад):                │
│  Я нашёл его данные. Прочитал его дела.      │
│  Понял: он не враг. Он разоблачает коррупцию.│
│                                              │
│  РЕШЕНИЕ:                                    │
│  Перешёл на его сторону.                     │
│  Вышел из ФСБ (формально: "отставка").       │
│  Теперь я — часть команды Виктора.           │
│                                              │
│  ═══════════════════════════════════════════ │
│                                              │
│  ⚠️ КРИТИЧНО:                                │
│                                              │
│  Полковник Крылов — МОЙ БЫВШИЙ НАЧАЛЬНИК.    │
│  Управление 'K', отдел контрразведки.        │
│  Он НЕ ПРОСТИЛ моё предательство.            │
│                                              │
│  Сейчас он идёт по твоему следу.             │
│  У него доступ к:                            │
│  - СОРМ (система прослушки)                  │
│  - GPS-трекинг мобильных                     │
│  - База данных ФСБ                           │
│  - Физическое наблюдение                     │
│                                              │
│  Координаты 55.7520°N 37.6175°E в логах.     │
│  Это ТВОЙ safe house!                        │
│                                              │
│  Агенты наблюдают:                           │
│  - Чёрный седан Lada Granta                  │
│  - Номер: X999XX77                           │
│  - Позиция: 100м от подъезда                 │
│  - Смена: каждые 6 часов                     │
│                                              │
│  ═══════════════════════════════════════════ │
│                                              │
│  ЧТО ДЕЛАТЬ:                                 │
│                                              │
│  1. Продолжай packet sniffing                │
│     Узнай: что ещё они знают?                │
│                                              │
│  2. НЕ ПАНИКУЙ                               │
│     Я отслеживаю передвижение Крылова        │
│     Предупрежу если он близко                │
│                                              │
│  3. ДОВЕРЬСЯ МНЕ                             │
│     Я с вами. Виктор знает.                  │
│     Команда тебя прикроет.                   │
│                                              │
│  Ты в опасности. Но ты не один.              │
│                                              │
│  — Алекс Соколов                             │
│    Позывной: "Призрак" (Ghost)               │
│                                              │
└──────────────────────────────────────────────┘
```

**🔓 ЛИЧНОСТЬ РАСКРЫТА!**

Вы смотрите на экран. Мурашки по коже.

**"Призрак"** — не просто помощник. Это **бывший агент ФСБ**, который рисковал всем, перейдя на сторону Виктора!

**Что вы узнали:**
- ✅ Алекс Соколов, 38 лет, ex-FSB Управление 'K' (контрразведка)
- ✅ 5 лет искал Виктора → 6 месяцев назад перешёл на его сторону
- ✅ Крылов = его БЫВШИЙ НАЧАЛЬНИК (личная драма!)
- ✅ Координаты safe house (55.7520°N 37.6175°E) в логах ФСБ
- ✅ Агенты наблюдают: Lada Granta X999XX77, 100м от подъезда

Вы возвращаетесь к packet sniffer. Теперь миссия ещё серьёзнее. Крылов знает, где вы. Время на исходе.

---

## 📚 THEORY BLOCK 2: IP и TCP заголовки — структура пакета

**Обычный сокет** (SOCK_STREAM):
- Видит только данные **вашего** приложения
- Ядро обрабатывает заголовки
- Удобно, но ограниченно

**Raw сокет** (SOCK_RAW):
- Видит **все пакеты** на интерфейсе
- Получаете **полный** пакет (с заголовками!)
- Полный контроль, но нужно парсить самому

```c
#include <sys/socket.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>

// Создание raw socket для TCP пакетов
int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);

// ⚠️ Требует root!
if (sockfd < 0) {
    perror("socket (are you root?)");
    exit(1);
}
```

**Почему нужен root?** Потому что raw socket может перехватывать **любой** трафик (угроза безопасности).

---

### 2. Структура IP заголовка (IPv4)

```c
#include <netinet/ip.h>

struct iphdr {
    uint8_t  ihl:4;        // IP Header Length (в 32-bit словах)
    uint8_t  version:4;    // Версия (4 для IPv4)
    uint8_t  tos;          // Type of Service
    uint16_t tot_len;      // Total Length (весь пакет)
    uint16_t id;           // Identification
    uint16_t frag_off;     // Fragment Offset
    uint8_t  ttl;          // Time To Live
    uint8_t  protocol;     // Protocol (6=TCP, 17=UDP, 1=ICMP)
    uint16_t check;        // Header Checksum
    uint32_t saddr;        // Source Address
    uint32_t daddr;        // Destination Address
};
```

**Важно**:
- `ihl` — длина заголовка в **32-bit словах** (обычно 5 = 20 байт)
- `protocol` — тип протокола (TCP=6, UDP=17)
- `saddr/daddr` — в **network byte order** (нужен `ntohl()`)

---

### 3. Структура TCP заголовка

```c
#include <netinet/tcp.h>

struct tcphdr {
    uint16_t source;       // Source port
    uint16_t dest;         // Destination port
    uint32_t seq;          // Sequence number
    uint32_t ack_seq;      // Acknowledgment number
    uint16_t res1:4;       // Reserved
    uint16_t doff:4;       // Data offset (длина заголовка)
    uint16_t fin:1, syn:1, rst:1, psh:1,
             ack:1, urg:1, ece:1, cwr:1;  // Flags
    uint16_t window;       // Window size
    uint16_t check;        // Checksum
    uint16_t urg_ptr;      // Urgent pointer
};
```

**TCP Flags**:
- `SYN` — начало соединения
- `ACK` — подтверждение
- `FIN` — закрытие соединения
- `RST` — сброс соединения
- `PSH` — немедленная отправка данных

---

### 4. Парсинг пакета

```c
unsigned char buffer[65536];  // Максимальный размер IP пакета

// Получить пакет
ssize_t size = recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, NULL);

// 1. Парсить IP заголовок
struct iphdr *ip = (struct iphdr*)buffer;

// Размер IP заголовка (в байтах)
int ip_header_len = ip->ihl * 4;

// 2. Парсить TCP заголовок (после IP)
struct tcphdr *tcp = (struct tcphdr*)(buffer + ip_header_len);

// Размер TCP заголовка (в байтах)
int tcp_header_len = tcp->doff * 4;

// 3. Payload (данные после заголовков)
unsigned char *payload = buffer + ip_header_len + tcp_header_len;
int payload_len = ntohs(ip->tot_len) - ip_header_len - tcp_header_len;

printf("Payload: ");
for (int i = 0; i < payload_len; i++) {
    printf("%02X ", payload[i]);
}
printf("\n");
```

**Ключевые структуры THEORY BLOCK 2:**
- `struct iphdr` — IP заголовок (source, dest, protocol)
- `struct tcphdr` — TCP заголовок (ports, seq, flags)
- `ip->ihl * 4` — размер IP заголовка в байтах
- `tcp->doff * 4` — размер TCP заголовка в байтах
- `payload` = после всех заголовков

---

## 🤔 КОНТРОЛЬНЫЕ ВОПРОСЫ (Блок 2)

Проверьте понимание структуры пакетов:

**4. В перехваченном пакете агентов Z. (19:46) `ip->protocol = 6`. Что это означает и почему важно для фильтрации?**

<details>
<summary>Ответ</summary>

**`protocol = 6` означает TCP!**

**IP protocol numbers:**
```c
#include <netinet/in.h>

#define IPPROTO_ICMP   1   // ICMP (ping)
#define IPPROTO_TCP    6   // TCP (надёжный)
#define IPPROTO_UDP   17   // UDP (ненадёжный)
```

**Фильтрация в коде:**
```c
struct iphdr *ip = (struct iphdr*)buffer;

if (ip->protocol == IPPROTO_TCP) {  // 6
    printf("TCP пакет обнаружен!\n");
    // Парсить TCP заголовок
    struct tcphdr *tcp = (struct tcphdr*)(buffer + ip->ihl * 4);
} else if (ip->protocol == IPPROTO_UDP) {  // 17
    printf("UDP пакет\n");
} else if (ip->protocol == IPPROTO_ICMP) {  // 1
    printf("ICMP (ping) пакет\n");
}
```

**В миссии (19:46):**
```
Перехвачен пакет:
  ip->protocol = 6  ← TCP!
  tcp->dest = 9999  ← Порт агентов Z.
  
Фильтр:
  if (ip->protocol == 6 && ntohs(tcp->dest) == 9999) {
      // ЭТО пакет агентов Z.!
      printf("Target confirmed. Location: Safe house.\n");
  }
```

**Почему важно:**
- Raw socket получает ВСЕ протоколы (TCP, UDP, ICMP, ...)
- Без фильтрации: тысячи пакетов в секунду!
- Нужен фильтр: `protocol == 6` → только TCP
- Затем: `port == 9999` → только агенты Z.

**Урок:** `ip->protocol` — первый уровень фильтрации. Без него утонете в трафике!
</details>

**5. Почему `ip->saddr` нельзя использовать напрямую для `printf()`? Как правильно конвертировать его в строку?**

<details>
<summary>Ответ</summary>

**`ip->saddr` — это 32-bit число в network byte order, НЕ строка!**

**Проблема:**
```c
struct iphdr *ip = (struct iphdr*)buffer;

printf("Source IP: %d\n", ip->saddr);  // ❌ НЕПРАВИЛЬНО!
// Вывод: Source IP: 701476106
// Это НЕ читаемый IP!
```

**Правильная конвертация:**
```c
#include <arpa/inet.h>

// Шаг 1: Создать struct in_addr
struct in_addr src_addr;
src_addr.s_addr = ip->saddr;  // Network byte order

// Шаг 2: Конвертировать в строку
char src_ip[INET_ADDRSTRLEN];  // Буфер для "xxx.xxx.xxx.xxx"
inet_ntop(AF_INET, &src_addr, src_ip, INET_ADDRSTRLEN);

// Шаг 3: Вывести
printf("Source IP: %s\n", src_ip);  // ✅ "127.0.0.1"
```

**Альтернатива (deprecated):**
```c
// Старый способ (НЕ рекомендуется):
char *src_ip = inet_ntoa(src_addr);  // ❌ Использует статический буфер!
printf("Source IP: %s\n", src_ip);
// Проблема: следующий вызов перезапишет результат!
```

**В миссии (19:47):**
```c
// Перехваченный пакет от агентов Z.:
struct iphdr *ip = (struct iphdr*)buffer;

struct in_addr src, dst;
src.s_addr = ip->saddr;
dst.s_addr = ip->daddr;

char src_ip[INET_ADDRSTRLEN], dst_ip[INET_ADDRSTRLEN];
inet_ntop(AF_INET, &src, src_ip, INET_ADDRSTRLEN);
inet_ntop(AF_INET, &dst, dst_ip, INET_ADDRSTRLEN);

printf("From: %s\n", src_ip);  // "127.0.0.1"
printf("To:   %s\n", dst_ip);  // "127.0.0.1"
```

**Почему network byte order:**
- IP адреса передаются в **big-endian** (network byte order)
- Intel процессоры — **little-endian** (host byte order)
- `inet_ntop()` делает конвертацию автоматически!

**Урок:** Всегда используйте `inet_ntop()` для IP адресов. Это безопасно и правильно!
</details>

**6. Что делает выражение `buffer + ip->ihl * 4` и почему это нужно для доступа к TCP заголовку?**

<details>
<summary>Ответ</summary>

**Вычисляет позицию TCP заголовка после IP заголовка!**

**Структура пакета:**
```
┌─────────────┬─────────────┬──────────────┐
│ IP Header   │ TCP Header  │ Payload      │
│ (20 bytes)  │ (20 bytes)  │ (variable)   │
└─────────────┴─────────────┴──────────────┘
 ↑             ↑             ↑
buffer        buffer+20     buffer+40
```

**Код:**
```c
unsigned char buffer[65536];
recvfrom(sockfd, buffer, sizeof(buffer), ...);

// buffer указывает на НАЧАЛО пакета (IP заголовок)
struct iphdr *ip = (struct iphdr*)buffer;

// Сколько байт занимает IP заголовок?
int ip_header_len = ip->ihl * 4;
//                         ↑    ↑
//                   в 32-bit  конвертация
//                   словах    в байты
// ihl = 5 → 5 * 4 = 20 байт (обычно)

// TCP заголовок ПОСЛЕ IP:
struct tcphdr *tcp = (struct tcphdr*)(buffer + ip_header_len);
//                                    ↑
//                          Арифметика указателей!
//                          buffer + 20 = адрес TCP
```

**Почему `ihl * 4`:**
```c
struct iphdr {
    uint8_t ihl:4;  // IP Header Length в 32-bit СЛОВАХ
    ...
};

// ihl измеряется в СЛОВАХ (4 байта):
ihl = 5  →  5 слов  = 5 * 4 = 20 байт (минимальный IP заголовок)
ihl = 6  →  6 слов  = 6 * 4 = 24 байта (с опциями)
ihl = 15 → 15 слов  = 15 * 4 = 60 байт (максимум)
```

**В миссии (19:46):**
```c
// Перехваченный пакет от агентов Z.:
unsigned char buffer[65536];
recvfrom(raw_fd, buffer, sizeof(buffer), ...);

struct iphdr *ip = (struct iphdr*)buffer;
// ip->ihl = 5 (стандартный заголовок)

int ip_len = ip->ihl * 4;  // 5 * 4 = 20

struct tcphdr *tcp = (struct tcphdr*)(buffer + 20);
//                                    ↑
//                          Пропускаем IP заголовок
//                          Теперь tcp указывает на TCP!

printf("Port: %d\n", ntohs(tcp->dest));  // 9999!
```

**Без этого:**
```c
// НЕПРАВИЛЬНО:
struct tcphdr *tcp = (struct tcphdr*)buffer;  // ❌
// tcp указывает на НАЧАЛО буфера (IP заголовок!)
// tcp->dest прочитает МУСОР из IP заголовка!
```

**Урок:** `buffer + ip->ihl * 4` = переход от IP к TCP. Без этого парсинг сломается!
</details>

---

## 💬 СЮЖЕТНАЯ СЦЕНА: Звонок Анны Ковалёвой — Предупреждение!

```
╔══════════════════════════════════════════════════════════╗
║  ВРЕМЯ:   20:20, среда, 1 октября                       ║
║  СОБЫТИЕ: 📱 Звонок от Анны Ковалёвой                   ║
╚══════════════════════════════════════════════════════════╝
```

Через 2 минуты после сообщения Ghost телефон снова звонит.

**Номер неизвестный. Но вы отвечаете.**

```
┌──────────────────────────────────────────────┐
│  ВХОДЯЩИЙ: +7 916 XXX-XX-XX                  │
│  [Принять звонок]                            │
└──────────────────────────────────────────────┘

"Morpheus! Это Анна Ковалёва.

Я forensics specialist. Работала с Виктором 2 года назад,
когда он ещё был в легальном бизнесе.

Ghost — Алекс Соколов — передал мне твой номер.
Сказал ты в опасности. У меня информация.

═══════════════════════════════════════════════

СЛУШАЙ ВНИМАТЕЛЬНО:

Полковник Крылов ЛИЧНО координирует операцию.

Я только что взломала серверные логи ФСБ
(не спрашивай как — это опасно).

Видела его имя в списке активных операций:

┌────────────────────────────────────────────┐
│ ОПЕРАЦИЯ: "МОРФЕЙ"                         │
│ РУКОВОДИТЕЛЬ: Полковник Крылов И.В.        │
│ ЦЕЛЬ: Задержание подозреваемого            │
│ СТАТУС: Активна                            │
│ ПРИОРИТЕТ: Высокий                         │
└────────────────────────────────────────────┘

═══════════════════════════════════════════════

ЧТО Я ЗНАЮ:

Два агента наблюдают за safe house ПРЯМО СЕЙЧАС:

🚗 Автомобиль:
   - Lada Granta, чёрная
   - Номер: X999XX77 (регион 77 = Москва)
   - Тонировка (незаконная, но им можно)

📍 Позиция:
   - 100 метров от твоего подъезда
   - Угол улицы (хороший обзор)
   - Камера направлена на вход

⏰ Режим:
   - Смена агентов каждые 6 часов
   - Сейчас: 20:20 → следующая смена в 02:00
   - Они НЕ СПЯТ (профессионалы!)

═══════════════════════════════════════════════

⚠️ КРИТИЧНО:

НЕ ВЫХОДИ ИЗ SAFE HOUSE!

Они ждут твоих действий.
Один шаг на улицу = задержание.

Крылов приказал: "Capture alive" (взять живым).
Ты им нужен для допроса.

═══════════════════════════════════════════════

МОИ РЕКОМЕНДАЦИИ:

1. ПРОДОЛЖАЙ PACKET SNIFFING
   Узнай всё что можешь
   Информация = сила

2. ИСПОЛЬЗУЙ ЗАЩИТУ:
   ✓ VPN (активируй СЕЙЧАС!)
   ✓ Tor Browser (если отправляешь что-то в сеть)
   ✓ Шифрование (всегда!)
   
   Незашифрованный трафик = они видят ВСЁ!

3. НЕ ЗВОНИ ПО ОБЫЧНОЙ СВЯЗИ
   СОРМ (система прослушки) активна
   Все звонки записываются
   
   Используй только:
   - Signal (E2E encryption)
   - Telegram Secret Chat
   - PGP email

4. ГОТОВЬСЯ К ЭВАКУАЦИИ
   Виктор организует встречу
   Но КОГДА — я не знаю
   
   Будь готов уйти в любой момент

═══════════════════════════════════════════════

Morpheus, я на твоей стороне.

Виктор помог мне 2 года назад когда меня пытались
дискредитировать. Я ему обязана.

Теперь я помогаю ВАМ.

Будь осторожен. Крылов — опасный противник.
Но Ghost (Алекс) знает его слабости.
Вместе справимся.

Удачи!

— Анна Ковалёва
  Forensics Specialist"

[Звонок завершён: 20:22]
```

**Что вы узнали от Анны:**
- ✅ Полковник Крылов ЛИЧНО руководит операцией "МОРФЕЙ" (вы!)
- ✅ Lada Granta X999XX77 наблюдает за safe house
- ✅ 100м от подъезда, смена каждые 6 часов
- ✅ "Capture alive" — вас нужны живым для допроса
- ✅ СОРМ активна (все звонки прослушиваются!)
- ✅ Анна на вашей стороне (долг перед Виктором)

Вы смотрите в окно. Где-то там, в 100 метрах, чёрный седан. Агенты ждут.

Но теперь вы знаете. И знание — сила.

Возвращаетесь к packet sniffer. Нужно узнать больше.

---

## 📚 THEORY BLOCK 3: Hex Dump и извлечение payload

> *"Payload — это душа пакета. Заголовки — просто упаковка."* — Ghost

```c
// IP в network byte order → строка
struct in_addr src_addr, dst_addr;
src_addr.s_addr = ip->saddr;
dst_addr.s_addr = ip->daddr;

char src_ip[INET_ADDRSTRLEN], dst_ip[INET_ADDRSTRLEN];
inet_ntop(AF_INET, &src_addr, src_ip, INET_ADDRSTRLEN);
inet_ntop(AF_INET, &dst_addr, dst_ip, INET_ADDRSTRLEN);

printf("From: %s:%d\n", src_ip, ntohs(tcp->source));
printf("To:   %s:%d\n", dst_ip, ntohs(tcp->dest));
```

---

### 6. Hex Dump

```c
void hex_dump(unsigned char *data, int len) {
    printf("Offset   Hex                                            ASCII\n");
    printf("-------- ---------------------------------------------- ----------------\n");
    
    for (int i = 0; i < len; i += 16) {
        printf("%08X ", i);
        
        // Hex
        for (int j = 0; j < 16; j++) {
            if (i + j < len) {
                printf("%02X ", data[i + j]);
            } else {
                printf("   ");
            }
        }
        
        printf(" ");
        
        // ASCII
        for (int j = 0; j < 16 && i + j < len; j++) {
            unsigned char c = data[i + j];
            printf("%c", (c >= 32 && c <= 126) ? c : '.');
        }
        
        printf("\n");
    }
}
```

---

### 7. Фильтрация пакетов

```c
// Фильтровать только TCP (protocol = 6)
if (ip->protocol != IPPROTO_TCP) {
    continue;
}

// Фильтровать по порту
uint16_t src_port = ntohs(tcp->source);
uint16_t dst_port = ntohs(tcp->dest);

if (dst_port == 9999 || src_port == 9999) {
    printf("MOONLIGHT traffic detected!\n");
    // Анализировать payload
}
```

---

### 8. Promiscuous Mode (опционально)

**Обычный режим**: сетевая карта отбрасывает пакеты не для нас.  
**Promiscuous mode**: карта принимает **все** пакеты в сети.

```c
#include <sys/ioctl.h>
#include <net/if.h>

struct ifreq ifr;
strncpy(ifr.ifr_name, "eth0", IFNAMSIZ);

// Получить текущие флаги
ioctl(sockfd, SIOCGIFFLAGS, &ifr);

// Установить promiscuous mode
ifr.ifr_flags |= IFF_PROMISC;
ioctl(sockfd, SIOCSIFFLAGS, &ifr);
```

**Осторожно**: В promiscuous mode вы видите **весь** трафик сегмента сети!

**Ключевые концепции THEORY BLOCK 3:**
- `inet_ntop()` — конвертация IP в строку
- `hex_dump()` — вывод payload в HEX + ASCII
- Фильтрация по порту (9999 для агентов Z.)
- Promiscuous mode — видеть ВСЁ

---

## 🤔 КОНТРОЛЬНЫЕ ВОПРОСЫ (Блок 3)

Проверьте понимание hex dump и payload:

**7. Что делает функция `hex_dump()` и почему она полезна при анализе пакетов агентов Z.?**

<details>
<summary>Ответ</summary>

**Hex dump выводит данные в HEX + ASCII формате для удобного анализа!**

**Функция:**
```c
void hex_dump(unsigned char *data, int len) {
    printf("Offset   Hex                                            ASCII\n");
    printf("-------- ---------------------------------------------- ----------------\n");
    
    for (int i = 0; i < len; i += 16) {  // По 16 байт на строку
        printf("%08X ", i);  // Offset
        
        // Hex часть:
        for (int j = 0; j < 16; j++) {
            if (i + j < len) {
                printf("%02X ", data[i + j]);  // Байт в HEX
            } else {
                printf("   ");  // Заполнитель
            }
        }
        
        printf(" ");
        
        // ASCII часть:
        for (int j = 0; j < 16 && i + j < len; j++) {
            unsigned char c = data[i + j];
            printf("%c", (c >= 32 && c <= 126) ? c : '.');  // Печатный символ или точка
        }
        
        printf("\n");
    }
}
```

**Пример вывода (перехваченный пакет в 19:47):**
```
Offset   Hex                                            ASCII
-------- ---------------------------------------------- ----------------
00000000 43 6F 6F 72 64 69 6E 61 74 65 73 3A 20 35 35  Coordinates: 55
00000010 2E 37 35 32 30 C2 B0 4E 20 33 37 2E 36 31 37  .7520°N 37.617
00000020 35 C2 B0 45                                    5°E
```

**Почему полезно:**

1. **Видно сырые данные:**
   - HEX: точное представление байтов
   - ASCII: читаемый текст (если есть)

2. **Нечитаемые символы видны:**
   ```
   00000000 54 61 72 67 65 74 00 FF 0A 63 6F 6E 66 69 72  Target...confir
   00000010 6D 65 64                                    med
              ↑     ↑  ↑
           0x00  0xFF 0x0A (нечитаемые = точки)
   ```

3. **Бинарные данные:**
   Если payload зашифрован → HEX показывает всё!

4. **Дебаггинг:**
   Видно каждый байт → легко найти проблемы

**В миссии:**
```c
// Перехватили пакет агентов Z.:
unsigned char *payload = buffer + ip_len + tcp_len;
int payload_len = ntohs(ip->tot_len) - ip_len - tcp_len;

printf("=== PAYLOAD ===\n");
hex_dump(payload, payload_len);

// Вывод:
// 43 6F 6F 72... = "Coordinates: 55.7520°N 37.6175°E"
// ВЫ ВИДИТЕ КООРДИНАТЫ SAFE HOUSE!
```

**Урок:** Hex dump = рентген данных. Видно ВСЁ: текст, бинарные данные, нечитаемые символы!
</details>

**8. В payload пакета (19:48) обнаружена строка "Order: Continue monitoring". Как её извлечь из hex dump?**

<details>
<summary>Ответ</summary>

**Просто прочитать ASCII колонку или конвертировать HEX в символы!**

**Метод 1: Читать ASCII колонку hex_dump:**
```
Offset   Hex                                            ASCII
-------- ---------------------------------------------- ----------------
00000000 4F 72 64 65 72 3A 20 43 6F 6E 74 69 6E 75 65  Order: Continue
00000010 20 6D 6F 6E 69 74 6F 72 69 6E 67 2E           monitoring.
         ↑                                             ↑
       HEX                                          ASCII (читаемо!)
```

**Метод 2: Конвертировать HEX → ASCII в коде:**
```c
unsigned char payload[] = {
    0x4F, 0x72, 0x64, 0x65, 0x72, 0x3A, 0x20, 
    0x43, 0x6F, 0x6E, 0x74, 0x69, 0x6E, 0x75, 0x65, 0x20,
    0x6D, 0x6F, 0x6E, 0x69, 0x74, 0x6F, 0x72, 0x69, 0x6E, 0x67, 0x2E
};

// Вывести как строку:
for (int i = 0; i < sizeof(payload); i++) {
    printf("%c", payload[i]);
}
printf("\n");

// Вывод: "Order: Continue monitoring."
```

**Автоматическое извлечение ASCII:**
```c
void extract_ascii(unsigned char *data, int len) {
    printf("ASCII Text: ");
    for (int i = 0; i < len; i++) {
        unsigned char c = data[i];
        if (c >= 32 && c <= 126) {  // Печатный символ?
            printf("%c", c);
        } else {
            printf(".");  // Нечитаемый → точка
        }
    }
    printf("\n");
}

// Использование:
extract_ascii(payload, payload_len);
// Вывод: "Order: Continue monitoring."
```

**В миссии (19:48):**
```c
// Перехватили третий пакет:
struct iphdr *ip = (struct iphdr*)buffer;
struct tcphdr *tcp = (struct tcphdr*)(buffer + ip->ihl * 4);

int ip_len = ip->ihl * 4;
int tcp_len = tcp->doff * 4;
unsigned char *payload = buffer + ip_len + tcp_len;
int payload_len = ntohs(ip->tot_len) - ip_len - tcp_len;

// Hex dump:
hex_dump(payload, payload_len);

// ASCII extraction:
extract_ascii(payload, payload_len);
// Вывод: "Order: Continue monitoring. Do not engage."

// ВЫ УЗНАЛИ: Агенты НЕ АТАКУЮТ (yet)!
```

**Урок:** Payload в plaintext = читается легко. Просто конвертируй HEX → ASCII!
</details>

**9. Почему в перехваченном пакете (20:30) `tcp->psh` флаг установлен и что это значит для миссии?**

<details>
<summary>Ответ</summary>

**PSH (Push) флаг = "немедленно отправить данные приложению"!**

**TCP флаги:**
```c
struct tcphdr {
    ...
    uint16_t fin:1,  // Закрыть соединение
             syn:1,  // Начать соединение
             rst:1,  // Сбросить соединение
             psh:1,  // PUSH (отправить сейчас!)
             ack:1,  // Подтверждение
             urg:1,  // Срочные данные
             ece:1, cwr:1;  // ECN флаги
};
```

**Что делает PSH:**

Обычно TCP буферизует данные:
```
Приложение отправляет: "Hello"
TCP: "Подожду ещё данных..."
       "...может ещё отправят?"
       "...соберу побольше в один пакет"

После timeout или заполнения буфера:
TCP: "Ок, отправляю!"
```

С PSH флагом:
```
Приложение: send("Hello", MSG_MORE=OFF)
TCP: "PSH установлен → ОТПРАВИТЬ СЕЙЧАС!"
     → Пакет уходит немедленно
```

**Код проверки:**
```c
struct tcphdr *tcp = (struct tcphdr*)(buffer + ip_len);

if (tcp->psh) {
    printf("PSH флаг установлен → данные важны!\n");
    // Это интерактивное сообщение (SSH, chat, команда)
}
```

**В миссии (20:30):**
```
Перехвачен пакет от агентов Z.:
  tcp->psh = 1  ← PSH установлен!
  Payload: "Agent Krylov: En route to target location. ETA: 22:00"

Почему PSH:
├─ Это КРИТИЧЕСКОЕ сообщение
├─ Агенты отправили НЕМЕДЛЕННО (не буферизовали)
├─ PSH = приоритет высокий!
└─> Это не рутинная коммуникация — это ПРИКАЗ!
```

**PSH vs нет PSH:**
```
БЕЗ PSH (рутинный трафик):
  tcp->psh = 0
  "Status: All quiet. Monitoring continues."
  → Обычная проверка

С PSH (важное сообщение):
  tcp->psh = 1
  "Agent Krylov: En route! ETA: 22:00"
  → СРОЧНО!
```

**Признаки интерактивного трафика:**
- SSH сессия → каждая команда с PSH
- Chat (Telegram, WhatsApp) → каждое сообщение с PSH
- HTTP POST → обычно с PSH
- Bulk transfer (скачивание файла) → БЕЗ PSH

**В пактет sniffer:**
```c
if (tcp->psh && ntohs(tcp->dest) == 9999) {
    printf("⚠️ ВАЖНОЕ СООБЩЕНИЕ АГЕНТОВ Z.!\n");
    hex_dump(payload, payload_len);
    // Это не рутина — анализируй!
}
```

**Урок:** PSH = приоритет! Если видите PSH на порту 9999 → это важное сообщение агентов!
</details>

---

## 💬 СЮЖЕТНАЯ СЦЕНА: Перехват пакета с Крыловым — ETA 22:00!

```
╔══════════════════════════════════════════════════════════╗
║  ВРЕМЯ:   20:30, среда, 1 октября                       ║
║  СОБЫТИЕ: 📡 КРИТИЧЕСКИЙ ПАКЕТ ПЕРЕХВАЧЕН!              ║
╚══════════════════════════════════════════════════════════╝
```

Вы продолжаете мониторинг. Packet sniffer работает. Анна предупредила. Ghost раскрыт. Но внезапно — новый пакет!

**Терминал:**

```bash
$ sudo ./packet_sniffer

═══════════════════════════════════════════════
    MOONLIGHT PACKET SNIFFER v1.0
═══════════════════════════════════════════════

Listening on all interfaces...
Filtering for port 9999...

[20:30:12] 📡 TCP PACKET CAPTURED!

From: 127.0.0.1:9999
To:   127.0.0.1:54321
Protocol: TCP
Flags: PSH ACK  ← PSH установлен! (важное сообщение!)
Seq: 42000
Payload size: 128 bytes

=== PAYLOAD HEX DUMP ===

Offset   Hex                                            ASCII
-------- ---------------------------------------------- ----------------
00000000 41 67 65 6E 74 20 4B 72 79 6C 6F 76 3A 20 45  Agent Krylov: E
00000010 6E 20 72 6F 75 74 65 20 74 6F 20 74 61 72 67  n route to targ
00000020 65 74 20 6C 6F 63 61 74 69 6F 6E 2E 0A 45 54  et location..ET
00000030 41 3A 20 32 32 3A 30 30 20 28 32 20 68 6F 75  A: 22:00 (2 hou
00000040 72 73 29 2E 0A 0A 4F 72 64 65 72 73 3A 20 53  rs)...Orders: S
00000050 75 72 76 65 69 6C 6C 61 6E 63 65 20 6F 6E 6C  urveillance onl
00000060 79 2E 20 44 6F 20 6E 6F 74 20 65 6E 67 61 67  y. Do not engag
00000070 65 2E 0A 54 61 72 67 65 74 20 69 73 20 76 61  e..Target is va
00000080 6C 75 61 62 6C 65 2E 20 43 61 70 74 75 72 65  luable. Capture
00000090 20 61 6C 69 76 65 2E                           alive.

=== ASCII TEXT ===

Agent Krylov: En route to target location.
ETA: 22:00 (2 hours).

Orders: Surveillance only. Do not engage.
Target is valuable. Capture alive.

Safe house coordinates: 55.7520°N 37.6175°E

Next node: 10.0.0.1:4433
Protocol: Encrypted TCP
Objective: Intercept encrypted stream

═══════════════════════════════════════════════
```

**💀 ШОК! ПОЛКОВНИК КРЫЛОВ ЕДЕТ К ВАМ!**

**Вы смотрите на экран. Холод внутри.**

```
Agent Krylov: En route to target location.
ETA: 22:00 (2 hours).
```

**Сейчас 20:30. Через 90 минут Крылов будет ЗДЕСЬ!**

Телефон вибрирует — SMS от Ghost (Алекса Соколова):

```
┌──────────────────────────────────────────────┐
│  FROM: Ghost (Алекс Соколов)                 │
│  TIME: 20:32                                 │
├──────────────────────────────────────────────┤
│                                              │
│  Видел перехват.                             │
│  Крылов будет через 75 минут.                │
│                                              │
│  Я ЗНАЮ ЕГО ТАКТИКУ:                         │
│                                              │
│  Он приедет с 3-4 агентами.                  │
│  Блокирует все выходы.                       │
│  Потребует добровольной сдачи.               │
│                                              │
│  Если откажешься:                            │
│  - Штурм (спецназ)                           │
│  - Слезоточивый газ                          │
│  - Захват силой                              │
│                                              │
│  НО:                                         │
│                                              │
│  У нас есть план.                            │
│  Виктор организует встречу.                  │
│  Дмитрий помогает с logistics.               │
│  Анна создаст помехи.                        │
│                                              │
│  ЗАВЕРШАЙ МИССИЮ.                            │
│  Перехвати всё что можешь.                   │
│  Затем готовься к эвакуации.                 │
│                                              │
│  Доверься процессу.                          │
│  Мы тебя прикроем.                           │
│                                              │
│  — A.S.                                      │
│                                              │
└──────────────────────────────────────────────┘
```

**Что вы узнали:**
- ✅ Крылов едет ЛИЧНО (не просто агенты наблюдения!)
- ✅ ETA 22:00 = через 90 минут
- ✅ Тактика: блокировка → требование → штурм (если отказ)
- ✅ "Capture alive" = для допроса (не убьют!)
- ✅ Координаты следующего узла: 10.0.0.1:4433 (Episode 12!)
- ✅ Ghost, Дмитрий, Анна готовят план эвакуации

Вы смотрите на часы. **20:32.** Время идёт.

Packet sniffer продолжает работу. Каждый пакет — ценная информация. Каждая секунда — на счету.

**Охотник стал добычей. Но добыча знает, что охотник идёт.**

**Информационная война продолжается.**

---

## 🎯 Миссия: "Packet Sniffer"

### Легенда

Агенты противника обмениваются сообщениями на порту **9999**. V. подозревает, что в пакетах скрыта координата следующего узла.

**Ваша задача**: перехватить TCP трафик и извлечь скрытое сообщение.

**Протокол коммуникации**:
```
Agent A → Agent B: TCP 127.0.0.1:54321 → 127.0.0.1:9999
Payload: [зашифрованные данные]

Agent B → Agent A: TCP 127.0.0.1:9999 → 127.0.0.1:54321
Payload: [ответ]
```

**Скрытое сообщение**: извлекается из **payload** каждого пакета на порт 9999.

---

### Технические требования

**1. Создать raw socket для TCP**:
```c
int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
```

**2. Перехватывать пакеты**:
```c
while (1) {
    recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, NULL);
    // Парсинг
}
```

**3. Извлечь информацию**:
- Source IP:Port
- Destination IP:Port
- TCP flags (SYN, ACK, PSH, FIN)
- Payload (данные после TCP заголовка)

**4. Фильтровать по порту 9999**

**5. Hex dump payload**

**6. Извлечь секретное сообщение** (ASCII символы из payload)

---

## 📝 Структура эпизода

```
episode-11-packet-analysis/
├── README.md              ← Вы здесь
├── mission.md
├── starter.c              ← Шаблон packet sniffer
├── artifacts/
│   └── packet_sniffer.c   ← Создайте этот файл
├── solution/
│   ├── packet_sniffer_solution.c
│   └── traffic_generator.c  ← Генератор тестового трафика
└── tests/
    └── test.sh
```

### 💡 Как работать:

1. **Изучите** `starter.c` — там базовый raw socket с TODO
2. **Создайте** файл `artifacts/packet_sniffer.c`
3. **Реализуйте** packet sniffing:
   - Создание raw socket (`SOCK_RAW`, `IPPROTO_TCP`)
   - Парсинг IP заголовка (`struct iphdr`)
   - Парсинг TCP заголовка (`struct tcphdr`)
   - Извлечение payload
   - Фильтрация по порту 9999
   - Hex dump и ASCII extraction
4. **Скомпилируйте**: `gcc -Wall -o packet_sniffer artifacts/packet_sniffer.c`
5. **Запустите с sudo**: `sudo ./packet_sniffer`

> 💡 **Для тестирования**: используйте `solution/traffic_generator.c` для генерации тестовых пакетов!

---

### Подсказки

<details>
<summary>Как создать raw socket?</summary>

```c
#include <sys/socket.h>
#include <netinet/ip.h>

int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
if (sockfd < 0) {
    perror("socket (are you root?)");
    exit(1);
}
```

**Важно**: запускайте с `sudo`!
</details>

<details>
<summary>Как парсить заголовки?</summary>

```c
unsigned char buffer[65536];
ssize_t size = recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, NULL);

// IP header
struct iphdr *ip = (struct iphdr*)buffer;
int ip_len = ip->ihl * 4;

// TCP header (после IP)
struct tcphdr *tcp = (struct tcphdr*)(buffer + ip_len);
int tcp_len = tcp->doff * 4;

// Payload
unsigned char *payload = buffer + ip_len + tcp_len;
int payload_len = ntohs(ip->tot_len) - ip_len - tcp_len;
```
</details>

<details>
<summary>Как фильтровать по порту?</summary>

```c
uint16_t src_port = ntohs(tcp->source);
uint16_t dst_port = ntohs(tcp->dest);

if (dst_port == 9999 || src_port == 9999) {
    printf("Target traffic detected!\n");
    // Обработать
}
```
</details>

<details>
<summary>Как извлечь ASCII из payload?</summary>

```c
printf("ASCII: ");
for (int i = 0; i < payload_len; i++) {
    if (payload[i] >= 32 && payload[i] <= 126) {
        printf("%c", payload[i]);
    } else {
        printf(".");
    }
}
printf("\n");
```
</details>

---

## ✅ Проверка

```bash
# Компиляция
gcc -Wall -o packet_sniffer artifacts/packet_sniffer.c

# В одном терминале: генератор трафика
gcc -Wall -o traffic_gen solution/traffic_generator.c
./traffic_gen &

# В другом терминале: sniffer (с sudo!)
sudo ./packet_sniffer

# Остановить генератор
pkill traffic_gen
```

**Критерии успеха**:
- Raw socket создан успешно
- Парсит IP и TCP заголовки
- Извлекает payload
- Фильтрует по порту 9999
- Выводит hex dump
- Извлекает ASCII сообщение
- Находит скрытое сообщение

---

## 🎬 DEBRIEFING

```
╔══════════════════════════════════════════════════════════╗
║  ЛОКАЦИЯ: Квартира, район Арбат, Москва                 ║
║  ВРЕМЯ:   22:35, среда, 1 октября                       ║
║  СТАТУС:  🟢 MESSAGE INTERCEPTED                         ║
╚══════════════════════════════════════════════════════════╝
```

`packet_sniffer` запущен с sudo. Перехват начат. Результат:

```
=== PACKET SNIFFER ===
Listening on all interfaces...
Filtering for port 9999

[Packet #1]
From: 127.0.0.1:54321 → 127.0.0.1:9999
Protocol: TCP
Flags: PSH ACK
Payload (24 bytes):

Offset   Hex                                  ASCII
-------- ------------------------------------ ----------------
00000000 54 68 65 20 6E 65 78 74 20 6E 6F 64 The next nod
00000010 65 3A 20 31 30 2E 30 2E 30 2E 31     e: 10.0.0.1

Decoded: "The next node: 10.0.0.1"

[Packet #2]
From: 127.0.0.1:9999 → 127.0.0.1:54321
Protocol: TCP
Flags: PSH ACK
Payload (18 bytes):

Offset   Hex                                  ASCII
-------- ------------------------------------ ----------------
00000000 50 6F 72 74 3A 20 34 34 33 33 0A     Port: 4433.

🎯 HIDDEN MESSAGE EXTRACTED:
┌─────────────────────────────────────────┐
│  Next node: 10.0.0.1:4433               │
│  Protocol: Encrypted TCP                │
│  Mission: Episode 12                    │
└─────────────────────────────────────────┘
```

**Что вы узнали:**
- **Raw sockets** дают полный контроль над пакетами
- **IP и TCP заголовки** содержат всю информацию о коммуникации
- **Payload** — это данные после заголовков
- Следующий узел: **10.0.0.1:4433** (зашифрованный канал)

В 22:33 финальное сообщение от V.:

```
┌─────────────────────────────────────────┐
│  FROM: V.                               │
├─────────────────────────────────────────┤
│                                         │
│  Ты научился перехватывать.             │
│  Теперь финал: РАСШИФРОВКА.             │
│                                         │
│  Episode 12: Encrypted Communications   │
│  Все знания соберутся воедино.          │
│                                         │
│  10.0.0.1:4433 ждёт тебя.               │
│                                         │
│  — V.                                   │
└─────────────────────────────────────────┘
```

**Видеть пакеты — это сила. Понимать их — это искусство.**

### 🎖️ Навык разблокирован:
**"Packet Master"** — Вы видите сеть на уровне байтов. Raw sockets больше не тайна.

---

## 📝 КОНТРОЛЬНЫЕ ВОПРОСЫ

Проверьте понимание Episode 11 (все вопросы основаны на сюжете контр-слежки):

### 🟢 Базовое понимание (4 вопроса)

**1. В 19:47 вы перехватили ВТОРОЙ ПАКЕТ с координатами "55.7520°N 37.6175°E". Почему это был шок?**

<details>
<summary>Ответ</summary>

**Это координаты ВАШЕГО safe house! Агенты Z. знают, где вы находитесь!**

**Что произошло:**
```
19:47 → Второй пакет (From: 127.0.0.1:9999 → 127.0.0.1:54321)
        Payload: "Coordinates: 55.7520°N 37.6175°E"
                 "Status: Under surveillance"
                 "Agent count: 1"
```

**Анализ:**
- Координаты точно указывают на ваше убежище
- "Under surveillance" = вас активно отслеживают
- "Agent count: 1" = они знают, что вы один

**Технически:**
```c
// В packet_sniffer вы извлекли payload:
char *payload_start = (char*)(packet + ip_header_len + tcp_header_len);
int payload_len = total_len - ip_header_len - tcp_header_len;

// И увидели:
// "Coordinates: 55.7520°N 37.6175°E"
```

**Осознание:** "Охотник стал добычей" — вы следили за ними, но **ОНИ тоже следят за ВАМИ**.

**Урок:** Packet sniffing — обоюдоострый меч. Если вы можете перехватывать трафик, то и противник может.
</details>

**2. Почему для запуска packet_sniffer нужны ROOT права (sudo)?**

<details>
<summary>Ответ</summary>

**Потому что raw sockets требуют привилегированного доступа к сетевому стеку!**

**Причина безопасности:**
```c
// Создание raw socket:
int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
// ^^^ Только root может делать это!

if (sockfd < 0) {
    perror("socket");  // "Operation not permitted" без sudo
    exit(1);
}
```

**Почему root?**
1. **Raw socket видит ВСЕ пакеты:**
   - Включая пакеты других пользователей
   - Включая зашифрованные соединения
   - Это нарушение конфиденциальности!

2. **Можно подделать пакеты:**
   - С любым source IP
   - С любым source port
   - Спуфинг атак, man-in-the-middle

3. **Обход firewall:**
   - Raw sockets работают на уровне IP
   - Минуют многие защиты

**В миссии:**
```bash
$ ./packet_sniffer
socket: Operation not permitted  ← Без sudo!

$ sudo ./packet_sniffer
Listening on all interfaces...  ✓
```

**Альтернативы (без root):**
- `pcap` библиотека (но нужны права на интерфейс)
- `tcpdump` с setuid (небезопасно)
- Docker с capabilities (CAP_NET_RAW)

**Урок:** Raw sockets = мощный инструмент, требует ответственности.
</details>

**3. В 20:00 вы осознали, что агенты Z. ТОЖЕ используют packet sniffing. Как они могли перехватить ваш трафик?**

<details>
<summary>Ответ</summary>

**Они на том же сетевом сегменте или имеют доступ к маршрутизатору!**

**Сценарий 1: Shared network (WiFi, общая сеть):**
```
       ВАШ КОМПЬЮТЕР              АГЕНТ Z.
           📱                         👤
            │                         │
            └────────┬────────────────┘
                     │
                 [WiFi Router]
                 
→ Агент Z. включает promiscuous mode на WiFi:
  sudo ifconfig wlan0 promisc
  sudo tcpdump -i wlan0
  
→ Видит ВСЕ пакеты в WiFi сети, включая ваши!
```

**Сценарий 2: Man-in-the-Middle (ARP spoofing):**
```c
// Агент Z. отправляет поддельные ARP пакеты:
// "Я — это маршрутизатор!"
// Весь трафик идёт через него
```

**Сценарий 3: Компрометированный роутер:**
```
Агенты Z. взломали WiFi роутер safe house
→ Настроили port mirroring
→ Весь трафик копируется им
```

**В миссии:**
- Safe house компрометирован
- Агенты Z. имеют доступ к локальной сети
- Они запустили свой packet_sniffer
- Перехватывают ваши соединения

**Защита:**
- VPN (шифрование трафика)
- HTTPS (TLS)
- Сменить safe house (физическая безопасность)

**Урок:** Безопасность сети = безопасность физическая + криптография.
</details>

**4. Что означает флаг "PSH ACK" в перехваченных TCP пакетах?**

<details>
<summary>Ответ</summary>

**PSH = "Push" (немедленно отправить), ACK = "Acknowledgment" (подтверждение)**

**Расшифровка:**
```c
struct tcphdr *tcp = (struct tcphdr*)(packet + ip_header_len);

if (tcp->psh) {
    printf("Флаг PSH установлен → немедленная отправка\n");
    // Данные НЕ буферизуются, отправляются сразу
}

if (tcp->ack) {
    printf("Флаг ACK установлен → подтверждение получения\n");
    printf("ACK number: %u\n", ntohl(tcp->ack_seq));
}
```

**PSH (Push):**
- Приложение хочет отправить данные НЕМЕДЛЕННО
- Не ждать заполнения TCP буфера
- Типично для интерактивного трафика (SSH, telnet, chat)

**ACK (Acknowledgment):**
- Подтверждаю получение данных с seq = ack_seq - 1
- Присутствует почти во всех TCP пакетах (кроме первого SYN)

**В миссии (Пакет #1):**
```
[Packet #1]
From: 127.0.0.1:54321 → 127.0.0.1:9999
Flags: PSH ACK
Payload: "Target confirmed. Location: Safe house."
```

**Почему PSH ACK?**
- Агент Z. отправил сообщение
- PSH = "отправь немедленно, не буферизуй" (срочное сообщение!)
- ACK = "подтверждаю получение предыдущих данных"

**Другие флаги:**
- SYN = установка соединения
- FIN = завершение соединения
- RST = аварийный сброс
- URG = срочные данные

**Урок:** Флаги раскрывают характер коммуникации (срочность, состояние сессии).
</details>

---

### 🟡 Практика (5 вопросов)

**5. В коде вы используете `IPPROTO_TCP` для фильтрации. Как перехватить ТОЛЬКО UDP пакеты?**

<details>
<summary>Ответ</summary>

**Создать raw socket с `IPPROTO_UDP`:**

```c
// Для TCP (из миссии):
int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);

// Для UDP:
int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);

// Для ВСЕХ протоколов:
int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_IP);
```

**UDP packet sniffer:**
```c
#include <netinet/udp.h>  // struct udphdr

// ...receive packet...

// Парсинг IP заголовка (аналогично TCP)
struct iphdr *ip = (struct iphdr*)buffer;
int ip_header_len = ip->ihl * 4;

// Парсинг UDP заголовка
struct udphdr *udp = (struct udphdr*)(buffer + ip_header_len);

printf("UDP Source port: %u\n", ntohs(udp->source));
printf("UDP Dest port: %u\n", ntohs(udp->dest));
printf("UDP Length: %u\n", ntohs(udp->len));
printf("UDP Checksum: 0x%04X\n", ntohs(udp->check));

// Payload
int udp_header_len = sizeof(struct udphdr);  // Всегда 8 байт
char *payload = (char*)(buffer + ip_header_len + udp_header_len);
int payload_len = ntohs(udp->len) - udp_header_len;
```

**Отличия UDP vs TCP:**
```
TCP заголовок: 20+ байт (переменный размер из-за опций)
UDP заголовок: 8 байт (фиксированный)

TCP: seq, ack_seq, flags, window...
UDP: только source, dest, len, checksum
```

**В миссии:**
- Агенты Z. используют TCP (порт 9999)
- Но могли бы использовать UDP (быстрее, меньше следов)
- Для перехвата UDP нужно изменить только `IPPROTO_TCP` → `IPPROTO_UDP`

**Урок:** Raw sockets работают со всеми протоколами (TCP, UDP, ICMP, ...).
</details>

**6. Как отфильтровать пакеты ТОЛЬКО с порта 9999, а не всех портов?**

<details>
<summary>Ответ</summary>

**Проверить source/dest port в TCP заголовке:**

```c
struct tcphdr *tcp = (struct tcphdr*)(buffer + ip_header_len);

uint16_t src_port = ntohs(tcp->source);
uint16_t dst_port = ntohs(tcp->dest);

// Фильтр: только порт 9999
#define TARGET_PORT 9999

if (src_port == TARGET_PORT || dst_port == TARGET_PORT) {
    printf("[Packet on port 9999]\n");
    printf("From: %s:%u → ", src_ip_str, src_port);
    printf("%s:%u\n", dst_ip_str, dst_port);
    
    // Обработать payload
    // ...
} else {
    // Пропустить
    continue;
}
```

**В миссии:**
```c
// Перехват ВСЕХ TCP пакетов:
int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);

while (1) {
    // Получить пакет
    recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, NULL);
    
    // Парсинг
    struct iphdr *ip = (struct iphdr*)buffer;
    struct tcphdr *tcp = (struct tcphdr*)(buffer + ip->ihl * 4);
    
    // ФИЛЬТР по порту
    if (ntohs(tcp->source) == 9999 || ntohs(tcp->dest) == 9999) {
        printf("MATCHED! Port 9999 packet\n");
        // Извлечь payload агентов Z.
    }
}
```

**Альтернатива: BPF (Berkeley Packet Filter):**
```c
// С libpcap можно задать фильтр:
pcap_compile(handle, &fp, "tcp port 9999", 0, PCAP_NETMASK_UNKNOWN);
pcap_setfilter(handle, &fp);
// Kernel будет фильтровать автоматически (эффективнее!)
```

**Урок:** Фильтрация в user space vs kernel space (BPF быстрее).
</details>

**7. В 19:46 первый пакет содержал "Target confirmed". Как определить, какой пакет пришёл первым, если они перемешаны?**

<details>
<summary>Ответ</summary>

**Использовать TCP sequence numbers!**

```c
struct tcphdr *tcp = (struct tcphdr*)(buffer + ip_header_len);

uint32_t seq = ntohl(tcp->seq);
uint32_t ack_seq = ntohl(tcp->ack_seq);

printf("SEQ: %u\n", seq);
printf("ACK: %u\n", ack_seq);
```

**Сортировка пакетов:**
```c
typedef struct {
    uint32_t seq;
    char payload[1024];
    int payload_len;
} Packet;

Packet packets[100];
int packet_count = 0;

// При получении пакета:
packets[packet_count].seq = ntohl(tcp->seq);
memcpy(packets[packet_count].payload, payload, payload_len);
packets[packet_count].payload_len = payload_len;
packet_count++;

// Сортировка по SEQ:
qsort(packets, packet_count, sizeof(Packet), compare_seq);

int compare_seq(const void *a, const void *b) {
    Packet *pa = (Packet*)a;
    Packet *pb = (Packet*)b;
    
    if (pa->seq < pb->seq) return -1;
    if (pa->seq > pb->seq) return 1;
    return 0;
}

// Теперь packets[0] — первый пакет!
```

**В миссии:**
```
[Packet #1] SEQ=1000: "Target confirmed. Location: Safe house."
[Packet #2] SEQ=1048: "Coordinates: 55.7520°N 37.6175°E"
[Packet #3] SEQ=1112: "Order: Continue monitoring."
```

**Почему SEQ важен:**
- Пакеты могут прийти в любом порядке (routing, retransmit)
- SEQ определяет истинный порядок
- Следующий пакет: SEQ = предыдущий SEQ + payload_len

**Урок:** TCP sequence numbers = timestamp данных (для упорядочивания потока).
</details>

**8. Что такое "promiscuous mode" и зачем он нужен для packet sniffing?**

<details>
<summary>Ответ</summary>

**Promiscuous mode = "принимать ВСЕ пакеты, даже не адресованные тебе"**

**Нормальный режим:**
```
Сетевая карта фильтрует пакеты:
├─ Пакеты с вашим MAC → принять
├─ Broadcast пакеты → принять
└─ Остальные → ОТБРОСИТЬ
```

**Promiscuous mode:**
```
Сетевая карта принимает ВСЁ:
├─ Пакеты с вашим MAC → принять
├─ Пакеты с чужим MAC → принять!
├─ Broadcast → принять
└─ Всё остальное → принять!
```

**Включение в коде:**
```c
#include <sys/ioctl.h>
#include <net/if.h>

int sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));

// Получить имя интерфейса
struct ifreq ifr;
strncpy(ifr.ifr_name, "eth0", IFNAMSIZ);

// Включить promiscuous mode
ioctl(sockfd, SIOCGIFFLAGS, &ifr);
ifr.ifr_flags |= IFF_PROMISC;
ioctl(sockfd, SIOCSIFFLAGS, &ifr);

printf("Promiscuous mode enabled on eth0\n");
```

**В миссии:**
- Без promiscuous: видите только свои пакеты
- С promiscuous: видите пакеты агентов Z. (порт 9999)

**На WiFi:**
- Ещё сложнее (Monitor mode)
- Нужно видеть пакеты других устройств
- `airmon-ng start wlan0`

**Легальность:**
⚠️ В своей сети: OK  
⚠️ В чужой сети: НЕЗАКОННО (перехват чужого трафика)

**Урок:** Promiscuous mode = основа всех сетевых анализаторов (Wireshark, tcpdump).
</details>

**9. Как вычислить длину payload в перехваченном пакете?**

<details>
<summary>Ответ</summary>

**`total_len - ip_header_len - tcp_header_len`:**

```c
// 1. Получить пакет
char buffer[65536];
ssize_t total_len = recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, NULL);

// 2. Парсинг IP заголовка
struct iphdr *ip = (struct iphdr*)buffer;
int ip_header_len = ip->ihl * 4;  // ihl в 32-bit словах
// ihl=5 → 5*4=20 байт (минимальный IP заголовок)

// 3. Парсинг TCP заголовка
struct tcphdr *tcp = (struct tcphdr*)(buffer + ip_header_len);
int tcp_header_len = tcp->doff * 4;  // doff в 32-bit словах
// doff=5 → 5*4=20 байт (минимальный TCP заголовок)

// 4. Вычислить payload
char *payload = (char*)(buffer + ip_header_len + tcp_header_len);
int payload_len = total_len - ip_header_len - tcp_header_len;

if (payload_len > 0) {
    printf("Payload (%d bytes):\n", payload_len);
    for (int i = 0; i < payload_len; i++) {
        printf("%c", payload[i]);
    }
    printf("\n");
}
```

**Пример (Пакет #1 из миссии):**
```
total_len = 84 байт (от recvfrom)
ip_header_len = 20 байт (стандартный)
tcp_header_len = 20 байт (без опций)

payload_len = 84 - 20 - 20 = 44 байт
payload = "Target confirmed. Location: Safe house.\n"
```

**Важно:**
- `ihl` и `doff` — в 32-bit словах, НЕ байтах!
- Минимум: IP=20 байт, TCP=20 байт
- Максимум: IP=60 байт (с опциями), TCP=60 байт
- Payload может быть 0 (ACK без данных)

**Проверка:**
```c
if (payload_len < 0) {
    fprintf(stderr, "Invalid packet (negative payload)\n");
    continue;
}
```

**Урок:** Payload = "то, ради чего всё это" (реальные данные приложения).
</details>

---

### 🔴 Анализ кода (3 вопроса)

**10. Найдите ошибку в этом коде извлечения payload:**

```c
struct iphdr *ip = (struct iphdr*)buffer;
struct tcphdr *tcp = (struct tcphdr*)(buffer + 20);  // ← ОШИБКА?
char *payload = (char*)(buffer + 40);
int payload_len = total_len - 40;
```

<details>
<summary>Ответ</summary>

**Ошибка: hardcoded размеры заголовков!**

**Проблемы:**

1. **IP заголовок не всегда 20 байт:**
   ```c
   struct tcphdr *tcp = (struct tcphdr*)(buffer + 20);  // ❌
   ```
   - Может быть 20-60 байт (IP опции!)
   - Нужно: `ip->ihl * 4`

2. **TCP заголовок не всегда 20 байт:**
   ```c
   char *payload = (char*)(buffer + 40);  // ❌ (20+20)
   ```
   - Может быть 20-60 байт (TCP опции!)
   - Нужно: `tcp->doff * 4`

3. **Payload offset неправильный:**
   ```c
   int payload_len = total_len - 40;  // ❌
   ```

**Правильный код:**
```c
struct iphdr *ip = (struct iphdr*)buffer;
int ip_header_len = ip->ihl * 4;  // ✓ Динамический!

struct tcphdr *tcp = (struct tcphdr*)(buffer + ip_header_len);
int tcp_header_len = tcp->doff * 4;  // ✓ Динамический!

char *payload = (char*)(buffer + ip_header_len + tcp_header_len);
int payload_len = total_len - ip_header_len - tcp_header_len;
```

**Что произойдёт при ошибке:**
- Пакет с IP опциями (ihl=6, 24 байта)
- `buffer + 20` → неправильный offset
- Читаем мусор вместо TCP заголовка
- Payload содержит часть TCP заголовка
- Невозможно декодировать данные агентов Z.!

**Урок:** Никогда не hardcode размеры протокольных заголовков!
</details>

**11. Почему этот код может читать мусор?**

```c
char buffer[1024];
int n = recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, NULL);
printf("Payload: %s\n", (char*)(buffer + 40));  // ← ПРОБЛЕМА?
```

<details>
<summary>Ответ</summary>

**Проблема: `%s` требует null-terminated строку, а payload может не иметь `\0`!**

**Что происходит:**
```c
printf("Payload: %s\n", (char*)(buffer + 40));
```

- `%s` читает до `\0`
- Payload агентов Z. может НЕ иметь `\0` в конце
- `printf` продолжит читать за пределы payload
- → Чтение мусора, возможно segfault!

**Пример (безопасный вывод):**
```c
char *payload = (char*)(buffer + ip_header_len + tcp_header_len);
int payload_len = total_len - ip_header_len - tcp_header_len;

// Вариант 1: посимвольно
for (int i = 0; i < payload_len; i++) {
    printf("%c", payload[i]);
}
printf("\n");

// Вариант 2: создать null-terminated копию
char safe_payload[1024];
memcpy(safe_payload, payload, payload_len);
safe_payload[payload_len] = '\0';  // Добавить \0
printf("Payload: %s\n", safe_payload);

// Вариант 3: precision в printf
printf("Payload: %.*s\n", payload_len, payload);
//                ^^^ печатать только payload_len символов
```

**В миссии:**
```
Payload (без \0): "Target confirmed. Location: Safe house."
Следующие байты в памяти: [random garbage]

printf("%s") → "Target confirmed...Safe house.[мусор][мусор]..."
```

**Урок:** Сетевые данные — это байты, НЕ C-строки!
</details>

**12. В чём проблема этого фильтра по IP?**

```c
struct iphdr *ip = (struct iphdr*)buffer;

if (ip->saddr == inet_addr("127.0.0.1")) {  // ← ОШИБКА?
    printf("From localhost\n");
}
```

<details>
<summary>Ответ</summary>

**Ошибка: сравнение network byte order с host byte order!**

**Проблема:**
```c
if (ip->saddr == inet_addr("127.0.0.1")) {  // ❌
```

- `ip->saddr` — в **network byte order** (big-endian)
- `inet_addr()` — возвращает **host byte order** на некоторых системах (НЕ portable!)
- Сравнение может провалиться!

**Правильный вариант:**
```c
// Вариант 1: Конвертировать в строку и сравнивать
char src_ip_str[INET_ADDRSTRLEN];
struct in_addr src_addr;
src_addr.s_addr = ip->saddr;  // Уже в network byte order
inet_ntop(AF_INET, &src_addr, src_ip_str, INET_ADDRSTRLEN);

if (strcmp(src_ip_str, "127.0.0.1") == 0) {
    printf("From localhost\n");
}

// Вариант 2: Использовать inet_pton
struct in_addr expected;
inet_pton(AF_INET, "127.0.0.1", &expected);  // → network byte order

if (ip->saddr == expected.s_addr) {  // ✓ Оба в network byte order
    printf("From localhost\n");
}

// Вариант 3: Прямое сравнение с учётом byte order
if (ntohl(ip->saddr) == 0x7F000001) {  // 127.0.0.1
    printf("From localhost\n");
}
```

**В миссии (корректный код):**
```c
struct in_addr src_addr;
src_addr.s_addr = ip->saddr;
char src_ip[INET_ADDRSTRLEN];
inet_ntop(AF_INET, &src_addr, src_ip, INET_ADDRSTRLEN);

// Теперь можно сравнивать строки
printf("From: %s\n", src_ip);
```

**Урок:** Всегда используйте `inet_ntop`/`inet_pton` для конвертации IP!
</details>

---

### 🎯 Сюжет (2 вопроса)

**13. В 20:15 V. написал: "Они следят за тобой. Но теперь ТЫ следишь за ними." Как это возможно — взаимный перехват?**

<details>
<summary>Ответ</summary>

**Оба используют packet sniffing в одной сети = взаимная прозрачность!**

**Сценарий:**
```
         SAFE HOUSE NETWORK
         
    ВЫ                      АГЕНТЫ Z.
    📱                         👤
     │                         │
     ├──> packet_sniffer       ├──> packet_sniffer
     │    (перехват порта 9999)│    (перехват ВСЕХ портов)
     │                         │
     └────────┬────────────────┘
              │
          [WiFi Router]
```

**Что происходит:**

1. **Агенты Z. перехватывают ВАШ трафик:**
   - Видят ваши подключения к серверу V. (Episode 10)
   - Узнают ваши координаты через GPS в IP
   - Отслеживают ваши действия

2. **ВЫ перехватываете ИХ трафик:**
   - Видите их коммуникацию на порту 9999
   - Узнаёте, что они знают о вас
   - Получаете инте о следующем узле

**Технически:**
```c
// Ваш sniffer:
if (ntohs(tcp->source) == 9999 || ntohs(tcp->dest) == 9999) {
    // Пакеты агентов Z.!
}

// Их sniffer:
if (ntohs(tcp->source) == 31337 || ntohs(tcp->dest) == 31337) {
    // Пакеты к серверу V.!
}
```

**Почему это работает:**
- Shared medium (WiFi, Ethernet hub)
- Promiscuous mode видит всё
- Шифрования нет → всё в plaintext

**Защита:**
- VPN (зашифрует весь трафик)
- TLS/SSL (Episode 12)
- Физическая изоляция (другая сеть)

**Урок:** В открытой сети все видят всех. Шифрование обязательно.
</details>

**14. Вы перехватили "Next node: 10.0.0.1:4433" в пакете агентов Z. Почему это важно для Episode 12?**

<details>
<summary>Ответ</summary>

**Это ПОДТВЕРЖДЕНИЕ адреса следующего узла от V.!**

**Что произошло:**

**Episode 10:**
```
10:51 → Подключились к серверу V. (203.0.113.42:31337)
        Получили: "Следующий узел: 10.0.0.1:4433"
```

**Episode 11:**
```
20:30 → Перехватили пакет агентов Z.:
        "Next node: 10.0.0.1:4433"
        "Protocol: Encrypted TCP"
        "Objective: Intercept encrypted stream"
```

**Анализ:**
1. **V. дал адрес:** 10.0.0.1:4433
2. **Агенты Z. ТОЖЕ знают адрес:** 10.0.0.1:4433
3. **Значит:** Они тоже пытаются подключиться!

**Почему важно:**
- Подтверждение: адрес правильный
- Опасность: агенты Z. на том же пути
- Задача Episode 12: перехватить зашифрованный поток БЫСТРЕЕ них

**В Episode 12:**
```
02:12 → V.: "Перехватить TCP-поток на 10.0.0.1:4433"
        "Расшифровать XOR"
        "Узнать координаты встречи"
        
→ Вы должны успеть ДО агентов Z.!
```

**Сюжетная линия:**
```
Episode 09: Нашли IP 203.0.113.42 (GPS → Красная площадь)
Episode 10: Подключились к 203.0.113.42:31337 (получили узел 2)
Episode 11: Подтвердили узел 2 через перехват агентов Z.
Episode 12: Расшифруете узел 2 → встреча с V. на Красной площади
```

**Урок:** Packet sniffing даёт разведданные о планах противника.
</details>

---

### 🚀 Продвинутые (1 вопрос)

**15. В сюжете агенты Z. знают координаты safe house (55.7520°N 37.6175°E). Могли ли они вычислить это из перехваченных пакетов?**

<details>
<summary>Ответ</summary>

**Да! Через корреляцию трафика, timing анализ и geolocation!**

**Способы:**

**1. GPS в пакетах (если вы их отправляли):**
```c
// Ваш код (гипотетически):
char msg[100];
snprintf(msg, sizeof(msg), "Status: Active at %f,%f", lat, lon);
send(sockfd, msg, strlen(msg), 0);

// Агенты Z. перехватывают → видят координаты!
```

**2. Timing analysis (задержки пакетов):**
```
Вы → Сервер V. (203.0.113.42)
Задержка RTT: 45 ms

Агенты Z. анализируют:
- RTT 45ms → примерно 1000 км от сервера
- Сервер в Москве → вы тоже в Москве
- Сужение круга поиска
```

**3. WiFi triangulation:**
```bash
# Агенты Z. сканируют WiFi:
$ iwlist wlan0 scan

ESSID: "SafeHouse_Guest"
MAC: AA:BB:CC:DD:EE:FF
Signal: -45 dBm  ← Очень близко!

# Trilateration с нескольких точек:
→ Вычисляют местоположение роутера
→ Координаты safe house
```

**4. IP Geolocation:**
```bash
$ curl "http://ip-api.com/json/YOUR_PUBLIC_IP"

{
  "lat": 55.7520,
  "lon": 37.6175,
  "city": "Moscow",
  "district": "Arbat"
}
```

**5. Traffic correlation:**
```
19:46 → Ваш пакет к V.: отправлен
19:46 → Пакет Z.: "Target confirmed. Location: Safe house."

Корреляция времени → вы в safe house!
```

**6. MAC адрес вашего устройства:**
```c
// В Ethernet frame:
struct ether_header {
    uint8_t ether_dhost[6];  // MAC назначения
    uint8_t ether_shost[6];  // ВАШ MAC!
    uint16_t ether_type;
};

// Агенты Z. видят ваш MAC
// → База данных производителей
// → Модель устройства
// → Возможно, история перемещений (если WiFi)
```

**Защита:**

```c
// 1. VPN (скрывает реальный IP)
sudo openvpn moonlight.ovpn

// 2. Tor (анонимность)
torify ./moonlight_client

// 3. MAC randomization
sudo ifconfig wlan0 hw ether DE:AD:BE:EF:CA:FE

// 4. Шифрование (TLS/SSL)
// Координаты не видны в plaintext

// 5. Физическая смена локации
// Переехать из safe house!
```

**В миссии:**
- Вы НЕ использовали VPN
- Агенты Z. в той же сети
- Perехватили трафик → вычислили координаты
- **Результат:** Safe house скомпрометирован

**Урок:** Метаданные (timing, geolocation, MAC) могут раскрыть местоположение даже без GPS в payload.
</details>

---

**🎓 Оценка:**
- **13-15 правильных** — Packet Master! Готовы к Episode 12 ✅
- **10-12 правильных** — Хорошо, но повторите promiscuous mode 📖
- **< 10 правильных** — Перечитайте Episode 11 и попробуйте packet sniffer 🔄

---

## 🥚 Easter Eggs

<details>
<summary>🔍 Отсылки и секреты</summary>

**Персонажи и сюжет:**

1. **"Призрак" = Алекс Соколов** (20:18) — САМОЕ ВАЖНОЕ раскрытие Season 3!
   - Ex-FSB, Управление 'K' (контрразведка) — реальное подразделение ФСБ
   - 5 лет искал Виктора → 6 месяцев назад перешёл на его сторону
   - Теперь часть команды (Season 4-10!)

2. **Анна Ковалёва** (20:20) — forensics specialist:
   - Работала с Виктором 2 года назад (до событий Season 1)
   - Детали слежки: Lada Granta X999XX77 (реалистичный номер)
   - 100м от подъезда, смена каждые 6 часов (профессиональная слежка)

3. **Полковник Крылов** — первое ПРЯМОЕ противостояние:
   - Бывший начальник Алекса (личная драма!)
   - ETA 22:00 = 2 часа до прибытия (deadline!)
   - "Capture alive" = вы ценны для них (не убьют!)

4. **Координаты 55.7520°N 37.6175°E** — ВАША ПОЗИЦИЯ:
   - Расстояние от Episode 09 (55.7558°N 37.6173°E = Красная площадь): ~500м!
   - Safe house рядом с Красной площадью (центр Москвы)
   - Крылов знает точное местоположение!

5. **Взаимная слежка** — "Охотник становится добычей":
   - Вы перехватываете ИХ пакеты
   - ОНИ перехватывают ВАШИ пакеты
   - Информационная война (кто кого переиграет?)

**Технические детали:**

6. **Raw sockets** — основа Wireshark, tcpdump, Snort (реальные инструменты)
7. **Port 9999** — часто в малварах (backdoor port)
8. **10.0.0.1** — private IP класса A, внутренняя сеть
9. **Promiscuous mode** — термин из радиоперехвата (принимать всё)
10. **struct iphdr** — прямой доступ к сетевому стеку Linux
11. **PSH flag** — "push", немедленная отправка (интерактивный трафик)
12. **СОРМ** — реальная российская система оперативно-розыскных мероприятий (SORM)
13. **Управление 'K'** — реальное подразделение ФСБ (контрразведка)
14. **Hex dump format** — классический формат из `hexdump -C`
15. **ETA 22:00** — 2 часа = точный timing для эвакуации в Episode 12!

**Сюжетные связи:**

16. **Алекс Соколов** — будет ключевым в Season 4-10:
   - Season 4: помощь с криптографией (ex-FSB опыт)
   - Season 6: авионика + embedded (связь с Дмитрием!)
   - Season 10: финальная операция (все союзники вместе!)

17. **Крылов vs Призрак** — личная вендетта:
   - Бывший начальник vs бывший подчинённый
   - Будет развиваться в Season 4-10

18. **Анна** — появится снова:
   - Season 2 Ep08 (?) — возможно упоминание
   - Season 4+ — forensics эксперт команды

**Философия эпизода**: *"Сеть прозрачна для тех, кто знает, как смотреть. Raw socket — это рентген. Но каждый охотник может стать добычей."*

**Accumulating Cast:**
- Season 1 → Виктор, Дмитрий, "Призрак" (UNKNOWN), Крылов (упоминание)
- Season 2 → Виктор, Дмитрий, Анна Ковалёва (?)
- Season 3 Ep11 → "Призрак" РАСКРЫТ! + Анна + Крылов (активная роль)
- Персонажи накапливаются и возвращаются!

</details>

---

## 🔗 Навигация

- [← Episode 10: Socket Programming](../episode-10-socket-programming/README.md)
- [→ Episode 12: Encrypted Communications](../episode-12-encrypted-communications/README.md)
- [📋 Season 3: Networks](../README.md)
- [🏠 Главная страница](../../README.md)

---

> *"In the network, everything is visible. You just need to know where to look."* — V.