/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Episode 16: Data Structures â€” ĞŸÑ€Ğ¾Ğ¼ĞµĞ¶ÑƒÑ‚Ğ¾Ñ‡Ğ½Ğ°Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ°
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Ğ—ĞĞ”ĞĞ§Ğ: Floyd's Cycle Detection Algorithm
 * 
 * Ğ’ Episode 06 (Season 2) Ğ²Ñ‹ ÑÑ‚Ğ¾Ğ»ĞºĞ½ÑƒĞ»Ğ¸ÑÑŒ Ñ "pointer chase":
 * Ğ´Ğ²Ğµ Ñ†ĞµĞ¿Ğ¾Ñ‡ĞºĞ¸ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹, Ğ¾Ğ´Ğ½Ğ° Ğ¸Ğ· ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ğ±Ñ‹Ğ»Ğ° Ğ·Ğ°Ñ†Ğ¸ĞºĞ»ĞµĞ½Ğ°!
 * 
 * Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞµĞ¼ Ğ£ĞĞ˜Ğ’Ğ•Ğ Ğ¡ĞĞ›Ğ¬ĞĞ«Ğ™ Ğ´ĞµÑ‚ĞµĞºÑ‚Ğ¾Ñ€ Ñ†Ğ¸ĞºĞ»Ğ¾Ğ² Ğ² linked list.
 * 
 * ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼: "Ğ§ĞµÑ€ĞµĞ¿Ğ°Ñ…Ğ° Ğ¸ Ğ—Ğ°ÑÑ†" (Floyd, 1967)
 * Ğ’Ñ€ĞµĞ¼Ñ: O(n), ĞŸĞ°Ğ¼ÑÑ‚ÑŒ: O(1)
 * 
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef struct Node {
    int data;
    struct Node *next;
} Node;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ—ĞĞ”ĞĞĞ˜Ğ• 1: Floyd's Cycle Detection â­â­â­â˜†â˜†
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ñ†Ğ¸ĞºĞ»Ğ° Ğ² linked list.
 * 
 * ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ "Ğ§ĞµÑ€ĞµĞ¿Ğ°Ñ…Ğ° Ğ¸ Ğ—Ğ°ÑÑ†":
 * - Slow pointer Ğ´Ğ²Ğ¸Ğ¶ĞµÑ‚ÑÑ Ğ½Ğ° 1 ÑˆĞ°Ğ³
 * - Fast pointer Ğ´Ğ²Ğ¸Ğ¶ĞµÑ‚ÑÑ Ğ½Ğ° 2 ÑˆĞ°Ğ³Ğ°
 * - Ğ•ÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ñ†Ğ¸ĞºĞ» â†’ Ğ²ÑÑ‚Ñ€ĞµÑ‚ÑÑ‚ÑÑ
 * - Ğ•ÑĞ»Ğ¸ Ğ½ĞµÑ‚ Ñ†Ğ¸ĞºĞ»Ğ° â†’ fast Ğ´Ğ¾Ğ¹Ğ´Ñ‘Ñ‚ Ğ´Ğ¾ NULL
 * 
 * Ğ’Ñ€ĞµĞ¼Ñ: O(n)
 * ĞŸĞ°Ğ¼ÑÑ‚ÑŒ: O(1)  â† Ğ’ĞĞ–ĞĞ! Ğ‘ĞµĞ· Ğ´Ğ¾Ğ¿. ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€!
 * 
 * @param head  Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ° ÑĞ¿Ğ¸ÑĞºĞ°
 * @return      true ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ñ†Ğ¸ĞºĞ», false Ğ¸Ğ½Ğ°Ñ‡Ğµ
 */
bool has_cycle(Node *head) {
    // TODO: Ğ ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞ¹Ñ‚Ğµ Floyd's algorithm
    // 
    // ĞŸĞ¾Ğ´ÑĞºĞ°Ğ·ĞºĞ°:
    // Node *slow = head;
    // Node *fast = head;
    // 
    // while (fast != NULL && fast->next != NULL) {
    //     slow = slow->next;        // 1 ÑˆĞ°Ğ³
    //     fast = fast->next->next;  // 2 ÑˆĞ°Ğ³Ğ°
    //     
    //     if (slow == fast) {
    //         // Ğ’ÑÑ‚Ñ€ĞµÑ‚Ğ¸Ğ»Ğ¸ÑÑŒ! Ğ•ÑÑ‚ÑŒ Ñ†Ğ¸ĞºĞ»
    //     }
    // }
    
    return false;  // TODO: Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚Ğµ Ğ½Ğ° Ñ€ĞµĞ°Ğ»ÑŒĞ½ÑƒÑ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ—ĞĞ”ĞĞĞ˜Ğ• 2: ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ Ñ†Ğ¸ĞºĞ»Ğ° â­â­â­â­â˜†
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ ÑƒĞ·ĞµĞ», Ğ³Ğ´Ğµ Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ĞµÑ‚ÑÑ Ñ†Ğ¸ĞºĞ».
 * 
 * ĞŸĞ¾ÑĞ»Ğµ Ğ¾Ğ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ Ğ²ÑÑ‚Ñ€ĞµÑ‡Ğ¸ slow Ğ¸ fast:
 * - Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒ slow Ğº head
 * - Ğ”Ğ²Ğ¸Ğ³Ğ°Ñ‚ÑŒ Ğ¾Ğ±Ğ° pointer Ğ¿Ğ¾ 1 ÑˆĞ°Ğ³Ñƒ
 * - Ğ“Ğ´Ğµ Ğ²ÑÑ‚Ñ€ĞµÑ‚ÑÑ‚ÑÑ â†’ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ Ñ†Ğ¸ĞºĞ»Ğ°!
 * 
 * ĞœĞ°Ñ‚ĞµĞ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ´Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒÑÑ‚Ğ²Ğ¾:
 * ĞŸÑƒÑÑ‚ÑŒ L = Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¾Ñ‚ head Ğ´Ğ¾ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ñ†Ğ¸ĞºĞ»Ğ°
 *      C = Ğ´Ğ»Ğ¸Ğ½Ğ° Ñ†Ğ¸ĞºĞ»Ğ°
 *      x = Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¾Ñ‚ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ñ†Ğ¸ĞºĞ»Ğ° Ğ´Ğ¾ Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ²ÑÑ‚Ñ€ĞµÑ‡Ğ¸
 * 
 * Slow Ğ¿Ñ€Ğ¾ÑˆÑ‘Ğ»: L + x
 * Fast Ğ¿Ñ€Ğ¾ÑˆÑ‘Ğ»: L + x + nC (Ğ³Ğ´Ğµ n >= 1)
 * 
 * Fast Ğ² 2Ã— Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ:
 * 2(L + x) = L + x + nC
 * L + x = nC
 * L = nC - x
 * 
 * Ğ¡Ğ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾: Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¾Ñ‚ head Ğ´Ğ¾ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ñ†Ğ¸ĞºĞ»Ğ° (L)
 * Ñ€Ğ°Ğ²Ğ½Ğ¾ Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ¾Ñ‚ Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ²ÑÑ‚Ñ€ĞµÑ‡Ğ¸ Ğ´Ğ¾ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ñ†Ğ¸ĞºĞ»Ğ° (nC - x)!
 * 
 * @param head  Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ° ÑĞ¿Ğ¸ÑĞºĞ°
 * @return      Ğ£ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğ° Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ Ñ†Ğ¸ĞºĞ»Ğ°, Ğ¸Ğ»Ğ¸ NULL ĞµÑĞ»Ğ¸ Ñ†Ğ¸ĞºĞ»Ğ° Ğ½ĞµÑ‚
 */
Node* find_cycle_start(Node *head) {
    // TODO: Ğ ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ¸ÑĞº Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ñ†Ğ¸ĞºĞ»Ğ°
    // 
    // 1. Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ½Ğ°Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ²ÑÑ‚Ñ€ĞµÑ‡Ğ¸ (ĞºĞ°Ğº Ğ² has_cycle)
    // 2. Ğ’ĞµÑ€Ğ½Ğ¸Ñ‚Ğµ slow Ğº head
    // 3. Ğ”Ğ²Ğ¸Ğ³Ğ°Ğ¹Ñ‚Ğµ Ğ¾Ğ±Ğ° Ğ¿Ğ¾ 1 ÑˆĞ°Ğ³Ñƒ
    // 4. Ğ“Ğ´Ğµ Ğ²ÑÑ‚Ñ€ĞµÑ‚ÑÑ‚ÑÑ â†’ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ Ñ†Ğ¸ĞºĞ»Ğ°
    
    return NULL;  // TODO
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ—ĞĞ”ĞĞĞ˜Ğ• 3: Ğ”Ğ»Ğ¸Ğ½Ğ° Ñ†Ğ¸ĞºĞ»Ğ° â­â­â­â˜†â˜†
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ Ğ´Ğ»Ğ¸Ğ½Ñƒ Ñ†Ğ¸ĞºĞ»Ğ°.
 * 
 * ĞŸĞ¾ÑĞ»Ğµ Ğ²ÑÑ‚Ñ€ĞµÑ‡Ğ¸ slow Ğ¸ fast:
 * - Ğ—Ğ°Ñ„Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾
 * - Ğ”Ğ²Ğ¸Ğ³Ğ°Ñ‚ÑŒ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾ ĞºÑ€ÑƒĞ³Ñƒ
 * - Ğ¡Ñ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ ÑˆĞ°Ğ³Ğ¸ Ğ´Ğ¾ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¾Ğ¹ Ğ²ÑÑ‚Ñ€ĞµÑ‡Ğ¸
 * 
 * @param head  Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ° ÑĞ¿Ğ¸ÑĞºĞ°
 * @return      Ğ”Ğ»Ğ¸Ğ½Ğ° Ñ†Ğ¸ĞºĞ»Ğ°, Ğ¸Ğ»Ğ¸ 0 ĞµÑĞ»Ğ¸ Ñ†Ğ¸ĞºĞ»Ğ° Ğ½ĞµÑ‚
 */
int cycle_length(Node *head) {
    // TODO: Ğ ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ´ÑÑ‡Ñ‘Ñ‚ Ğ´Ğ»Ğ¸Ğ½Ñ‹ Ñ†Ğ¸ĞºĞ»Ğ°
    
    return 0;  // TODO
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ—ĞĞ”ĞĞĞ˜Ğ• 4: Ğ Ğ°Ğ·Ğ¾Ñ€Ğ²Ğ°Ñ‚ÑŒ Ñ†Ğ¸ĞºĞ» â­â­â­â­â˜†
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Ğ Ğ°Ğ·Ñ€Ñ‹Ğ²Ğ°ĞµÑ‚ Ñ†Ğ¸ĞºĞ», Ğ´ĞµĞ»Ğ°Ñ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ»Ğ¸Ğ½ĞµĞ¹Ğ½Ñ‹Ğ¼.
 * 
 * ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ ÑƒĞ·ĞµĞ» Ñ†Ğ¸ĞºĞ»Ğ° Ğ¸ ÑƒÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ next = NULL.
 * 
 * @param head  Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ° ÑĞ¿Ğ¸ÑĞºĞ°
 * @return      true ĞµÑĞ»Ğ¸ Ñ†Ğ¸ĞºĞ» Ğ±Ñ‹Ğ» Ñ€Ğ°Ğ·Ğ¾Ñ€Ğ²Ğ°Ğ½, false ĞµÑĞ»Ğ¸ Ñ†Ğ¸ĞºĞ»Ğ° Ğ½Ğµ Ğ±Ñ‹Ğ»Ğ¾
 */
bool break_cycle(Node *head) {
    // TODO: ĞĞ°Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ Ñ†Ğ¸ĞºĞ»Ğ°
    // TODO: ĞĞ°Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ ÑƒĞ·ĞµĞ» Ğ¿ĞµÑ€ĞµĞ´ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾Ğ¼ Ñ†Ğ¸ĞºĞ»Ğ°
    // TODO: Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğµ ĞµĞ³Ğ¾ next = NULL
    
    return false;  // TODO
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ (ÑƒĞ¶Ğµ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ñ‹)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Node* create_node(int data) {
    Node *node = (Node*)malloc(sizeof(Node));
    node->data = data;
    node->next = NULL;
    return node;
}

void print_list_safe(Node *head, int max_nodes) {
    printf("List: ");
    Node *current = head;
    int count = 0;
    
    while (current != NULL && count < max_nodes) {
        printf("%d", current->data);
        if (current->next != NULL && count < max_nodes - 1) {
            printf(" -> ");
        }
        current = current->next;
        count++;
    }
    
    if (count == max_nodes && current != NULL) {
        printf(" -> [CYCLE DETECTED]");
    }
    
    printf("\n");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¸
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void test_no_cycle() {
    printf("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘ TEST 1: ĞĞµÑ‚ Ñ†Ğ¸ĞºĞ»Ğ° (1->2->3->4->5)            â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    Node *n1 = create_node(1);
    Node *n2 = create_node(2);
    Node *n3 = create_node(3);
    Node *n4 = create_node(4);
    Node *n5 = create_node(5);
    
    n1->next = n2;
    n2->next = n3;
    n3->next = n4;
    n4->next = n5;
    n5->next = NULL;
    
    print_list_safe(n1, 10);
    
    bool cycle = has_cycle(n1);
    printf("Has cycle: %s\n", cycle ? "YES" : "NO");
    printf("Expected: NO\n");
    
    if (!cycle) {
        printf("âœ… PASS\n");
    } else {
        printf("âŒ FAIL\n");
    }
    
    // Cleanup
    free(n1); free(n2); free(n3); free(n4); free(n5);
}

void test_cycle_at_end() {
    printf("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘ TEST 2: Ğ¦Ğ¸ĞºĞ» Ğ² ĞºĞ¾Ğ½Ñ†Ğµ (1->2->3->4->5->3)      â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    Node *n1 = create_node(1);
    Node *n2 = create_node(2);
    Node *n3 = create_node(3);
    Node *n4 = create_node(4);
    Node *n5 = create_node(5);
    
    n1->next = n2;
    n2->next = n3;
    n3->next = n4;
    n4->next = n5;
    n5->next = n3;  // CYCLE: 5 -> 3
    
    print_list_safe(n1, 10);
    
    bool cycle = has_cycle(n1);
    printf("Has cycle: %s\n", cycle ? "YES" : "NO");
    printf("Expected: YES\n");
    
    Node *start = find_cycle_start(n1);
    if (start != NULL) {
        printf("Cycle starts at node with data: %d\n", start->data);
        printf("Expected: 3\n");
    }
    
    int len = cycle_length(n1);
    printf("Cycle length: %d\n", len);
    printf("Expected: 3 (nodes: 3->4->5->3)\n");
    
    if (cycle && start != NULL && start->data == 3 && len == 3) {
        printf("âœ… PASS\n");
    } else {
        printf("âŒ FAIL\n");
    }
    
    // Ğ Ğ°Ğ·Ñ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ†Ğ¸ĞºĞ» Ğ¿ĞµÑ€ĞµĞ´ cleanup
    break_cycle(n1);
    
    // Cleanup
    free(n1); free(n2); free(n3); free(n4); free(n5);
}

void test_self_loop() {
    printf("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘ TEST 3: Self-loop (1->1)                     â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    Node *n1 = create_node(1);
    n1->next = n1;  // CYCLE: points to itself
    
    printf("List: 1 -> [SELF LOOP]\n");
    
    bool cycle = has_cycle(n1);
    printf("Has cycle: %s\n", cycle ? "YES" : "NO");
    printf("Expected: YES\n");
    
    int len = cycle_length(n1);
    printf("Cycle length: %d\n", len);
    printf("Expected: 1\n");
    
    if (cycle && len == 1) {
        printf("âœ… PASS\n");
    } else {
        printf("âŒ FAIL\n");
    }
    
    // Ğ Ğ°Ğ·Ñ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ†Ğ¸ĞºĞ»
    break_cycle(n1);
    
    // Cleanup
    free(n1);
}

void test_cycle_at_head() {
    printf("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘ TEST 4: Ğ¦Ğ¸ĞºĞ» Ğ¾Ñ‚ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° (1->2->3->1)          â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    Node *n1 = create_node(1);
    Node *n2 = create_node(2);
    Node *n3 = create_node(3);
    
    n1->next = n2;
    n2->next = n3;
    n3->next = n1;  // CYCLE: back to head
    
    print_list_safe(n1, 10);
    
    bool cycle = has_cycle(n1);
    Node *start = find_cycle_start(n1);
    int len = cycle_length(n1);
    
    printf("Has cycle: %s\n", cycle ? "YES" : "NO");
    if (start) printf("Cycle starts at: %d\n", start->data);
    printf("Cycle length: %d\n", len);
    
    printf("Expected: YES, start=1, length=3\n");
    
    if (cycle && start == n1 && len == 3) {
        printf("âœ… PASS\n");
    } else {
        printf("âŒ FAIL\n");
    }
    
    // Ğ Ğ°Ğ·Ñ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ†Ğ¸ĞºĞ»
    break_cycle(n1);
    
    // Cleanup
    free(n1); free(n2); free(n3);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Main
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int main() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘  FLOYD'S CYCLE DETECTION â€” Linked List Cycles             â•‘\n");
    printf("â•‘  Episode 16: Data Structures                              â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    test_no_cycle();
    test_cycle_at_end();
    test_self_loop();
    test_cycle_at_head();
    
    printf("\n");
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘  ğŸ“Š FLOYD'S ALGORITHM SUMMARY                              â•‘\n");
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    printf("â•‘  ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼: \"Ğ§ĞµÑ€ĞµĞ¿Ğ°Ñ…Ğ° Ğ¸ Ğ—Ğ°ÑÑ†\" (Floyd, 1967)               â•‘\n");
    printf("â•‘                                                           â•‘\n");
    printf("â•‘  Ğ’Ñ€ĞµĞ¼Ñ: O(n)                                              â•‘\n");
    printf("â•‘  ĞŸĞ°Ğ¼ÑÑ‚ÑŒ: O(1)  â† ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§ĞĞ! Ğ‘ĞµĞ· Ğ´Ğ¾Ğ¿. ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€!            â•‘\n");
    printf("â•‘                                                           â•‘\n");
    printf("â•‘  ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ:                                              â•‘\n");
    printf("â•‘  1. Ğ”ĞµÑ‚ĞµĞºÑ†Ğ¸Ñ Ñ†Ğ¸ĞºĞ»Ğ¾Ğ² Ğ² linked lists                        â•‘\n");
    printf("â•‘  2. ĞŸĞ¾Ğ¸ÑĞº Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ğ¾Ğ² Ğ² Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ°Ñ… (Leetcode 287)            â•‘\n");
    printf("â•‘  3. ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ñ‹ ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ğ¸ (rho-Ğ¼ĞµÑ‚Ğ¾Ğ´ ĞŸĞ¾Ğ»Ğ»Ğ°Ñ€Ğ´Ğ°)           â•‘\n");
    printf("â•‘  4. Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹ Ğ¿ÑĞµĞ²Ğ´Ğ¾ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ñ… Ñ‡Ğ¸ÑĞµĞ»                      â•‘\n");
    printf("â•‘                                                           â•‘\n");
    printf("â•‘  Season 2 Episode 06 connection:                          â•‘\n");
    printf("â•‘  Ğ¢Ğ¾Ğ³Ğ´Ğ° Ğ²Ñ‹ Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ğ»Ğ¸ Ñ†ĞµĞ¿Ğ¾Ñ‡ĞºÑƒ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹.          â•‘\n");
    printf("â•‘  Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ñ‹ Ğ·Ğ½Ğ°ĞµÑ‚Ğµ ĞĞŸĞ¢Ğ˜ĞœĞĞ›Ğ¬ĞĞ«Ğ™ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ O(1) Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸!      â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    return 0;
}

