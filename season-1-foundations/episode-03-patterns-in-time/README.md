# Episode 03: "Паттерны во времени"
## Season 1: Foundations

> *"В хаосе всегда есть порядок. Нужно лишь научиться его видеть..."*

---

## 🎬 BRIEFING

```
╔══════════════════════════════════════════════════════════════╗
║  ЛОКАЦИЯ: Ваша квартира, район Арбат, Москва               ║
║  ВРЕМЯ:   03:47, среда, 1 октября (глубокая ночь)          ║
║  СТАТУС:  🔴 PATTERN DETECTED - CRITICAL                   ║
╚══════════════════════════════════════════════════════════════╝
```

**03:15**  
Вы уже час анализируете данные из Episode 02. Глаза слипаются, но адреналин не даёт уснуть. На экране — колонки цифр, координат, временных меток.

Внезапно вы видите это.

**03:22**  
Временные метки. Они не случайны:
```
1634567890
1634567900  <-- +10 секунд
1634567910  <-- +10 секунд
1634567920  <-- +10 секунд
```

> *"Строгая периодичность — это не природа. Это машина. Или человек."*

Кто-то передаёт сигнал каждые 10 секунд. Как метроном. Как маяк.

**03:35**  
Вы начинаете наносить координаты на карту. И видите линию. **Маршрут.**

```
    МОСКВА          ЦЮРИХ          БЕРЛИН
      •  ──────────→  •  ──────────→  •
   55.75°N         47.37°N        52.52°N
   37.62°E          8.54°E        13.40°E
```

Точки соединяются. Это не просто данные. Это **след перемещения**.

**03:47**  
Последняя точка ведёт к... московскому дата-центру на Варшавском шоссе. Сервер №1723.

> *"Всё сходится в одной точке. Виктор оставил карту сокровищ. Но сокровище — это сервер с информацией."*

**Проблема:** 1427 записей. Тысячи временных меток. Десятки координат. Вручную не пересчитать.

**Решение:** Нужна программа. Нужны **циклы**. Много циклов.

**Ваша задача:** Написать анализатор паттернов, который найдёт:
1. Периодичность передачи (интервал)
2. Маршрут по координатам
3. PIN-код доступа к серверу (зашит в данных)

---

## 📚 THEORY

> *"Повторение — мать учения. А цикл — отец автоматизации."* — Victor Petrov

### 1. Циклы — автоматизация повторяющихся действий

Представьте: у вас 1000 записей. Обработать вручную? Это смерть. Обработать циклом? 0.001 секунды.

**Циклы** позволяют программам делать одно и то же действие много раз, не копируя код.

#### Цикл for

Используется, когда **заранее известно** сколько раз нужно повторить:

```c
for (int i = 0; i < 10; i++) {
    printf("%d ", i);  // Выведет: 0 1 2 3 4 5 6 7 8 9
}
```

**Структура:**
```c
for (инициализация; условие; шаг) {
    // код
}
```

1. **Инициализация** — выполняется один раз в начале
2. **Условие** — проверяется перед каждой итерацией
3. **Тело цикла** — выполняется, если условие истинно
4. **Шаг** — выполняется после каждой итерации

**Метафора — Конвейер с известным числом шагов:**

```
  for (int i = 0; i < 5; i++)
       │    │      │      │
       │    │      │      └─ Шаг: i++ (двигаем ленту)
       │    │      └──────── Условие: i < 5 (пока не конец)
       │    └─────────────── Старт: i = 0
       └──────────────────── Счётчик позиции

  КОНВЕЙЕР:
  ┌───┬───┬───┬───┬───┐
  │ 0 │ 1 │ 2 │ 3 │ 4 │  ← Обработаем все ящики
  └───┴───┴───┴───┴───┘
    ↑ начало     конец ↑
```

**Реальный пример — обработка данных Виктора:**
```c
int timestamps[5] = {1000, 1010, 1020, 1030, 1040};

for (int i = 0; i < 5; i++) {
    printf("Запись %d: timestamp = %d\n", i, timestamps[i]);
}

// Вывод:
// Запись 0: timestamp = 1000
// Запись 1: timestamp = 1010
// Запись 2: timestamp = 1020
// ...
```

---

### 2. Константы (const) — защита от изменений

**`const`** делает переменную **неизменяемой** (read-only).

```c
const int MAX_ATTEMPTS = 3;
const double PI = 3.14159;
const char* message = "Hello";

// Попытка изменить — ОШИБКА компиляции!
MAX_ATTEMPTS = 5;  // ❌ error: assignment of read-only variable
```

#### Метафора — Страховочный трос альпиниста 🧗

```
         🏔️ ЭВЕРЕСТ (8848 м)
            /\
           /  \
          /    \
         /      \
        /        \
       /          \
      /___________🧗 ← Вы лезете вверх
      
const int MAX_HEIGHT = 8848;  ← Страховочный трос!

// Попытка "прыгнуть выше" — трос не даст!
MAX_HEIGHT = 9000;  // ❌ Компилятор: "Стоп! Нельзя!"
```

**Зачем страховка в коде?**

1. ✅ **Защита от падения (багов)** — случайно не перезапишешь важное значение
2. ✅ **Самодокументация** — видно, что "это не должно меняться!"
3. ✅ **Компилятор = страховщик** — проверит за вас
4. ✅ **Оптимизация** — может поместить в readonly-память

**Визуализация:**

```
БЕЗ const:                      С const:
┌─────────────┐                ┌─────────────┐
│ int max = 3 │ ← Можно менять │const int    │ 🔒 Защищено!
│ max = 100;  │ ✓ OK           │  max = 3;   │
│ max = -5;   │ ✓ OK (баг!)    │ max = 100;  │ ❌ ОШИБКА!
└─────────────┘                └─────────────┘
```

---

#### const с указателями (важно!)

```c
// 1. Указатель на константу (данные нельзя менять)
const int *ptr1;
int const *ptr2;  // То же самое
*ptr1 = 10;       // ❌ ОШИБКА
ptr1 = &x;        // ✅ ОК (сам указатель можно менять)

// 2. Константный указатель (адрес нельзя менять)
int *const ptr3 = &x;
*ptr3 = 10;       // ✅ ОК (данные можно менять)
ptr3 = &y;        // ❌ ОШИБКА (адрес нельзя менять)

// 3. Константный указатель на константу (ничего нельзя менять!)
const int *const ptr4 = &x;
*ptr4 = 10;       // ❌ ОШИБКА
ptr4 = &y;        // ❌ ОШИБКА
```

**Правило чтения:** читаем **справа налево**:
- `const int *ptr` — указатель на **константный int**
- `int *const ptr` — **константный указатель** на int
- `const int *const ptr` — **константный указатель** на **константный int**

---

#### const в функциях

```c
// Обещаем не менять массив
void print_array(const int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    // arr[0] = 999;  // ❌ ОШИБКА компиляции!
}

// Обещаем не менять строку
int string_length(const char *str) {
    int len = 0;
    while (str[len] != '\0') {
        len++;
    }
    return len;
    // str[0] = 'X';  // ❌ ОШИБКА!
}
```

**Польза**: защита от случайных изменений + ясность намерений.

---

#### const vs #define

```c
#define MAX_SIZE 100    // Макрос (текстовая замена)
const int MAX_SIZE = 100; // Константная переменная

// Отличия:
// #define: без типа, без памяти, работает препроцессор
// const: с типом, в памяти (но может быть оптимизирован), проверка типов
```

**Рекомендация**: используйте `const` для типобезопасности, `#define` для размеров массивов и условной компиляции.

**Метафора**: `const` — это печать "не вскрывать" на коробке. Можно смотреть, но не трогать!

---

#### Цикл while

Используется, когда **неизвестно заранее** сколько итераций:

```c
int i = 0;
while (i < 10) {
    printf("%d ", i);
    i++;
}
```

**Метафора — Охранник у двери:**

```
            ┌──────────────┐
            │  ВХОД В КЛУБ │
            └──────┬───────┘
                   │
          ┌────────▼────────┐
          │  ОХРАННИК       │
          │ while (есть ID) │  ← Проверяет ДО входа
          └────────┬────────┘
                   │
        ┌──────────┴──────────┐
     ДА │                     │ НЕТ
    ┌───▼────┐           ┌────▼────┐
    │ ВПУСК  │           │ ОТКАЗ   │
    │ Войти  │           │ Домой   │
    └────────┘           └─────────┘
```

**Реальный пример — чтение данных до конца:**
```c
int timestamp;
int count = 0;

// Читаем, пока есть данные
while (scanf("%d", &timestamp) == 1) {
    printf("Прочитано: %d\n", timestamp);
    count++;
}

printf("Всего записей: %d\n", count);
```

**Важно:** Условие проверяется **перед** каждой итерацией!

---

#### Цикл do-while — Сначала действие, потом проверка

Иногда нужно выполнить код **хотя бы раз**, даже если условие ложно:

```c
int i = 0;
do {
    printf("%d ", i);
    i++;
} while (i < 10);
```

**Разница:** Условие проверяется **после** выполнения тела.

**Визуализация:**
```
     while                      do-while
       │                           │
   ┌───▼───┐                   ┌───▼───┐
   │ ПРОВЕРКА│                  │ ДЕЙСТВИЕ│
   └───┬───┘                   └───┬───┘
  ДА   │   НЕТ                     │
   ┌───▼───┐                   ┌───▼───┐
   │ДЕЙСТВИЕ│                  │ ПРОВЕРКА│
   └───┬───┘                   └───┬───┘
       │                      ДА   │   НЕТ
     (цикл)                    (цикл) (выход)
```

**Реальный пример — Меню программы:**
```c
int choice;
do {
    printf("\n1. Анализ данных\n");
    printf("2. Поиск паттернов\n");
    printf("0. Выход\n");
    printf("Выбор: ");
    scanf("%d", &choice);
    
    // Обработка выбора...
    
} while (choice != 0);  // Повторяем, пока не выбрано 0

printf("До встречи, агент.\n");
```

**Когда использовать:**  
✅ Меню программы (показать минимум раз)  
✅ Ввод с валидацией (запросить минимум раз)  
✅ Игровой цикл (хотя бы один ход)

---

### 2. Управление циклами

#### break — выход из цикла

```c
for (int i = 0; i < 100; i++) {
    if (i == 5) {
        break;  // Выход из цикла при i == 5
    }
    printf("%d ", i);  // 0 1 2 3 4
}
```

**Метафора — Аварийный выход:**

```
  for (int i = 0; i < 1000; i++) {
      if (найдена_улика) {
          break;  ← СТОП! Нашли! Выход из цикла!
      }
  }
  // Продолжаем ниже...
```

**Реальный пример — Поиск в данных:**
```c
int data[] = {10, 25, 42, 17, 99, 3};
int target = 42;
int found_index = -1;

for (int i = 0; i < 6; i++) {
    if (data[i] == target) {
        found_index = i;
        break;  // Нашли! Дальше искать не нужно
    }
}

if (found_index != -1) {
    printf("Найдено на позиции %d\n", found_index);
} else {
    printf("Не найдено\n");
}
```

#### continue — пропустить итерацию

```c
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0) {
        continue;  // Пропустить чётные
    }
    printf("%d ", i);  // 1 3 5 7 9
}
```

**Метафора — Пропустить бракованный товар на конвейере:**

```
  for (int i = 0; i < 10; i++) {
      if (бракованный) {
          continue;  ← Пропустить! К следующему!
      }
      // Обработка хорошего товара
  }
```

**Реальный пример — Фильтрация данных:**
```c
// Вывести только нечётные числа
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0) {
        continue;  // Чётное? Пропускаем!
    }
    printf("%d ", i);  // Только нечётные: 1 3 5 7 9
}
```

---

### 3. Вложенные циклы

Циклы внутри циклов — для многомерных данных:

```c
// Таблица умножения
for (int i = 1; i <= 3; i++) {
    for (int j = 1; j <= 3; j++) {
        printf("%d×%d=%d  ", i, j, i*j);
    }
    printf("\n");
}
```

**Вывод:**
```
1×1=1  1×2=2  1×3=3  
2×1=2  2×2=4  2×3=6  
3×1=3  3×2=6  3×3=9  
```

**Метафора:** Матрёшка — циклы вложены друг в друга.

**Важно:** Внешний цикл = строки, внутренний = столбцы.

---

### 4. Бесконечные циклы

#### Преднамеренные:
```c
while (1) {  // или for (;;)
    // Бесконечный цикл (для серверов, игр)
    if (условие_выхода) break;
}
```

#### Случайные (баги):
```c
for (int i = 0; i < 10; i--) {  // БАГ! i уменьшается!
    printf("%d ", i);  // Бесконечный цикл!
}
```

**Как остановить:** Ctrl+C в терминале.

---

### 5. Паттерны поиска

#### Линейный поиск:
```c
int arr[] = {10, 20, 30, 40, 50};
int target = 30;
int found = -1;

for (int i = 0; i < 5; i++) {
    if (arr[i] == target) {
        found = i;
        break;
    }
}

if (found != -1) {
    printf("Найдено на позиции %d\n", found);
}
```

**Визуализация линейного поиска:**
```
Ищем число 30:

  i=0    i=1    i=2  ← НАЙДЕНО!
   ↓      ↓      ↓
 ┌───┬───┬───┬───┬───┐
 │10 │20 │30 │40 │50 │
 └───┴───┴───┴───┴───┘
  ✗    ✗    ✓    (стоп, break!)
```

#### Поиск максимума:
```c
int arr[] = {3, 7, 2, 9, 1};
int max = arr[0];

for (int i = 1; i < 5; i++) {
    if (arr[i] > max) {
        max = arr[i];
    }
}

printf("Максимум: %d\n", max);
```

**Визуализация поиска максимума:**
```
 ┌───┬───┬───┬───┬───┐
 │ 3 │ 7 │ 2 │ 9 │ 1 │
 └───┴───┴───┴───┴───┘
   ↑   ↑       ↑
  max=3 │       │
     max=7      │
             max=9 ← Финальный максимум!
```

---

## 🎯 MISSION

### Данные

Файл содержит тысячи временных меток и координат. Формат:
```
timestamp latitude longitude
1234567890 55.7558 37.6173
1234567900 55.7560 37.6180
...
```

---

### Задача 1: pattern_finder.c

**Цель:** Найти периодичность в данных

1. Прочитать все временные метки
2. Вычислить интервалы между последовательными метками
3. Найти самый частый интервал (это период передачи)
4. Вывести паттерн

**Подсказка:** Используйте массив для хранения интервалов, затем найдите моду (самое частое значение).

**Шаблон:** См. функцию `pattern_finder_example()` в `starter.c`  
**Ваш файл:** `artifacts/pattern_finder.c`

---

### Задача 2: sequence_analyzer.c

**Цель:** Проанализировать последовательность координат

1. Прочитать координаты в массив
2. Вычислить расстояния между последовательными точками
3. Найти среднее расстояние
4. Найти аномалии (расстояния > 2× среднего)

**Формула расстояния** (упрощённая для малых дистанций):
```c
float distance = sqrt(pow(lat2 - lat1, 2) + pow(lon2 - lon1, 2)) * 111.0;
// × 111 км/градус для приблизительного перевода
```

**Шаблон:** См. функцию `sequence_analyzer_example()` в `starter.c`  
**Ваш файл:** `artifacts/sequence_analyzer.c`

---

### Задача 3: bruteforce.c (Challenge)

**Цель:** Брутфорс-поиск ключа

В данных спрятан 4-значный PIN-код. Метод: контрольная сумма всех байт координат по модулю 10000.

1. Перебрать все варианты от 0000 до 9999
2. Для каждого варианта вычислить контрольную сумму
3. Сравнить с эталонной (дана в конце файла)
4. Найти совпадение = PIN найден

**Примечание:** Это учебный пример брутфорса. Реальные системы используют более сложную защиту!

**Шаблон:** См. функцию `bruteforce_example()` в `starter.c`  
**Ваш файл:** `artifacts/bruteforce.c`

---

## 📝 Структура файлов

```
episode-03-patterns-in-time/
├── README.md           ← Вы здесь
├── mission.md          
├── data.txt            ← Входные данные
├── starter.c           ← Шаблоны и примеры
├── artifacts/
│   ├── pattern_finder.c       ← Создайте этот файл
│   ├── sequence_analyzer.c    ← Создайте этот файл
│   └── bruteforce.c           ← Создайте этот файл
└── tests/
    └── test.sh
```

### 💡 Как работать:

1. **Изучите** `starter.c` — там функции `pattern_finder_example()`, `sequence_analyzer_example()`, `bruteforce_example()`
2. **Создайте** файлы в `artifacts/` для своего кода
3. **Используйте** массивы для хранения данных
4. **Тестируйте** на файле `data.txt`

---

## 🛠 Компиляция

```bash
# Pattern finder
gcc -Wall -Wextra -std=c11 -o pattern artifacts/pattern_finder.c

# Sequence analyzer
gcc -Wall -Wextra -std=c11 -lm -o sequence artifacts/sequence_analyzer.c
# -lm нужен для math.h (sqrt, pow)

# Bruteforce
gcc -Wall -Wextra -std=c11 -o bruteforce artifacts/bruteforce.c
```

---

## 💡 Подсказки

### Подсказка 1: Чтение до EOF
```c
long timestamp;
float lat, lon;

while (scanf("%ld %f %f", &timestamp, &lat, &lon) == 3) {
    // Обработка
}
```

### Подсказка 2: Массив для счётчиков
```c
int intervals[1000] = {0};  // Счётчики для каждого интервала

// После вычисления interval
if (interval < 1000) {
    intervals[interval]++;
}
```

### Подсказка 3: Поиск максимума в массиве
```c
int max_count = 0;
int most_frequent = 0;

for (int i = 0; i < 1000; i++) {
    if (intervals[i] > max_count) {
        max_count = intervals[i];
        most_frequent = i;
    }
}
```

---

## 🎓 Что вы изучите

✅ Цикл `for` (когда известно количество итераций)  
✅ Цикл `while` (условный цикл)  
✅ Цикл `do-while` (минимум одна итерация)  
✅ `break` и `continue`  
✅ Вложенные циклы  
✅ Поиск паттернов в данных  
✅ Простой брутфорс  

---

## 🎬 DEBRIEFING

```
╔═══════════════════════════════════════════════════════════╗
║         🎯 ПАТТЕРН НАЙДЕН! КРИТИЧЕСКАЯ ИНФОРМАЦИЯ        ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  ✓ Период передачи: 10 секунд (точно!)                   ║
║  ✓ Маршрут: Москва → Цюрих → Берлин → ???                ║
║  ✓ Конечная точка: Москва, Варшавское шоссе              ║
║  ✓ Координаты: 55.6470° N, 37.6127° E                    ║
║  ✓ Объект: Дата-центр "STREAM", сервер #1723             ║
║                                                           ║
║  [!] PIN-КОД НАЙДЕН: 4217                                ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**06:15, среда — рассвет**  
Вы откидываетесь на спинку кресла. Глаза красные от напряжения, но в них горит огонь.

**Найдено:**
- 🎯 **Период:** Каждые 10 секунд. Как метроном. Как пульс.
- 🗺️ **Маршрут:** Три города, одна конечная точка — дата-центр в Москве.
- 🔐 **PIN-код:** 4217 — ваш ключ к серверу #1723.

Вы смотрите на адрес. Варшавское шоссе, дата-центр "STREAM". Знакомое место — вы делали пентест для них год назад. Но сервер #1723... этого сервера в документации не было.

> *"Невидимый сервер. Невидимые данные. Виктор всегда любил прятать самое важное на виду."*

За окном разгорается рассвет над Москвой. Но вы не ложитесь спать.

**06:20 — НЕОЖИДАННЫЙ ЗВОНОК**

Ваш телефон вибрирует. **Неизвестный номер.** Не тот, что писал SMS про дедлайн.

Вы не отвечаете. Через 5 секунд — новое сообщение:

```
╔════════════════════════════════════════════╗
║  От: UNKNOWN_2                             ║
║  Время: 06:20                              ║
╠════════════════════════════════════════════╣
║  "НЕ ходи на сервер #1723."                ║
║                                            ║
║  "Это ЛОВУШКА."                            ║
║                                            ║
║  "Доверься мне. — V."                      ║
╚════════════════════════════════════════════╝
```

Кровь стынет в жилах.

**Это... Виктор?**

Но ВИКТОР сам дал вам координаты сервера #1723! В первом сообщении!

Вы перечитываете первое расшифрованное сообщение из Episode 01:

> *"MOONLIGHT activated. They know. Files at old place. Trust only code."*

Там НЕТ упоминания сервера #1723! Вы **сами** нашли его в паттернах координат!

**Два варианта:**

1. 🔴 **Первое сообщение — от Виктора. Второе — от врагов.**  
   Они пытаются отвести вас от цели. Сервер #1723 — это то, что нужно.

2. 🔵 **Второе сообщение — от Виктора. Первое... подделка?**  
   Кто-то знал ваш XOR-ключ. Вас заманили в ловушку с самого начала.

> *"Доверяй только коду..."* — но код может быть подложным.

Вы смотрите на часы: **06:20, среда**. До дедлайна от "UNKNOWN" остаётся **43 часа**.

**Кому верить?**

**Следующий шаг:**  
У вас есть координаты. Есть PIN. Но есть и предупреждение. 

Прежде чем идти на сервер, нужен **инструмент** — программа, которая:
- Автоматически расшифрует сообщения
- Проанализирует паттерны  
- Проверит подлинность данных
- Соберёт всё воедино

И возможно, даст ответ: **кто из двух "Викторов" настоящий?**

Время создавать свой первый профессиональный инструмент.

> *"В этой игре ложь носит маску правды. Но код не лжёт. Код покажет истину."*

**Status:** 🟢 Mission Complete!  
**New Skill Unlocked:** 🔁 Loop Mastery  
**Intel Acquired:** 📍 Server Location + 🔐 PIN Code  
**Next Episode:** Episode 04 - "Первый инструмент"

---

### 📚 Что вы изучили:
- ✅ Циклы for, while, do-while
- ✅ Управление циклами (break, continue)
- ✅ Вложенные циклы
- ✅ Поиск паттернов в данных
- ✅ Брутфорс-методы
- ✅ Алгоритмы поиска (линейный, максимум)
- ✅ const для защиты данных

---

## 🎯 КОНТРОЛЬНЫЕ ВОПРОСЫ

> *"Циклы — это сила программирования. Убедись, что владеешь ими."* — Victor Petrov

### Циклы

1. **for vs while vs do-while:**
   - [ ] Когда использовать `for`?
   - [ ] Когда использовать `while`?
   - [ ] Когда использовать `do-while`?
   - [ ] В чём ключевая разница между `while` и `do-while`?
     <details>
     <summary>Ответ</summary>
     do-while ВСЕГДА выполнится минимум один раз (проверка условия в конце)
     </details>

2. **Управление циклами:**
   - [ ] Что делает `break`?
   - [ ] Что делает `continue`?
   - [ ] Можно ли использовать `break` вне цикла?

3. **Вложенные циклы:**
   - [ ] Сколько раз выполнится тело в этом коде?
     ```c
     for (int i = 0; i < 3; i++) {
         for (int j = 0; j < 2; j++) {
             printf("*");
         }
     }
     ```
     <details>
     <summary>Ответ</summary>
     6 раз (3 × 2 = 6)
     </details>

### const

4. **Константы:**
   - [ ] Зачем использовать `const`?
   - [ ] Можно ли изменить значение `const` переменной?
   - [ ] В чём разница между `const int *ptr` и `int *const ptr`?

5. **const vs #define:**
   - [ ] Когда лучше использовать `const`, а когда `#define`?

### Алгоритмы

6. **Поиск паттернов:**
   - [ ] Что такое "мода" (mode) в статистике?
   - [ ] Как найти самое частое значение в массиве?
   - [ ] Почему важно анализировать интервалы, а не сами значения?

---

### 🏆 Самопроверка

Если вы уверенно ответили на 80%+ вопросов — **готовы к Episode 04!**

Если есть сомнения — **вернитесь к THEORY**.

> *"42 часа до дедлайна. Время на финальный рывок. Создаём инструмент."*

---

## 🔗 Связь между эпизодами

**Из Episode 01 мы взяли:**
- ✅ Массивы → хранение временных меток и координат
- ✅ Цикл `for` → базовая обработка данных

**Из Episode 02 мы взяли:**
- ✅ Условные операторы → фильтрация и валидация
- ✅ Логические операции → комбинирование условий

**Что нового в Episode 03:**
- ✅ Циклы `while` и `do-while` → чтение до EOF
- ✅ `break` и `continue` → управление потоком
- ✅ `const` → защита данных от изменений
- ✅ Алгоритмы поиска → линейный, максимум, мода

**Что будет в Episode 04:**
- 🔜 Функции → модульность кода
- 🔜 Заголовочные файлы (.h) → разделение интерфейса и реализации
- 🔜 Многофайловые проекты → профессиональная структура
- 🔜 struct и typedef → группировка данных
- 🔜 Работа с файлами → чтение/запись

**Прогрессия:**
```
Ep01: ДАННЫЕ          → массивы, циклы for, XOR
  ↓
Ep02: РЕШЕНИЯ         → if/else, switch, валидация
  ↓
Ep03: АНАЛИЗ          → while, паттерны, алгоритмы
  ↓
Ep04: ИНСТРУМЕНТ      → функции, модули, СБОРКА ВСЕГО!
```

**Визуализация прогресса:**
```
 [██████████░░] 75% Season 1 Complete
 
  ✓ Ep01: Данные расшифрованы
  ✓ Ep02: Данные классифицированы  
  ✓ Ep03: Паттерн найден
  ⏳ Ep04: Инструмент... (осталось собрать)
```

> *"От байтов через логику к паттернам. Осталось создать оружие."*

---

## 🎨 Easter Eggs

🔍 **Отсылки в этом эпизоде:**
- 🧠 Поиск паттернов — как в "Beautiful Mind" (фильм про математика Джона Нэша)
- 💻 Брутфорс PIN — классика хакерских сцен из "Матрицы" и "Кто Я"
- 🔍 Анализ последовательностей — дедуктивный метод Шерлока Холмса
- 🗺️ Географический след — как в "Борне" и "Враге государства"
- ⏱️ Периодичность 10 сек — отсылка к Dead Drop протоколам КГБ

**Скрытый код:**  
В адресе сервера "1723" зашифрована дата первого контакта с Виктором: 17.23 (17 февраля в 23:00).

---

**Паттерн найден, агент. Теперь нужны инструменты.**

```c
// PATTERN ANALYSIS: COMPLETE
// LOCATION: IDENTIFIED  
// ACCESS CODE: CRACKED
// NEXT STEP: BUILD DECODER TOOL
// 
// "In patterns we trust. In code we believe."
```

*— Рассвет приносит не только свет, но и ясность. Всё сходится к одной точке...*
