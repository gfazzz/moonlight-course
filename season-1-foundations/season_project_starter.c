/*
 * ═══════════════════════════════════════════════════════════════
 * Season 1 Final Project: moonlight_decoder
 * ═══════════════════════════════════════════════════════════════
 * 
 * Интегрируй свой код из Episode 01-04 в единый инструмент.
 * 
 * Этот decoder будет использоваться в Season 2 и дальше!
 * 
 * Автор: [Твоё имя]
 * Дата: [Сегодня]
 * ═══════════════════════════════════════════════════════════════
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ═══════════════════════════════════════════════════════════════
// TODO: Подключи свои модули
// ═══════════════════════════════════════════════════════════════
// После создания модулей раскомментируй эти строки:

// #include "byte_ops.h"   // Из Episode 01: print_bytes_hex, print_bytes_as_chars
// #include "crypto.h"     // Из Episode 04: xor_decrypt, caesar_decrypt
// #include "utils.h"      // Валидация файлов
// #include "decoder.h"    // Автоопределение шифрования

// ═══════════════════════════════════════════════════════════════
// Константы
// ═══════════════════════════════════════════════════════════════

#define VERSION "1.0.0"
#define MAX_FILE_SIZE (10 * 1024 * 1024)  // 10 MB лимит

// ═══════════════════════════════════════════════════════════════
// TODO: Вспомогательные функции (или вынеси в utils.c)
// ═══════════════════════════════════════════════════════════════

/**
 * Чтение файла в буфер
 * 
 * @param filename Имя файла
 * @param buffer Указатель на буфер (будет выделен malloc)
 * @param size Размер прочитанных данных
 * @return 0 при успехе, -1 при ошибке
 */
int read_file(const char *filename, unsigned char **buffer, size_t *size) {
    // TODO: Реализуй чтение файла
    // 1. Открой файл с fopen(filename, "rb")
    // 2. Определи размер с fseek + ftell
    // 3. Проверь, что размер < MAX_FILE_SIZE
    // 4. Выдели память с malloc
    // 5. Прочитай данные с fread
    // 6. Закрой файл
    // 7. Верни 0 при успехе
    
    printf("TODO: Реализуй read_file()\n");
    return -1;
}

/**
 * Вывод справки
 */
void print_usage(const char *program_name) {
    printf("═══════════════════════════════════════════════════════════════\n");
    printf("  moonlight_decoder v%s\n", VERSION);
    printf("  Season 1 Final Project - Operation MOONLIGHT\n");
    printf("═══════════════════════════════════════════════════════════════\n");
    printf("\n");
    printf("Использование:\n");
    printf("  %s <encrypted_file> [options]\n", program_name);
    printf("\n");
    printf("Опции:\n");
    printf("  -h, --help          Показать эту справку\n");
    printf("  -x, --hex           Вывести результат в hex формате\n");
    printf("  -o <file>           Сохранить результат в файл\n");
    printf("  -k <key>            Указать XOR ключ вручную (hex)\n");
    printf("\n");
    printf("Примеры:\n");
    printf("  %s message.enc\n", program_name);
    printf("  %s data.bin --hex\n", program_name);
    printf("  %s secret.dat -o output.txt\n", program_name);
    printf("\n");
}

// ═══════════════════════════════════════════════════════════════
// Main функция
// ═══════════════════════════════════════════════════════════════

int main(int argc, char *argv[]) {
    // ═══════════════════════════════════════════════════════════
    // Шаг 1: Парсинг аргументов командной строки
    // ═══════════════════════════════════════════════════════════
    
    // TODO: Проверь количество аргументов
    if (argc < 2) {
        print_usage(argv[0]);
        return 1;
    }
    
    // TODO: Обработай флаги --help, --hex, -o, -k
    const char *input_filename = argv[1];
    int hex_output = 0;              // TODO: Установи в 1, если флаг --hex
    const char *output_filename = NULL;  // TODO: Установи, если флаг -o
    unsigned char manual_key = 0;    // TODO: Установи, если флаг -k
    
    printf("═══════════════════════════════════════════════════════════════\n");
    printf("  moonlight_decoder v%s\n", VERSION);
    printf("═══════════════════════════════════════════════════════════════\n\n");
    
    // ═══════════════════════════════════════════════════════════
    // Шаг 2: Чтение зашифрованного файла
    // ═══════════════════════════════════════════════════════════
    
    printf("[*] Чтение файла: %s\n", input_filename);
    
    unsigned char *data = NULL;
    size_t data_size = 0;
    
    // TODO: Прочитай файл в буфер
    // if (read_file(input_filename, &data, &data_size) != 0) {
    //     fprintf(stderr, "[!] Ошибка чтения файла\n");
    //     return 1;
    // }
    
    printf("[✓] Прочитано байт: %zu\n\n", data_size);
    
    // ═══════════════════════════════════════════════════════════
    // Шаг 3: Определение типа шифрования
    // ═══════════════════════════════════════════════════════════
    
    printf("[*] Анализ типа шифрования...\n");
    
    // TODO: Используй функцию из decoder.h
    // int encryption_type = detect_encryption_type(data, data_size);
    int encryption_type = 0;  // Временная заглушка
    
    // TODO: Выведи определённый тип
    switch (encryption_type) {
        case 1:  // ENCRYPTION_XOR
            printf("[✓] Обнаружено: XOR шифрование\n\n");
            break;
        case 2:  // ENCRYPTION_CAESAR
            printf("[✓] Обнаружено: Caesar cipher\n\n");
            break;
        default:
            printf("[?] Тип шифрования неизвестен\n\n");
            break;
    }
    
    // ═══════════════════════════════════════════════════════════
    // Шаг 4: Расшифровка
    // ═══════════════════════════════════════════════════════════
    
    printf("[*] Расшифровка...\n");
    
    // TODO: Расшифруй данные в зависимости от типа
    if (encryption_type == 1) {  // XOR
        // TODO: Если manual_key != 0, используй его
        // Иначе используй crack_xor_key() из crypto.h
        
        // unsigned char key = manual_key ? manual_key : crack_xor_key(data, data_size);
        // printf("[*] XOR ключ: 0x%02X\n", key);
        // xor_decrypt(data, data_size, key);
        
        printf("TODO: Реализуй XOR расшифровку\n");
        
    } else if (encryption_type == 2) {  // Caesar
        // TODO: Определи shift и расшифруй
        // int shift = crack_caesar_shift(data, data_size);
        // caesar_decrypt((char*)data, shift);
        
        printf("TODO: Реализуй Caesar расшифровку\n");
    }
    
    printf("[✓] Расшифровка завершена\n\n");
    
    // ═══════════════════════════════════════════════════════════
    // Шаг 5: Вывод результата
    // ═══════════════════════════════════════════════════════════
    
    printf("═══════════════════════════════════════════════════════════════\n");
    printf("  РАСШИФРОВАННОЕ СООБЩЕНИЕ\n");
    printf("═══════════════════════════════════════════════════════════════\n\n");
    
    if (hex_output) {
        // TODO: Используй print_bytes_hex() из byte_ops.h
        printf("TODO: Вывод в hex формате\n");
    } else {
        // TODO: Используй print_bytes_as_chars() из byte_ops.h
        // Или просто printf("%s", data) если это текст
        printf("TODO: Вывод расшифрованного текста\n");
    }
    
    printf("\n");
    
    // ═══════════════════════════════════════════════════════════
    // Шаг 6: Сохранение в файл (опционально)
    // ═══════════════════════════════════════════════════════════
    
    if (output_filename != NULL) {
        printf("[*] Сохранение в файл: %s\n", output_filename);
        
        // TODO: Открой файл и запиши данные
        // FILE *out = fopen(output_filename, "wb");
        // fwrite(data, 1, data_size, out);
        // fclose(out);
        
        printf("[✓] Сохранено\n\n");
    }
    
    // ═══════════════════════════════════════════════════════════
    // Шаг 7: Статистика (бонус)
    // ═══════════════════════════════════════════════════════════
    
    printf("═══════════════════════════════════════════════════════════════\n");
    printf("  СТАТИСТИКА\n");
    printf("═══════════════════════════════════════════════════════════════\n");
    printf("  Размер файла:     %zu байт\n", data_size);
    printf("  Тип шифрования:   %s\n", 
           encryption_type == 1 ? "XOR" : 
           encryption_type == 2 ? "Caesar" : "Unknown");
    
    // TODO: Добавь больше статистики:
    // - Количество печатных символов
    // - Наиболее частые байты
    // - Энтропия данных
    
    printf("═══════════════════════════════════════════════════════════════\n\n");
    
    // ═══════════════════════════════════════════════════════════
    // Очистка памяти
    // ═══════════════════════════════════════════════════════════
    
    if (data != NULL) {
        free(data);
    }
    
    printf("[✓] Операция завершена успешно!\n");
    printf("    Decoder готов для использования в Season 2.\n\n");
    
    return 0;
}

// ═══════════════════════════════════════════════════════════════
// КОНЕЦ ФАЙЛА
// ═══════════════════════════════════════════════════════════════

/*
 * СЛЕДУЮЩИЕ ШАГИ:
 * 
 * 1. Создай модули byte_ops, crypto, utils, decoder
 * 2. Раскомментируй #include для своих модулей
 * 3. Реализуй функцию read_file()
 * 4. Реализуй расшифровку для XOR и Caesar
 * 5. Добавь вывод результата через byte_ops
 * 6. Обнови Makefile
 * 7. Скомпилируй: make season_project
 * 8. Протестируй на зашифрованных файлах
 * 
 * Удачи, агент! 🚀
 */

