# Episode 01: "Странное сообщение"
## Season 1: Foundations

> *"Всё начинается с простого сообщения..."*

---

## 🎬 BRIEFING

```
╔══════════════════════════════════════════════════════════╗
║  ЛОКАЦИЯ: Ваша квартира, район Арбат, Москва            ║
║  ВРЕМЯ:   23:47, вторник, 30 сентября                   ║
║  СТАТУС:  🟡 SUSPICIOUS ACTIVITY DETECTED                ║
╚══════════════════════════════════════════════════════════╝
```

**23:45**  
Вы заканчиваете очередной пентест для московского стартапа. Кофе давно остыл. На втором мониторе крутится компиляция. За окном — огни ночной Москвы. Обычный вторник фрилансера.

**23:46**  
Вы уже тянетесь к кнопке выключения, когда экран мигает. Уведомление. Но не от заказчика.

**23:47**  
*СТАРЫЙ КАНАЛ АКТИВИРОВАН*

Сердце пропускает удар. Этот канал... вы не использовали его три года. С тех пор как...

**От: V_Petrov_Ghost**  
**Шифрование: XOR-42 (ваш старый протокол)**

Виктор Петров. Ваш бывший напарник из отдела "К" ФСБ. Человек, который научил вас половине того, что вы знаете. Человек, который, по официальной версии, **погиб в автокатастрофе на Рублёвке два года назад**.

Но труп так и не нашли. Закрытая кремация. Быстрые похороны. Слишком быстрые...

Вы не верили в его смерть. Но доказательств не было. До этой секунды.

> *"Призраки не пишут сообщения. Но Виктор всегда был исключением..."* — вы вспоминаете его последние слова перед "смертью".

Сообщение короткое, зашифровано вашим общим XOR протоколом для экстренных ситуаций:

```
Encrypted message (hex):
1B 0A 0A 0E 0F 12 10 11 1B 26 00 02 1B 12 19 00 1B 04 03 26
1B 11 04 04 3C 26 0A 0E 0A 3C 26 15 12 0F 04 26 26 26 19 12
0F 04 26 0F 04 26 0A 0F 03 26 17 0F 00 02 04 3C 26 26 26 03
1A 1A 26 19

XOR Key: 0x42
```

Вам нужно:
1. Понять основы работы с данными в C
2. Реализовать XOR дешифровку
3. Прочитать сообщение Виктора
4. Понять, что происходит

**Миссия принята?**

---

## 📚 THEORY

### 1. Переменные и типы данных

> *"Каждый байт в памяти имеет свою роль. Знание типов — первый шаг к контролю."* — Victor Petrov

В C каждая переменная должна иметь **тип**. Тип определяет:
- 📦 Сколько памяти займёт переменная
- 🔢 Какие значения она может хранить  
- ⚙️ Какие операции с ней можно делать

#### Основные типы:

```c
int age = 25;           // Целое число (обычно 4 байта)
char letter = 'A';      // Символ (1 байт)
float price = 99.99;    // Число с плавающей точкой (4 байта)
double pi = 3.14159;    // Двойная точность (8 байт)
```

**Метафора — Сейф с ячейками:**
```
╔═══════════════════╗
║  ПАМЯТЬ КОМПЬЮТЕРА ║
╠═══════════════════╣
║ ┌──────┐ ┌──────┐ ║  char (1 байт)  = маленькая ячейка
║ │ 'A'  │ │  25  │ ║  int  (4 байта) = средний сейф
║ └──────┘ └──────┘ ║  double (8 байт)= большой контейнер
╚═══════════════════╝
```

- **Имя переменной** — ярлык на ячейке (`age`, `letter`)
- **Тип** — размер ячейки (в маленькую не влезет большое число)
- **Значение** — что лежит внутри

#### Беззнаковые типы (unsigned):

```c
unsigned int count = 100;   // Только положительные числа
unsigned char byte = 255;   // 0-255 (для байтов данных)
```

**Зачем?** Если не нужны отрицательные числа, получаем в два раза больший диапазон!

---

### 2. Массивы

Массив — это набор элементов **одного типа**, расположенных в памяти последовательно.

```c
int numbers[5] = {10, 20, 30, 40, 50};
char name[] = "Victor";  // Строка — это массив char + '\0'
```

**Метафора:** Массив — это ряд почтовых ящиков:
- Все ящики одинакового размера (один тип)
- Пронумерованы от 0 (первый элемент — `numbers[0]`)
- Чтобы открыть ящик №2, пишем `numbers[2]`

**Важно:** Индексация с нуля!
```c
int arr[3] = {10, 20, 30};
// arr[0] = 10
// arr[1] = 20
// arr[2] = 30
// arr[3] = ??? ОШИБКА! Выход за границы
```

---

### 3. Ввод и вывод

#### Вывод (printf):

```c
#include <stdio.h>

int main() {
    int age = 25;
    printf("My age is %d\n", age);  // %d — формат для int
    printf("Letter: %c\n", 'A');    // %c — формат для char
    printf("Price: %.2f\n", 99.99); // %f — формат для float/double
    return 0;
}
```

**Форматы:**
- `%d` — целое число (int)
- `%c` — символ (char)
- `%f` — число с плавающей точкой
- `%s` — строка (массив char)
- `%x` — шестнадцатеричное число
- `%02X` — hex с ведущими нулями (42 → 2A)

#### Ввод (scanf):

```c
int age;
printf("Enter your age: ");
scanf("%d", &age);  // Обратите внимание на &!
```

**Почему `&`?** `scanf` нужен **адрес** переменной, чтобы записать туда значение. Об этом подробнее в Season 2.

---

### 4. Операторы

#### Арифметические:
```c
int a = 10, b = 3;
int sum = a + b;       // 13
int diff = a - b;      // 7
int product = a * b;   // 30
int quotient = a / b;  // 3 (целочисленное деление!)
int remainder = a % b; // 1 (остаток от деления)
```

#### Побитовые (для работы с байтами):
```c
unsigned char a = 0b1010;  // 10 в двоичной
unsigned char b = 0b1100;  // 12 в двоичной

a & b  // AND:  1000 (8)
a | b  // OR:   1110 (14)
a ^ b  // XOR:  0110 (6)  ← Это нам нужно!
~a     // NOT:  0101 (5)
```

**XOR (исключающее ИЛИ) — магия шифрования:**

```
Правило XOR:        Визуализация:
0 ^ 0 = 0          ╔══════════════════╗
0 ^ 1 = 1          ║  A   ^   B   = C ║
1 ^ 0 = 1          ║ 'M'  ^  0x42 = ? ║  
1 ^ 1 = 0          ║  ?   ^  0x42 = M ║ ← Магия!
                   ╚══════════════════╝
```

**Магия XOR:** `(A ^ B) ^ B = A` — дважды XOR с одним ключом возвращает оригинал!

**Практический пример:**
```c
char original = 'A';                // 65 (в ASCII)
char key = 0x42;                    // 66 (ключ Виктора)
char encrypted = original ^ key;    // 65 ^ 66 = 7 (зашифровано!)
char decrypted = encrypted ^ key;   // 7 ^ 66 = 65 ('A' вернулась!)

printf("Оригинал:  %c\n", original);   // A
printf("Зашифр.:   %d\n", encrypted);  // 7 (нечитаемо)
printf("Расшифр.:  %c\n", decrypted);  // A (вернулось!)
```

> *"XOR — это как секретное рукопожатие. Знаешь код — понимаешь сообщение."* — Из ваших занятий с Виктором

---

### 5. Циклы (введение)

Для обработки массива нужен цикл:

```c
int numbers[5] = {10, 20, 30, 40, 50};

// Цикл for
for (int i = 0; i < 5; i++) {
    printf("%d\n", numbers[i]);
}
```

**Читается как:** 
- `int i = 0` — начать с 0
- `i < 5` — пока i меньше 5
- `i++` — увеличивать i на 1 после каждой итерации

**Метафора:** Конвейер с 5 шагами, вы проходите по каждому.

---

### 6. Функции (preview)

Функция — это переиспользуемый блок кода:

```c
// Объявление функции
int add(int a, int b) {
    return a + b;
}

// Использование
int result = add(5, 3);  // result = 8
```

**Структура:**
```c
тип_возврата название(параметры) {
    // тело функции
    return значение;
}
```

---

## 🎯 MISSION

### Задача 1: warmup.c (Разминка)

**Цель:** Понять XOR и базовый ввод/вывод

Напишите программу, которая:
1. Спрашивает у пользователя число (0-255)
2. Применяет XOR с ключом `0x42`
3. Выводит результат в hex формате

**Пример:**
```
Enter byte (0-255): 65
Encrypted: 0x27
```

**Starter code:** `warmup.c`

---

### Задача 2: decoder.c (Основная)

**Цель:** Расшифровать сообщение Виктора

Дано:
- Зашифрованное сообщение (массив байтов в hex)
- Ключ XOR: `0x42`

Нужно:
1. Сохранить зашифрованные байты в массив
2. Применить XOR к каждому байту
3. Вывести расшифрованное сообщение

**Зашифрованное сообщение (в коде):**
```c
unsigned char encrypted[] = {
    0x0F, 0x0D, 0x0D, 0x0C, 0x0E, 0x0B, 0x05, 0x0A, 
    0x16, 0x62, 0x23, 0x21, 0x36, 0x2B, 0x34, 0x23, 
    0x36, 0x27, 0x26, 0x6C, 0x48, 0x16, 0x2A, 0x27, 
    0x3B, 0x62, 0x29, 0x2C, 0x2D, 0x35, 0x6C, 0x48, 
    0x04, 0x2B, 0x2E, 0x27, 0x31, 0x62, 0x23, 0x36, 
    0x62, 0x2D, 0x2E, 0x26, 0x62, 0x32, 0x2E, 0x23, 
    0x21, 0x27, 0x6C, 0x48, 0x16, 0x30, 0x37, 0x31, 
    0x36, 0x62, 0x2D, 0x2C, 0x2E, 0x3B, 0x62, 0x21, 
    0x2D, 0x26, 0x27, 0x6C, 0x48, 0xA0, 0xC2, 0xD6, 
    0x62, 0x14, 0x6C
};
```

**Подсказки:**
- Длина массива: `sizeof(encrypted) / sizeof(encrypted[0])`
- XOR каждого байта: `decrypted[i] = encrypted[i] ^ key;`
- Вывод как текст: `printf("%s", decrypted);`

**Starter code:** `decoder.c`

---

### Задача 3: validator.c (Challenge)

**Цель:** Проверить корректность расшифровки

После расшифровки проверьте:
1. Все символы — печатные (ASCII 32-126) или спецсимволы (\n, \t)
2. Нет странных символов
3. Вывести статистику: сколько букв, цифр, пробелов

**Bonus:** Подсчитать контрольную сумму (сумма всех байтов % 256)

---

## 📝 Структура файлов

```
episode-01-strange-message/
├── README.md           ← Вы здесь
├── mission.md          ← Краткое ТЗ
├── starter.c           ← Шаблоны для начала
├── artifacts/
│   ├── warmup.c        ← Ваш код здесь
│   ├── decoder.c       ← Ваш код здесь
│   └── validator.c     ← Ваш код здесь
├── tests/
│   ├── test.sh         ← Автотесты
│   └── expected.txt    ← Ожидаемый результат
└── solution/
    └── decoder_solution.c  ← Открывать только если застряли!
```

---

## 🛠 Компиляция и запуск

### Компиляция:
```bash
gcc -Wall -Wextra -std=c11 -o decoder artifacts/decoder.c
```

**Флаги:**
- `-Wall -Wextra` — все предупреждения (полезно!)
- `-std=c11` — стандарт C11
- `-o decoder` — имя выходного файла

### Запуск:
```bash
./decoder
```

### Автотесты:
```bash
cd tests
./test.sh
```

---

## 💡 Подсказки

### Подсказка 1: Создание массива
```c
unsigned char encrypted[] = {0x1B, 0x0A, /* ... */};
int length = sizeof(encrypted) / sizeof(encrypted[0]);
```

### Подсказка 2: XOR в цикле
```c
for (int i = 0; i < length; i++) {
    decrypted[i] = encrypted[i] ^ KEY;
}
```

### Подсказка 3: Нулевой терминатор
Строки в C заканчиваются символом `\0`:
```c
decrypted[length] = '\0';  // Завершить строку!
```

---

## 🎓 Что вы изучите

✅ Переменные и типы данных  
✅ Массивы  
✅ Циклы (`for`)  
✅ Операторы (особенно XOR)  
✅ Ввод/вывод (`printf`, `scanf`)  
✅ Компиляция программ  
✅ Работа с hex данными  

---

## 🎬 DEBRIEFING

```
╔════════════════════════════════════════════════════════╗
║           🔓 СООБЩЕНИЕ РАСШИФРОВАНО                   ║
╠════════════════════════════════════════════════════════╣
║                                                        ║
║  "MOONLIGHT activated.                                 ║
║   They know.                                           ║
║   Files at old place.                                  ║
║   Trust only code.                                     ║
║                                            — V."       ║
║                                                        ║
╚════════════════════════════════════════════════════════╝
```

**00:02, среда**  
Вы смотрите на экран. Руки дрожат. Виктор жив.

Но вопросов больше, чем ответов:
- 🤔 Что такое **MOONLIGHT**?
- 👁️ Кто "они"? И что они знают?
- 📂 "Старое место" — это не физическая локация...
- 💻 "Доверяй только коду" — его любимая фраза

Вы помните. "Старое место" — это протокол обмена файлами, который вы разработали вместе. Скрытый канал в сети. Если Виктор пишет об этом, значит там лежит что-то важное.

> *"В этой игре нет случайностей. Каждый символ — ключ к разгадке."*

Время действовать.

**Status:** 🟢 Mission Complete!  
**New Objective:** 🔍 Find files at "old place"  
**Next Episode:** Episode 02 - "Цепочка зацепок"

---

### 📊 Что вы узнали:
- ✅ Виктор ЖИВ и на связи
- ✅ Операция "MOONLIGHT" активирована  
- ✅ Враг знает о чём-то важном
- ✅ Следующий шаг — "старое место"

---

## 🎨 Easter Eggs

🔍 **Отсылки в этом эпизоде:**
- XOR шифрование — классика из Watch Dogs
- "Старый канал" — как в "Враг государства"
- Виктор Петров — имя из "Семнадцать мгновений весны"

---

## 📚 Дополнительные ресурсы

- [CS50: Week 1 - C](https://cs50.harvard.edu/x/)
- [C Programming: A Modern Approach](http://knking.com/books/c2/)
- K&R "The C Programming Language" — Глава 1

---

**Удачи, агент! Время расшифровывать...**

```
// LOADING...
// DECRYPTION MODULE READY
// AWAITING YOUR CODE
```
