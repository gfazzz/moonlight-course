# Episode 08: "Fragmentation" 🔍

> *"Memory leaks are silent killers. Learn to hunt them down before they hunt you."*

---

## 🎬 BRIEFING — ФИНАЛ SEASON 2

```
╔══════════════════════════════════════════════════════════╗
║  ЛОКАЦИЯ: Safe House, Кузьминки, Москва                 ║
║  ВРЕМЯ:   02:47, четверг, 2 октября                     ║
║  СТАТУС:  🔴 TROJAN DETECTED - MEMORY ATTACK IN PROGRESS ║
╚══════════════════════════════════════════════════════════╝
```

**ВРЕМЕННАЯ ЛИНИЯ:**
```
19:30  ✅ Динамический загрузчик создан, поток остановлен
21:00  📧 Получена "безопасная" программа от V.
21:30  🏃 Запуск программы мониторинга
22:30  🚨 ТРЕВОГА: Утечка памяти +100MB/час!
00:15  ⚠️  Система начинает тормозить (swap активирован)
01:30  🔥 ОЗУ заполнено на 94% — критическая ситуация!
02:00  💀 Обнаружен троянский код от Z.
02:47  🎯 Последний шанс: найти ВСЕ утечки за 15 минут
```

### 🔐 СИТУАЦИЯ — ТРОЯНСКАЯ АТАКА

**21:00** — После остановки потока данных вы получаете от V. программу:

```
╔═══════════════════════════════════════════════════════════╗
║  ОТ: V.                                                   ║
║  ТЕМА: Инструмент мониторинга                            ║
║  ВРЕМЯ: 21:00                                            ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  "Используй эту программу для мониторинга активности Z.  ║
║   Она будет логировать все попытки доступа.              ║
║   Запусти и оставь работать. — V."                       ║
║                                                           ║
║  Вложение: moonlight_monitor.c                           ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

Вы доверяете V. и запускаете программу.

**21:30** — Программа работает. Логи пишутся:
```
[21:30:15] Monitoring started
[21:30:42] Connection attempt from 185.220.101.47 - BLOCKED
[21:31:08] Connection attempt from 95.142.207.19 - BLOCKED
[21:31:33] Suspicious packet intercepted - LOGGED
...
```

Всё выглядит нормально.

**22:30** — Вы замечаете, что система притормаживает. Проверяете память:

```bash
$ free -h
              total        used        free
Mem:           16Gi        2.5Gi       13Gi

# Через 30 минут...
$ free -h
              total        used        free
Mem:           16Gi        4.1Gi       11Gi  # Память растёт!
```

---

### 🚨 ТВИСТ — ОБНАРУЖЕНИЕ В 02:00

**00:15** — Система начинает серьёзно тормозить. Swap активирован:

```bash
$ free -h
              total        used        free      
Mem:           16Gi        15Gi        512Mi  🔥
Swap:          8Gi         3.2Gi       4.8Gi  ← SWAP активен!
```

**01:30** — Критический уровень:

**📊 ВИЗУАЛИЗАЦИЯ УТЕЧКИ:**

```
╔═══════════════════════════════════════════════════════════╗
║  MEMORY LEAK — РЕАЛЬНОЕ ВРЕМЯ                             ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  21:00 [██        ] 2.0 GB   ← Старт программы           ║
║  21:30 [███       ] 3.2 GB                                ║
║  22:00 [████      ] 4.8 GB                                ║
║  22:30 [█████     ] 6.1 GB   ← Замечаете проблему         ║
║  23:00 [██████    ] 7.5 GB                                ║
║  23:30 [███████   ] 8.9 GB                                ║
║  00:00 [████████  ] 10.3 GB                               ║
║  00:30 [█████████ ] 11.8 GB  🔥 SWAP активирован         ║
║  01:00 [██████████] 13.2 GB  🔥 Система тормозит         ║
║  01:30 [███████████] 15.1GB  🔥🔥 КРИТИЧНО!              ║
║  02:00 [████████████] ???    💀 OOM Killer готов убить   ║
║                                                           ║
║  Скорость утечки: ~180 MB/час                             ║
║  Прогноз: краш через 15-20 минут                          ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**02:00** — Вы анализируете код программы... **и замечаете странность**:

```c
// Файл: moonlight_monitor.c
void process_logs() {
    for (int i = 0; i < 1000; i++) {
        char *buffer = malloc(10240);  // 10KB
        read_log_entry(buffer);
        process_entry(buffer);
        // ❌ НЕТ free(buffer)!
    }
    // Утекло: 1000 × 10KB = 10MB за цикл
}

// И ещё...
void analyze_packet(Packet *pkt) {
    char *temp = malloc(pkt->size);
    memcpy(temp, pkt->data, pkt->size);
    // ... обработка ...
    // ❌ НЕТ free(temp)!
}

// И ещё 3 утечки в других функциях...
```

Вы проверяете автора файла:

```bash
$ file moonlight_monitor.c
moonlight_monitor.c: C source, ASCII text

$ strings moonlight_monitor.c | grep -i author
// Author: Z. (Infiltration Module v2.1)
// Purpose: Resource Exhaustion Attack
```

**Это не программа от V. Это ТРОЯН от Z.!**

Телефон вибрирует. SMS:

```
╔═══════════════════════════════════════════════════════════╗
║  От: +7-XXX-XXX-XXXX (Z.)                                 ║
║  Время: 02:02                                             ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  "Поздравляю, ты запустил мою программу.                 ║
║   Утечка памяти — это не баг. Это оружие.                ║
║                                                           ║
║   Через 15 минут твоя система рухнет.                    ║
║   Все данные операции MOONLIGHT будут уничтожены.        ║
║                                                           ║
║   Но я дам тебе шанс:                                    ║
║   Найди ВСЕ утечки. Исправь их. Докажи инструментами.    ║
║                                                           ║
║   Если справишься — получишь координаты следующей        ║
║   встречи с V. Настоящим V.                              ║
║                                                           ║
║   Таймер пошёл. — Z."                                    ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**02:47** — Последнее сообщение от настоящего V.:

```
╔═══════════════════════════════════════════════════════════╗
║  ОТ: V. (encrypted channel Alpha-7)                       ║
║  ТЕМА: Финальный экзамен                                 ║
║  ВРЕМЯ: 02:50                                            ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  "Прости. Канал был скомпрометирован.                    ║
║   Та программа — от Z., не от меня.                      ║
║                                                           ║
║   Это последний тест Season 2:                           ║
║   Утечки памяти — самая опасная категория багов.         ║
║   Они убивают молча. Незаметно. Необратимо.              ║
║                                                           ║
║   Твоя задача:                                           ║
║   1. Найти ВСЕ утечки (valgrind/leaks)                   ║
║   2. Исправить код                                       ║
║   3. Оптимизировать (минимум аллокаций)                  ║
║   4. Доказать отсутствие утечек                          ║
║                                                           ║
║   Времени мало. Система рухнет через 15 минут.           ║
║                                                           ║
║   Справишься — Season 2 завершён.                        ║
║   Season 3 ждёт тебя. Живой.                             ║
║                                                           ║
║   Удачи, агент. — V."                                    ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

### 🎯 ЗАДАЧА — ФИНАЛЬНЫЙ ЭКЗАМЕН

**Исправить троянскую программу:**
1. 🔍 **Найти утечки** — использовать valgrind/leaks
2. 🔧 **Исправить код** — добавить недостающие free()
3. ⚡ **Оптимизировать** — уменьшить количество аллокаций (переиспользование буферов)
4. ✅ **Проверить** — доказать отсутствие утечек
5. 📊 **Измерить** — улучшить производительность

**Сложность:** 🔴🔴 Very Hard  
**Новые навыки:** Поиск утечек, профилирование памяти, оптимизация, valgrind/leaks mastery  
**Deadline:** ⏰ 15 минут до краха системы

```
╔══════════════════════════════════════════════════════════╗
║  [!] ЭТО ФИНАЛЬНОЕ ИСПЫТАНИЕ SEASON 2!                   ║
║                                                          ║
║  Требования для прохождения:                             ║
║  ✓ 0 bytes leaked (проверено valgrind/leaks)             ║
║  ✓ Все allocs == все frees                               ║
║  ✓ Программа работает корректно                          ║
║  ✓ Оптимизация: -50% аллокаций от троянской версии       ║
║                                                          ║
║  Награда: Координаты встречи с V. + доступ к Season 3    ║
╚══════════════════════════════════════════════════════════╝
```

---

## 📚 ТЕОРИЯ: Поиск утечек и оптимизация памяти

### 💡 Почему утечки памяти критичны?

**Реальные примеры катастроф:**
- 🚀 **NASA Mars Rover (Sojourner)** — утечка памяти привела к перезагрузкам
- 🏦 **Knight Capital (2012)** — баг в софте (включая утечки) → потеря $440 миллионов за 45 минут
- 🎮 **AAA игры** — утечки = фризы после нескольких часов игры (Skyrim, Battlefield)
- 🌐 **Apache web server (старые версии)** — утечки → restart каждые N дней
- 🔐 **Системы безопасности** — память = уязвимость для DoS-атак

**В продакшене утечка памяти = катастрофа!**

---

### 1. Что такое утечка памяти?

**Утечка памяти (memory leak)** — ситуация, когда выделенная память не освобождается и не может быть использована повторно.

**📊 МЕТАФОРА: АРЕНДОВАННЫЕ КВАРТИРЫ**

```
╔═══════════════════════════════════════════════════════════╗
║  ГОРОД HEAP — АРЕНДОВАННЫЕ КВАРТИРЫ                       ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  НОРМАЛЬНАЯ РАБОТА:                                       ║
║  ┌──────┐ ┌──────┐ ┌──────┐                              ║
║  │Кв. 1 │ │Кв. 2 │ │Кв. 3 │ ← Арендовали (malloc)        ║
║  └──────┘ └──────┘ └──────┘                              ║
║     ↓        ↓        ↓                                   ║
║  Вернули  Вернули  Вернули  ← Освободили (free)          ║
║  ключ     ключ     ключ                                  ║
║                                                           ║
║  ✅ Квартиры свободны для новых жильцов                   ║
║                                                           ║
║  ════════════════════════════════════════════════════     ║
║                                                           ║
║  УТЕЧКА ПАМЯТИ:                                           ║
║  ┌──────┐ ┌──────┐ ┌──────┐                              ║
║  │Кв. 1 │ │Кв. 2 │ │Кв. 3 │ ← Арендовали (malloc)        ║
║  └──────┘ └──────┘ └──────┘                              ║
║     ↓        ⨯        ⨯                                   ║
║  Вернули  ПОТЕРЯЛИ ПОТЕРЯЛИ ← Забыли free()!             ║
║  ключ     ключ!    ключ!                                 ║
║                                                           ║
║  ❌ Квартиры заблокированы НАВСЕГДА!                      ║
║  ❌ Никто не может их использовать!                       ║
║  ❌ Город переполняется... 💥                             ║
║                                                           ║
║  После 1000 утечек:                                       ║
║  ГОРОД ПАРАЛИЗОВАН! Нет свободных квартир!                ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**Код с утечкой:**

```c
// ❌ Утечка
void leak_example() {
    int *p = malloc(1000 * sizeof(int));
    // Забыли free(p)!
}  // p исчезает, но память потеряна навсегда (до завершения программы)

// После 1000 вызовов: 4MB памяти утекло!
for (int i = 0; i < 1000; i++) {
    leak_example();  // +4KB каждый раз
}
```

**Последствия:**
- Постоянный рост потребления памяти
- Замедление системы (swap)
- Краш при исчерпании памяти (OOM Killer)
- Невозможность выделить новую память

---

### 2. Типы утечек

**1. Прямая утечка (Direct leak)**:
```c
int *p = malloc(100);
// Забыли free(p)
```

**2. Потерянный указатель**:
```c
int *p = malloc(100);
p = malloc(200);  // Старый блок (100 байт) потерян!
```

**3. Косвенная утечка (Indirect leak)**:
```c
struct Node {
    int *data;
    struct Node *next;
};

Node *head = malloc(sizeof(Node));
head->data = malloc(100);  // Выделили
free(head);  // Освободили Node, но data утекла!
```

**4. Условная утечка**:
```c
int *p = malloc(100);
if (error) {
    return;  // Выход без free! Утечка!
}
free(p);
```

**5. Цикличная утечка (в циклах)**:
```c
for (int i = 0; i < 1000; i++) {
    char *temp = malloc(1024);
    // ... работа ...
    // Забыли free(temp)
}  // 1000 блоков утекло!
```

---

### 3. Инструменты поиска утечек

#### **macOS: `leaks`**

Встроенная утилита Apple:

```bash
# Запустить с проверкой утечек при выходе
leaks --atExit -- ./my_program

# Или проверить запущенный процесс по PID
leaks <pid>

# Или в реальном времени
leaks --atExit --list -- ./my_program
```

**Интерпретация вывода:**
```
leaks Report Version: 4.0
Process 12345: 512 nodes malloced for 8192 KB
Process 12345: 1 leak for 1024 total leaked bytes.

Leak: 0x7f8a12345000  size=1024  zone: DefaultMallocZone_0x...
    Call stack:
    0x00007fff12345678  malloc
    0x0000000100001234  process_logs  ← ЗДЕСЬ УТЕЧКА!
    0x0000000100001567  main
```

#### **Linux: `valgrind`**

```bash
# Полная проверка утечек
valgrind --leak-check=full --show-leak-kinds=all ./my_program

# Только утечки без деталей
valgrind --leak-check=summary ./my_program

# С трекингом источников
valgrind --track-origins=yes ./my_program
```

**Вывод valgrind:**
```
==12345== HEAP SUMMARY:
==12345==     in use at exit: 1,024 bytes in 1 blocks
==12345==   total heap usage: 10 allocs, 9 frees, 10,240 bytes allocated
==12345==
==12345== 1,024 bytes in 1 blocks are definitely lost
==12345==    at 0x4C2AB80: malloc (vg_replace_malloc.c:299)
==12345==    by 0x400567: process_logs (logger.c:42)  ← ЗДЕСЬ!
==12345==    by 0x4005A3: main (logger.c:156)
==12345==
==12345== LEAK SUMMARY:
==12345==    definitely lost: 1,024 bytes in 1 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 0 bytes in 0 blocks
```

---

### 4. Паттерны предотвращения утечек

**1. Правило: Кто выделил — тот и освобождает**

```c
// ✅ Хорошо
char* create_string() {
    char *s = malloc(100);
    strcpy(s, "Hello");
    return s;
}

void use_string() {
    char *s = create_string();
    printf("%s\n", s);
    free(s);  // Вызывающий освобождает
}
```

**2. Обнуление после free**

```c
// ✅ Безопасно
free(p);
p = NULL;  // Теперь повторный free безопасен (ничего не делает)

if (p != NULL) {
    free(p);  // Не выполнится, если уже освобождено
}
```

**3. Cleanup-функции**

```c
typedef struct {
    char *name;
    int *data;
} Resource;

Resource* create_resource() {
    Resource *r = malloc(sizeof(Resource));
    r->name = malloc(100);
    r->data = malloc(1000 * sizeof(int));
    return r;
}

// ✅ Централизованная очистка
void destroy_resource(Resource *r) {
    if (r) {
        free(r->name);   // Сначала вложенные
        free(r->data);
        free(r);         // Потом структуру
    }
}
```

**4. SAFE_FREE макрос**

```c
#define SAFE_FREE(p) do { \
    free(p); \
    p = NULL; \
} while(0)

SAFE_FREE(buffer);
SAFE_FREE(buffer);  // Безопасно (уже NULL)
```

---

### 5. Защита от двойного освобождения (Double Free)

**Проблема:**
```c
int *p = malloc(100);
free(p);
free(p);  // КРАШ!
```

**Решение 1: Обнулять:**
```c
free(p);
p = NULL;
free(p);  // OK (free(NULL) безопасен)
```

**Решение 2: Безопасный макрос:**
```c
#define SAFE_FREE(p) do { \
    if (p) { \
        free(p); \
        p = NULL; \
    } \
} while(0)

SAFE_FREE(p);
SAFE_FREE(p);  // Безопасно
```

---

### 6. Оптимизация использования памяти

**1. Переиспользование буферов**

```c
// ❌ Плохо (много аллокаций)
for (int i = 0; i < 1000; i++) {
    char *buf = malloc(1024);
    // работа с buf
    free(buf);
}
// 1000 malloc + 1000 free = медленно!

// ✅ Хорошо (одна аллокация)
char *buf = malloc(1024);
for (int i = 0; i < 1000; i++) {
    // работа с buf (переиспользуем!)
}
free(buf);
// 1 malloc + 1 free = быстро!
```

**2. Memory pools (пулы памяти)**

```c
typedef struct {
    void *memory;
    size_t size;
    size_t used;
} MemoryPool;

MemoryPool* pool_create(size_t size) {
    MemoryPool *pool = malloc(sizeof(MemoryPool));
    pool->memory = malloc(size);
    pool->size = size;
    pool->used = 0;
    return pool;
}

void* pool_alloc(MemoryPool *pool, size_t size) {
    if (pool->used + size > pool->size) {
        return NULL;  // Пул переполнен
    }
    void *ptr = (char*)pool->memory + pool->used;
    pool->used += size;
    return ptr;
}

void pool_reset(MemoryPool *pool) {
    pool->used = 0;  // Сброс без free!
}

void pool_destroy(MemoryPool *pool) {
    free(pool->memory);
    free(pool);
}
```

**3. Кэширование расчётов**

```c
// ❌ Плохо
for (int i = 0; i < strlen(str); i++) {  // strlen вызывается каждый раз!
    process(str[i]);
}

// ✅ Хорошо
size_t len = strlen(str);  // Один раз
for (int i = 0; i < len; i++) {
    process(str[i]);
}
```

---

### 7. Best Practices

**1. Всегда проверяйте malloc:**
```c
int *p = malloc(size);
if (!p) {
    perror("malloc failed");
    return -1;
}
```

**2. Один malloc — один free:**
```c
// Трекайте все аллокации
int allocated = 0;
int freed = 0;

p = malloc(100);
allocated++;

free(p);
freed++;

// В конце: allocated == freed?
assert(allocated == freed);
```

**3. Используйте статический анализ:**
```bash
# clang static analyzer
scan-build make

# cppcheck
cppcheck --enable=all .
```

**4. Добавляйте ассерты:**
```c
#include <assert.h>

void function(int *p) {
    assert(p != NULL);  // Краш в дебаге, если NULL
    *p = 42;
}
```

**5. Логируйте аллокации (дебаг):**
```c
#ifdef DEBUG
#define MALLOC(size) (printf("MALLOC %zu at %s:%d\n", size, __FILE__, __LINE__), malloc(size))
#define FREE(p) (printf("FREE %p at %s:%d\n", p, __FILE__, __LINE__), free(p))
#else
#define MALLOC malloc
#define FREE free
#endif
```

---

## 🎯 Миссия: "Детектив утечек"

### Легенда

Вам досталась троянская программа от Z. — **система логирования MOONLIGHT** с намеренными утечками памяти.

Программа работает, но память постоянно растёт!

После 1000 операций программа съедает 100MB+. Система на грани краха.

**Ваша задача:**
1. Запустить программу с детектором утечек
2. Найти все утечки памяти (минимум 5)
3. Исправить их
4. Оптимизировать использование памяти
5. Доказать отсутствие утечек

---

### Программа `buggy_logger.c` (троян от Z.)

**Предоставлена**: `buggy_logger.c` — программа с утечками

**Симптомы:**
- Память растёт при каждом логе
- Через 1000 операций: ~50MB утекло
- Valgrind/leaks показывают утечки
- Система тормозит после нескольких часов работы

**Функционал:**
- Чтение конфига из файла
- Запись логов с временными метками
- Ротация логов (создание новых файлов)
- Буферизация сообщений

**Скрытые утечки (минимум 5):**
1. Конфиг: строки из файла не освобождаются
2. Лог-записи: сообщения не очищаются
3. Буфер: при ротации остаются записи
4. Временные буферы: забыты free
5. Косвенные: вложенные структуры

---

### Технические требования

**Входные данные**: 
- `config.txt` (конфигурация)
- Команды через stdin

**Задачи:**
1. Запустить с valgrind/leaks
2. Идентифицировать утечки (файл:строка)
3. Исправить каждую утечку
4. Добавить cleanup-функции
5. Проверить: 0 leaks

**Критерии успеха:**
```bash
valgrind --leak-check=full ./fixed_logger
...
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: N allocs, N frees, X bytes allocated
==12345==
==12345== All heap blocks were freed -- no leaks are possible
```

---

## 📝 Структура эпизода

```
episode-08-fragmentation/
├── README.md              ← Вы здесь
├── mission.md
├── buggy_logger.c         ← Троянская программа с утечками
├── starter.c              ← Шаблон для исправления
├── artifacts/
│   └── fixed_logger.c     ← Создайте исправленный файл
├── solution/
│   └── fixed_logger_solution.c
└── tests/
    └── test.sh
```

### 💡 Как работать:

1. **Изучите** `buggy_logger.c` — там утечки памяти
2. **Скопируйте** `buggy_logger.c` в `artifacts/fixed_logger.c`
3. **Найдите утечки** с помощью:
   - `valgrind --leak-check=full ./buggy_logger` (Linux)
   - `leaks --atExit -- ./buggy_logger` (macOS)
4. **Исправьте** каждую утечку:
   - Добавьте `free()` для каждого `malloc()`/`strdup()`
   - Проверьте освобождение в функции cleanup
   - Не забудьте закрыть файлы (`fclose()`)
5. **Оптимизируйте**:
   - Переиспользуйте буферы вместо malloc в циклах
   - Уменьшите количество аллокаций
6. **Проверьте**: `valgrind` должен показать "0 bytes in 0 blocks"

---

## 🎓 КОНТРОЛЬНЫЕ ВОПРОСЫ

### Базовое понимание

1. **Утечка памяти:**
   - Что такое memory leak?
   - Почему утечки опасны в production?
   - Приведите пример кода с утечкой

2. **Метафора:**
   - Объясните утечку через метафору "арендованных квартир"
   - Что значит "потерять ключ от квартиры"?
   - Как "город heap" переполняется?

3. **Типы утечек:**
   - Чем отличается прямая утечка от косвенной?
   - Что такое потерянный указатель?
   - Приведите пример условной утечки

### Практическое применение

4. **Valgrind:**
   - Как запустить valgrind для поиска утечек?
   - Как интерпретировать "definitely lost"?
   - Что означает "10 allocs, 9 frees"?

5. **leaks (macOS):**
   - Как использовать leaks --atExit?
   - Как найти строку кода, где произошла утечка?

6. **Исправление:**
   - Как исправить утечку в цикле?
   - Зачем cleanup-функции?
   - Что такое SAFE_FREE макрос?

### Анализ кода

7. **Найдите утечку:**
```c
void process_data() {
    for (int i = 0; i < 100; i++) {
        char *temp = malloc(1024);
        read_data(temp);
        process(temp);
    }
}  // Сколько байт утекло?
```

8. **Найдите косвенную утечку:**
```c
typedef struct {
    char *message;
    int id;
} LogEntry;

LogEntry* create_entry() {
    LogEntry *e = malloc(sizeof(LogEntry));
    e->message = strdup("Hello");
    e->id = 42;
    return e;
}

// Как правильно освободить?
```

9. **Double free:**
```c
int *p = malloc(100);
free(p);
// ... 100 строк кода ...
free(p);  // Как предотвратить?
```

### Оптимизация

10. **Переиспользование:**
    - Почему переиспользование буферов быстрее?
    - Сравните: 1000 malloc vs 1 malloc в цикле
    - Когда нельзя переиспользовать?

11. **Memory pools:**
    - Что такое memory pool?
    - Когда использовать pools?
    - В чём преимущество перед malloc?

### Сюжет

12. **Троянская программа:**
    - Почему Z. использовал утечки как оружие?
    - Как утечка памяти может быть DoS-атакой?
    - Реальны ли такие атаки?

13. **Финал Season 2:**
    - Что доказывает исправление утечек?
    - Почему это последний тест?
    - Как это связано с Season 3?

### Продвинутые вопросы

14. **Профилирование:**
    - Как измерить утечку в реальном времени?
    - Что такое heap profiling?
    - Какие инструменты использовать? (massif, heaptrack)

15. **Задача:**
```c
// Реализуйте систему трекинга аллокаций
typedef struct {
    void *ptr;
    size_t size;
    const char *file;
    int line;
} AllocationInfo;

void* tracked_malloc(size_t size, const char *file, int line);
void tracked_free(void *ptr);
void print_leaks();  // Выводит все не-free'нутые блоки
```

---

## ✅ Проверка

```bash
# Найти утечки
valgrind --leak-check=full ./buggy_logger

# Исправить
nano artifacts/fixed_logger.c

# Собрать
make

# Проверить
make test
make valgrind  # или make leaks на macOS
```

**Критерии успеха:**
- ✅ 0 байт утекло
- ✅ Все allocs == все frees
- ✅ Программа работает корректно
- ✅ Оптимизация: меньше аллокаций чем в оригинале

---

## 🎬 DEBRIEFING — ФИНАЛ SEASON 2

```
╔═══════════════════════════════════════════════════════════╗
║        🏆 ТРОЯН ОБЕЗВРЕЖЕН! УТЕЧКИ УСТРАНЕНЫ!            ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  ✅ ВСЕ УТЕЧКИ НАЙДЕНЫ И ИСПРАВЛЕНЫ                       ║
║                                                           ║
║  📊 РЕЗУЛЬТАТЫ АНАЛИЗА:                                   ║
║  ────────────────────────────────────────                ║
║  Было:  247 allocations, 189 frees  → 58 leaks 🔴        ║
║  Стало: 247 allocations, 247 frees  → 0 leaks ✅         ║
║                                                           ║
║  💾 ПАМЯТЬ:                                               ║
║  ────────────────────────────────────────                ║
║  Утекало: 180 MB/час → краш через 90 минут               ║
║  Теперь:  Стабильно 512 MB                               ║
║                                                           ║
║  ⚡ ОПТИМИЗАЦИЯ:                                          ║
║  ────────────────────────────────────────                ║
║  Аллокаций сокращено: 247 → 120 (-51%)                   ║
║  Скорость: +37% быстрее                                  ║
║  CPU usage: -28%                                         ║
║                                                           ║
║  🔬 VALGRIND ОТЧЁТ:                                       ║
║  ────────────────────────────────────────                ║
║  All heap blocks were freed -- no leaks are possible     ║
║  ERROR SUMMARY: 0 errors from 0 contexts                 ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

### 📬 ФИНАЛЬНОЕ СООБЩЕНИЕ ОТ V.

```
╔═══════════════════════════════════════════════════════════╗
║  ОТ: V. (encrypted channel Alpha-7)                       ║
║  ТЕМА: Season 2 завершён. Координаты встречи.            ║
║  ВРЕМЯ: 04:15                                            ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  "Троян обезврежен. Утечки устранены.                    ║
║   Ты не просто прошёл тест — ты превзошёл его.           ║
║                                                           ║
║   Season 2: Memory & Pointers — ЗАВЕРШЁН.                ║
║                                                           ║
║   Ты освоил:                                             ║
║   ✓ Массивы и строки (основа всех данных)                ║
║   ✓ Указатели (ключ к пониманию системы)                 ║
║   ✓ Динамическую память (свобода и контроль)             ║
║   ✓ Поиск утечек (защита от катастроф)                   ║
║                                                           ║
║   Теперь ты готов к следующему уровню.                   ║
║                                                           ║
║   КООРДИНАТЫ ВСТРЕЧИ:                                    ║
║   55.7558° N, 37.6173° E                                 ║
║   (Красная площадь, Московский Кремль)                   ║
║   Время: 12:00, пятница, 3 октября                       ║
║                                                           ║
║   Приди один. Жди дальнейших инструкций.                 ║
║                                                           ║
║   ════════════════════════════════════════════            ║
║                                                           ║
║   Season 3: Networks                                     ║
║                                                           ║
║   Там ты узнаешь:                                        ║
║   → Как данные путешествуют через сеть                   ║
║   → Как шифруются пакеты                                 ║
║   → Как защищаются и взламываются системы                ║
║   → Кто на самом деле Z.                                 ║
║   → И что случилось со мной два года назад...            ║
║                                                           ║
║   Операция MOONLIGHT только начинается.                  ║
║                                                           ║
║   До встречи в сети, агент.                              ║
║                                                           ║
║   — Victor Petrov"                                       ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

### 📊 Статистика Season 2:
- ⏱️ Общее время Season 2: 6-8 часов
- 🎓 Эпизодов пройдено: **4/4** ✅
- 🏆 Достижений разблокировано: **4/4** ✅
- 💪 Навыков освоено: **Memory Management Mastery** ✅

### 🏆 SEASON 2 COMPLETED! 

```
╔═══════════════════════════════════════════════════════════╗
║                                                           ║
║         🎖️  MEMORY MANAGEMENT EXPERT  🎖️                 ║
║                                                           ║
║  [████████████████████████████████████] 100%             ║
║                                                           ║
║  Вы мастерски освоили:                                   ║
║  ✓ Episode 05: Memory Map (массивы, строки)              ║
║  ✓ Episode 06: Pointer Game (указатели, циклы)           ║
║  ✓ Episode 07: Deep Dive (динамическая память)           ║
║  ✓ Episode 08: Fragmentation (поиск утечек)              ║
║                                                           ║
║  Теперь вы можете:                                       ║
║  → Работать с памятью на низком уровне                   ║
║  → Создавать эффективные структуры данных                ║
║  → Находить и устранять утечки памяти                    ║
║  → Оптимизировать использование ресурсов                 ║
║                                                           ║
║  🚀 READY FOR SEASON 3: NETWORKS                         ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

### 🎨 Easter Eggs финала

🔍 **Скрытые детали:**
- Троянская программа от Z. — реальный паттерн из production багов
- OOM Killer (Out-Of-Memory) — реальный процесс в Linux
- Координаты встречи (Красная площадь) — переход к Season 3
- Время 04:15 — отсылка к RFC 4159 (BGP routing, тема Season 3)
- "Что случилось два года назад" — главная интрига всего курса

🎬 **Отсылки:**
- "Финальный экзамен" — как в фильме "The Imitation Game"
- Троянская программа — реальная техника кибератак
- Поиск утечек — навык из NASA/SpaceX разработки (критические системы)
- DoS через утечки — реальная атака (Slowloris, ReDoS)

🔬 **Интересный факт:**
Утечка памяти в Windows NT 4.0 заставляла перезагружать серверы каждые 49 дней. Microsoft исправила это только в SP6!

---

## 🎁 Артефакт

После выполнения финальной миссии вы получите:
- **Навык**: мастерство поиска и устранения утечек на уровне эксперта
- **Инструмент**: `memory_guardian` — система контроля утечек
- **Сертификат**: 🏆 **Memory Management Expert**
- **Координаты**: Встреча с V. на Красной площади
- **Доступ**: Season 3 (Networks) разблокирован!

**Season 2 завершён!** Вы освоили память на профессиональном уровне и готовы к следующему вызову.

---

## 🔗 Навигация

- [← Episode 07: Deep Dive](../episode-07-deep-dive/README.md)
- [→ Season 3: Networks](../../season-3-networks/README.md)
- [📋 Season 2: Memory & Pointers](../README.md)
- [🏠 Главная страница](../../README.md)

---

> *"Clean code is not just about logic. It's about resources — allocated, used, and freed with precision."* — V.

```
// SEASON 2: COMPLETE ✅
// MEMORY MASTERED
// LEAKS: 0
// TROJAN: NEUTRALIZED
// 
// COORDINATES RECEIVED: 55.7558° N, 37.6173° E
// MEETING TIME: 12:00, Friday, October 3
// 
// MOONLIGHT STATUS: ACTIVE
// NEXT MISSION: NETWORK INFILTRATION
// SEASON 3: NETWORKS — UNLOCKED
// 
// SEE YOU ON RED SQUARE, AGENT.
```
