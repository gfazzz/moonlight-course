# Episode 07: "Deep Dive" 💾

> *"Static memory is a cage. Dynamic memory is freedom — and responsibility."*

---

## 🎬 BRIEFING

```
╔══════════════════════════════════════════════════════════╗
║  ЛОКАЦИЯ: Safe House, Кузьминки, Москва                 ║
║  ВРЕМЯ:   19:30, среда, 1 октября                       ║
║  СТАТУС:  🔴 FILE GROWING REMOTELY - ATTACK DETECTED     ║
╚══════════════════════════════════════════════════════════╝
```

**ВРЕМЕННАЯ ЛИНИЯ:**
```
13:45  ✅ Цепочка указателей пройдена (Episode 06)
15:00  📧 Новый файл от V.: archive.dat (размер: 2.4 KB)
15:30  📊 Анализ структуры файла начат
17:00  ⚠️  Попытка загрузить в статический массив — переполнение!
17:45  🚨 КРИТИЧЕСКОЕ: Файл растёт в реальном времени!
17:47  📧 "Призрак" предупреждает о 185.220.101.47 (Tor exit node)
18:15  💡 Обнаружен удалённый поток данных
18:42  📞 Звонок Анне (техподдержка по dynamic allocation)
19:30  🎯 Решение: malloc/realloc для растущих данных
20:15  ✅ Поток остановлен → Episode 08
```

---

## 🎭 ПЕРСОНАЖИ ЭПИЗОДА

**Появляются в этом эпизоде:**

🔄 **Виктор Петров** (V.)
- **Роль:** Отправитель файла archive.dat
- **Момент:** 15:00 — файл начинает расти динамически
- **Связь:** Тестирует навыки работы с динамической памятью

👻 **"Призрак"** — анонимный хакер
- **Роль:** Предупреждает об удалённой атаке
- **Момент:** 17:47 — отправляет предупреждение
- **Сообщение:** *"IP 185.220.101.47 — Tor exit node. Кто-то заливает данные удалённо. Найди команду STOP_STREAM в потоке. :)"*
- **Помощь:** Раскрывает источник атаки

🔄 **Анна Ковалёва** — Forensics Specialist
- **Роль:** Техническая консультация
- **Момент:** 18:42 — вы звоните за помощью
- **Реплика:** *"Динамические данные требуют heap. malloc выделяет, realloc расширяет, free освобождает. Каждый malloc ДОЛЖЕН иметь free, иначе утечка. У тебя 40 минут."*
- **Помощь:** Объясняет malloc/realloc/free lifecycle

⚔️ **Полковник Крылов** (упоминается)
- **Момент:** "Призрак" намекает, что за атакой стоит Z.
- **Статус:** Продолжает охоту, напряжение растёт

> **Expanded Cast в действии:** "Призрак" раскрывает технические детали атаки, Анна помогает с malloc/free, давление от Z. усиливается.

### 🔐 СИТУАЦИЯ — ФАЙЛ РАСТЁТ!

После расшифровки цепочки указателей вы получили координаты безопасного убежища и адрес heap-памяти: `0x600000000000`. V. подготовил вас к следующему шагу.

**15:00** — На защищённый канал приходит файл `archive.dat`. Метаданные:

```
Имя:     archive.dat
Размер:  2.4 KB (при получении)
Тип:     Structured archive
Отправитель: V. (зашифрованный канал)
Сообщение: "Статические массивы больше не работают. Heap или ничего."
```

Вы начинаете анализ. Пробуете загрузить в статический массив:

```c
char buffer[4096];  // 4KB — должно хватить, верно?
FILE *f = fopen("archive.dat", "rb");
size_t read = fread(buffer, 1, sizeof(buffer), f);
printf("Read: %zu bytes\n", read);
```

**17:00** — Программа падает:
```
*** buffer overflow detected ***
Read: 4096 bytes (buffer full!)
*** stack smashing detected ***
Aborted (core dumped)
```

Вы смотрите на размер файла снова... **Он изменился!**

```bash
$ ls -lh archive.dat
-rw-r--r-- 1 user user 6.8K Oct 1 17:00 archive.dat  # Было 2.4KB!
```

---

### 🚨 ТВИСТ — ДИНАМИЧЕСКИЙ РОСТ В 17:45

Вы наблюдаете за файлом в реальном времени:

```
17:00  →  6.8 KB
17:15  →  12.3 KB  (+5.5KB за 15 минут!)
17:30  →  18.7 KB
17:45  →  25.1 KB  (продолжает расти!)
```

**Кто-то заливает данные в файл удалённо!**

Вы проверяете сетевые подключения:

```bash
$ netstat -an | grep ESTABLISHED
tcp  0  0  192.168.1.42:8443  185.220.101.X:443  ESTABLISHED
         ↑ ваш компьютер        ↑ неизвестный сервер
```

Входящее соединение. Данные поступают непрерывно.

SMS на телефон:

```
╔═══════════════════════════════════════════════════════════╗
║  От: +7-XXX-XXX-XXXX (неизвестный)                        ║
║  Время: 17:47                                             ║
║                                                           ║
║  "Думаешь, V. даёт тебе всё просто так?                  ║
║   Каждая секунда = +100KB данных.                        ║
║   Найди источник за 3 часа.                              ║
║   Или твой диск переполнится. — Z."                      ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

Вы проверяете свободное место:

```bash
$ df -h .
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1       50G   48G   1.2G  98%  /
                           ↑ Осталось 1.2GB!
```

**Математика:**
- Скорость роста: ~100KB/сек = 6MB/мин = 360MB/час
- Свободное место: 1.2GB
- **Время до заполнения диска: ~3.3 часа**

### 🎯 ЗАДАЧА — ОСТАНОВИТЬ ПОТОК

**Что нужно сделать:**
1. ✅ Создать `dynamic_loader` — загрузчик с динамической памятью
2. ✅ Парсить растущий файл в реальном времени
3. ✅ Найти скрытую команду остановки потока в данных
4. ✅ Остановить удалённую загрузку
5. ✅ Корректно освободить всю память

**Сложность:** 🔴 Hard  
**Новые навыки:** malloc, free, calloc, realloc, heap management, работа с растущими данными  
**Deadline:** ⏰ 3 часа до заполнения диска

**17:30** — Вы пытаетесь загрузить файл в статический массив. Переполнение буфера. Crash.

```c
char buffer[1024];  // Слишком мало!
// File size: 3.8MB и растёт...
```

Статические массивы бессильны. Размер неизвестен заранее. Файл растёт в реальном времени.

Нужна **динамическая память**. Выделять столько, сколько нужно. Во время выполнения.

---

## 📚 THEORY 1: Stack vs Heap и malloc/free

### 💡 Зачем нужна динамическая память?

**Проблемы статической памяти:**
- 🚫 **Фиксированный размер** — объявляется при компиляции
- 🚫 **Ограничена стеком** — обычно ~8MB
- 🚫 **Не растёт** — нельзя изменить размер
- 🚫 **Умирает со scope** — нельзя вернуть из функции

**Когда нужна динамическая память:**
- 📁 **Файлы неизвестного размера** — загрузка данных
- 🌐 **Сетевые буферы** — пакеты переменной длины
- 🗂️ **Структуры данных** — деревья, графы, списки
- 🎮 **Игры** — динамические объекты, частицы
- 🤖 **AI/ML** — матрицы весов, датасеты

---

### 1. Stack vs Heap — две области памяти

**📊 МЕТАФОРА: КВАРТИРА vs СКЛАД**

```
╔═══════════════════════════════════════════════════════════╗
║  ПАМЯТЬ ПРОГРАММЫ — ДВА МИРА                              ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  🏠 STACK (КВАРТИРА) — 8MB                                ║
║  ┌──────────────────────────────────────┐                ║
║  │ Локальные переменные                 │                ║
║  │ ┌──────┐ ┌──────┐ ┌──────┐          │                ║
║  │ │ int x│ │char c│ │arr[5]│          │ Автоматическое║
║  │ └──────┘ └──────┘ └──────┘          │ Быстрое       ║
║  │  ↑ Вышел из функции — всё исчезло!  │ Ограниченное  ║
║  └──────────────────────────────────────┘                ║
║                                                           ║
║  🏗️ HEAP (СКЛАД) — Гигабайты                             ║
║  ┌──────────────────────────────────────┐                ║
║  │ Динамические данные                  │                ║
║  │  [███████    ] [████] [██████████]   │ Ручное        ║
║  │   malloc()     malloc()  malloc()    │ Медленнее     ║
║  │      ↑           ↑          ↑        │ Огромное      ║
║  │   Живут до free()!                   │               ║
║  └──────────────────────────────────────┘                ║
║                                                           ║
║  КВАРТИРА (Stack):                                       ║
║  + Быстрая уборка (автоматическая)                       ║
║  - Мало места (8MB)                                      ║
║  - Нельзя расширить                                      ║
║                                                           ║
║  СКЛАД (Heap):                                           ║
║  + Огромное пространство (гигабайты)                     ║
║  + Можно арендовать сколько нужно                        ║
║  - Нужно вручную убирать (free)                          ║
║  - Медленнее доступ                                      ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**Код:**

```c
// STACK (квартира)
void function() {
    int x = 42;           // Выделено на стеке
    char name[10];        // Тоже на стеке
    // При выходе из функции — всё автоматически освобождается
}

// HEAP (склад)
void function() {
    int *p = malloc(sizeof(int));    // Арендуем место на складе
    *p = 42;
    // p не освободится автоматически!
    free(p);  // Нужно вернуть "ключ от ячейки"
}
```

**📊 Визуализация в памяти:**

```
┌─────────────────────────────────────────┐
│ АДРЕСНОЕ ПРОСТРАНСТВО ПРОГРАММЫ         │
├─────────────────────────────────────────┤
│ 0xFFFFFFFF                              │
│ ┌─────────────────────────────┐         │
│ │ STACK (растёт вниз ↓)       │         │
│ │ ┌─────┐ ← текущая функция   │         │
│ │ │ int │                      │  ~8MB  │
│ │ └─────┘                      │         │
│ │   ...                        │         │
│ └─────────────────────────────┘         │
│                                         │
│         ← свободная область →           │
│                                         │
│ ┌─────────────────────────────┐         │
│ │ HEAP (растёт вверх ↑)       │         │
│ │ [███] [██] [████████]       │  Гига-  │
│ │  ↑malloc   ↑malloc          │  байты  │
│ │                             │         │
│ └─────────────────────────────┘         │
│ 0x00000000                              │
└─────────────────────────────────────────┘
```

---

### 2. malloc() — аренда памяти

**📊 МЕТАФОРА: АРЕНДА ЯЧЕЙКИ НА СКЛАДЕ**

```
╔═══════════════════════════════════════════════════════════╗
║  СКЛАД HEAP — АРЕНДА ЯЧЕЕК                                ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  ВЫ: "Хочу арендовать ячейку на 100 байт"                ║
║       ↓                                                   ║
║  СКЛАД (malloc): "Вот ключ: адрес 0x600012345000"        ║
║       ↓                                                   ║
║  ┌─────────────────────────┐                             ║
║  │ Ячейка #0x600012345000  │ ← Ваша арендованная память  ║
║  │ ┌───────────────┐       │                             ║
║  │ │ 100 байт      │       │   Можете хранить что угодно ║
║  │ │ [ваши данные] │       │   Живёт до free()!          ║
║  │ └───────────────┘       │                             ║
║  └─────────────────────────┘                             ║
║         ↑                                                 ║
║    int *p = malloc(100);  ← p хранит "ключ" (адрес)      ║
║                                                           ║
║  ПРАВИЛО: Получил ключ (malloc) → верни ключ (free)      ║
║           Иначе ячейка навсегда заблокирована! (утечка)  ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**Синтаксис:**

```c
#include <stdlib.h>

// malloc - memory allocation
void *malloc(size_t size);

// Примеры
int *p = malloc(sizeof(int));           // Арендуем 4 байта
int *arr = malloc(10 * sizeof(int));    // Арендуем 40 байт (массив из 10 int)
char *str = malloc(100);                 // Арендуем 100 байт для строки

// КРИТИЧЕСКИ ВАЖНО: проверить на NULL!
if (p == NULL) {
    fprintf(stderr, "Склад переполнен! Нет свободных ячеек!\n");
    return 1;
}

*p = 42;  // Используем

free(p);  // Вернули ключ — ячейка свободна для других
```

**⚠️ Важные детали:**
- `malloc()` возвращает `void*` — универсальный указатель
- Память **НЕ инициализирована** — содержит мусор!
- **ВСЕГДА проверяйте на NULL** — память может кончиться
- Размер задаётся в **байтах** — используйте `sizeof()`

---

### 3. free() — возврат ключа

```c
int *p = malloc(100);  // Арендовали
// ... используем ...
free(p);  // Вернули ключ

// После free():
// - Память освобождена
// - p больше нельзя разыменовывать!
// - Можно обнулить: p = NULL (good practice)
```

**📊 Lifecycle памяти:**

```
╔═══════════════════════════════════════════════════════════╗
║  ЖИЗНЕННЫЙ ЦИКЛ ДИНАМИЧЕСКОЙ ПАМЯТИ                       ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  1. ВЫДЕЛЕНИЕ (malloc)                                    ║
║     int *p = malloc(100);                                 ║
║     ┌────────────┐                                        ║
║     │ Heap block │ ← выделено, содержит МУСОР!           ║
║     └────────────┘                                        ║
║          ↑                                                ║
║          p (ключ от ячейки)                               ║
║                                                           ║
║  2. ИСПОЛЬЗОВАНИЕ                                         ║
║     *p = 42;                                              ║
║     ┌────────────┐                                        ║
║     │  p = 42    │ ← содержит данные                     ║
║     └────────────┘                                        ║
║                                                           ║
║  3. ОСВОБОЖДЕНИЕ (free)                                   ║
║     free(p);                                              ║
║     ┌────────────┐                                        ║
║     │   FREE!    │ ← освобождено                         ║
║     └────────────┘                                        ║
║          ⨯                                                ║
║     p теперь ОПАСЕН! (dangling pointer)                   ║
║                                                           ║
║  4. ОБНУЛЕНИЕ (good practice)                             ║
║     p = NULL;                                             ║
║     p = NULL → безопасно                                  ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

---

## 🔍 КОНТРОЛЬНЫЕ ВОПРОСЫ (THEORY 1)

**Проверьте понимание Stack/Heap и malloc/free:**

1. **Stack vs Heap:** В чём ключевое отличие? Где хранятся локальные переменные, где — malloc?
2. **malloc:** Что возвращает `malloc()` в случае ошибки? Почему нужна проверка на `NULL`?
3. **free:** Почему каждый `malloc` ДОЛЖЕН иметь соответствующий `free`? Что такое memory leak?
4. **Dangling pointer:** Почему после `free(p)` рекомендуется делать `p = NULL`?

<details>
<summary>💡 Показать ответы</summary>

1. **Stack** — автоматическая память (локальные переменные), фиксированный размер. **Heap** — динамическая, выделяется вручную, ограничена только RAM.
2. Возвращает `NULL`. Без проверки → разыменование NULL → краш!
3. Без `free` память остаётся занятой → **утечка памяти**. В цикле = исчерпание RAM.
4. **Dangling pointer** указывает на освобождённую память. `p = NULL` делает его безопасным — разыменование NULL вызовет краш сразу, а не непредсказуемое поведение.

</details>

---

**18:15** — Вы пытаетесь связаться с **"Призраком"**. Защищённый канал. Пишете:

```
"Файл растёт. Удалённая атака. 3 часа до заполнения диска.
 Как остановить поток? Нужна помощь."
```

Ответ приходит через 2 минуты:

```
╔════════════════════════════════════════════════════════╗
║  От: [ENCRYPTED] — "Призрак"                          ║
║                                                        ║
║  "IP: 185.220.101.47 = Tor exit node. Поток идёт      ║
║   через несколько прокси. Прямое блокирование не      ║
║   сработает. Ищи команду STOP в самих данных.         ║
║                                                        ║
║   Используй realloc() — файл растёт динамически.      ║
║   Выделяй память порциями, расширяй буфер.            ║
║   Утечки недопустимы — каждый байт на счету.          ║
║                                                        ║
║   Действуй быстро. 2ч 45мин осталось."                ║
║                                                        ║
╚════════════════════════════════════════════════════════╝
```

**"Призрак"** снова помогает. **realloc()** — нужно разобраться...

---

## 📚 THEORY 2: calloc, realloc и динамические строки

### calloc() — malloc с обнулением

```c
// malloc: выделяет память с МУСОРОМ
int *arr1 = malloc(10 * sizeof(int));
// arr1[0] может быть = 2394857 (случайный мусор!)

// calloc: выделяет память и ОБНУЛЯЕТ
int *arr2 = calloc(10, sizeof(int));
// arr2[0] = 0, arr2[1] = 0, ... (все нули)

free(arr1);
free(arr2);
```

**Когда использовать:**
- `malloc` — когда сразу заполняете данными (быстрее)
- `calloc` — когда нужны нули (безопаснее, но медленнее)

---

### 5. realloc() — изменение размера

**📊 МЕТАФОРА: ПЕРЕЕЗД НА БОЛЬШУЮ ЯЧЕЙКУ**

```
╔═══════════════════════════════════════════════════════════╗
║  REALLOC — ПЕРЕЕЗД В БОЛЬШУЮ ЯЧЕЙКУ                       ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  БЫЛО: арендовали 10 байт                                 ║
║  ┌──────────┐                                             ║
║  │ 10 байт  │ ← p = 0x1000                                ║
║  │ [данные] │                                             ║
║  └──────────┘                                             ║
║                                                           ║
║  realloc(p, 20);  ← "Хочу 20 байт!"                       ║
║                                                           ║
║  СТАЛО: 2 варианта                                        ║
║                                                           ║
║  Вариант A: Расширили на месте                            ║
║  ┌────────────────────┐                                   ║
║  │ 20 байт            │ ← p = 0x1000 (тот же адрес!)     ║
║  │ [данные][........] │                                   ║
║  └────────────────────┘                                   ║
║                                                           ║
║  Вариант B: Переехали (нет места рядом)                   ║
║  ┌──────────┐ (старое)                                    ║
║  │ FREE!    │ ← 0x1000 освобождено                        ║
║  └──────────┘                                             ║
║                                                           ║
║  ┌────────────────────┐ (новое)                           ║
║  │ 20 байт            │ ← p = 0x2000 (НОВЫЙ адрес!)      ║
║  │ [данные][........] │   данные скопированы             ║
║  └────────────────────┘                                   ║
║                                                           ║
║  ⚠️ ВАЖНО: адрес может измениться!                        ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**Безопасное использование:**

```c
int *arr = malloc(10 * sizeof(int));

// ❌ ОПАСНО: если вернёт NULL, arr потеряется!
arr = realloc(arr, 20 * sizeof(int));

// ✅ ПРАВИЛЬНО: используем временную переменную
int *temp = realloc(arr, 20 * sizeof(int));
if (temp != NULL) {
    arr = temp;  // Успех! Обновляем указатель
} else {
    // Ошибка! arr ещё валиден, можно освободить
    free(arr);
    return 1;
}

// Используем увеличенный массив
arr[15] = 42;

free(arr);
```

---

### 6. Динамические строки

**Задача:** прочитать строку неизвестной длины.

```c
char* read_dynamic_string() {
    int capacity = 10;  // Начальная вместимость
    int length = 0;
    char *buffer = malloc(capacity);
    
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {
        // Если буфер заполнен — увеличиваем
        if (length + 1 >= capacity) {
            capacity *= 2;  // Удваиваем!
            char *temp = realloc(buffer, capacity);
            if (!temp) {
                free(buffer);
                return NULL;
            }
            buffer = temp;
        }
        
        buffer[length++] = c;
    }
    
    buffer[length] = '\0';
    return buffer;  // Вызывающий ДОЛЖЕН free()!
}
```

**Паттерн роста:**
```
Capacity: 10 → 20 → 40 → 80 → 160 → ...
         (удвоение при заполнении)
```

---

## 🔍 КОНТРОЛЬНЫЕ ВОПРОСЫ (THEORY 2)

**Проверьте понимание calloc/realloc и динамических строк:**

5. **calloc vs malloc:** В чём разница? Когда использовать calloc?
6. **realloc:** Как работает `realloc()`? Почему нельзя делать `ptr = realloc(ptr, new_size)`?
7. **Динамические строки:** Как правильно создать строку динамически? Не забыть `+1` для `'\0'`!
8. **Рост буфера:** Почему при росте массива используют удвоение размера (×2), а не +1?

<details>
<summary>💡 Показать ответы</summary>

5. **calloc** обнуляет память, **malloc** оставляет мусор. calloc для массивов, где нужны нули.
6. **realloc** может переместить блок памяти → возвращает новый адрес! Нужно: `new_ptr = realloc(ptr, size); if (new_ptr) ptr = new_ptr;`
7. `char *str = malloc(strlen(source) + 1);` — **+1 для '\0'!** Иначе переполнение при strcpy.
8. Удвоение = **O(log n)** перевыделений. +1 = O(n) перевыделений → очень медленно!

</details>

---

**19:00** — Вы звоните **Анне Ковалёвой**. Она отвечает:

```
╔════════════════════════════════════════════════════════╗
║  📞 ВЫЗОВ: Анна Ковалёва                              ║
║  Статус: Forensics Specialist                         ║
╚════════════════════════════════════════════════════════╝
```

— **Анна, файл растёт динамически. 4.1MB и продолжает. Как парсить?**  
— *Динамический рост? Используй реал локк для расширения буфера. Порциями по 64KB — оптимально для IO.*

Вы слышите шум на фоне.

— *Слушай, я на задании. Быстро: выделяй большой блок сразу (1-2MB), парси порциями. Не забудь освободить — проверь valgrind или leaks. Удачи.*

Связь обрывается.

**19:10** — Теперь понятно. Но нужно разобраться с двумерными массивами и частыми ошибками...

---

## 📚 THEORY 3: Двумерные массивы и ошибки

### Двумерные динамические массивы

**Метод 1: Массив указателей**

```c
int rows = 3, cols = 4;

// Выделить массив указателей на строки
int **matrix = malloc(rows * sizeof(int*));

// Выделить каждую строку отдельно
for (int i = 0; i < rows; i++) {
    matrix[i] = malloc(cols * sizeof(int));
}

// Использование
matrix[1][2] = 42;

// Освобождение (в обратном порядке!)
for (int i = 0; i < rows; i++) {
    free(matrix[i]);  // Сначала строки
}
free(matrix);  // Потом массив указателей
```

**Метод 2: Один блок** (эффективнее):

```c
int *matrix = malloc(rows * cols * sizeof(int));

// Доступ как matrix[i][j]:
#define INDEX(i, j) ((i) * cols + (j))
matrix[INDEX(1, 2)] = 42;

free(matrix);  // Одно освобождение!
```

---

### 8. Распространённые ошибки

```c
// ❌ Утечка памяти
void leak() {
    int *p = malloc(100);
    // Забыли free(p)!
}  // p исчезает, но память не освобождена!

// ❌ Double free
int *p = malloc(100);
free(p);
free(p);  // КРАШ!

// ❌ Use after free
int *p = malloc(100);
free(p);
*p = 42;  // КРАШ! Память уже не наша!

// ❌ Потерянный указатель
int *p = malloc(100);
p = malloc(200);  // Старый блок потерян! Утечка!

// ✅ Правильно
int *p = malloc(100);
if (p == NULL) {
    return 1;
}
*p = 42;
free(p);
p = NULL;  // Good practice
```

---

## 🔍 КОНТРОЛЬНЫЕ ВОПРОСЫ (THEORY 3)

**Проверьте понимание двумерных массивов и ошибок:**

9. **Двумерный массив:** Как выделить динамический двумерный массив 3×4?
10. **Double free:** Что произойдёт при `free(p); free(p);`? Почему это опасно?
11. **Memory leak:** Как возникает утечка памяти? Приведите пример.
12. **Валидация:** Почему КАЖДЫЙ `malloc` нужно проверять на `NULL`?

<details>
<summary>💡 Показать ответы</summary>

9. Массив указателей: `int **matrix = malloc(3 * sizeof(int*));` затем каждую строку: `matrix[i] = malloc(4 * sizeof(int));`
10. **Краш!** Система пытается освободить уже освобождённый блок → corruption → segfault!
11. Выделяем память, но не освобождаем: `p = malloc(100); p = malloc(200);` — первый блок потерян навсегда.
12. Если памяти нет → `malloc` вернёт `NULL`. Разыменование `NULL` → **краш программы!**

</details>

---

**19:30** — Теория изучена. "Призрак" объяснил realloc, Анна посоветовала порции 64KB. 

Время практики. Сначала разминка — динамическая строка с realloc...

---

## 🎯 ПРОМЕЖУТОЧНАЯ ЗАДАЧА: "Dynamic String"

> *"Перед загрузкой архива переменного размера, научитесь работать с realloc."*

### Задача

Реализовать функцию `read_dynamic_string()`, которая читает строку **любой длины** из stdin, используя `realloc` для роста буфера.

**Требования:**
1. Начальная вместимость: 10 байт
2. При заполнении — удваивать размер буфера
3. Выводить сообщения о realloc
4. Корректно освобождать память

**Ожидаемый вывод:**
```
Enter text (press Enter to finish):
> This is a very long string that will trigger realloc multiple times because it exceeds initial capacity
[Realloc: 10 → 20 bytes]
[Realloc: 20 → 40 bytes]
[Realloc: 40 → 80 bytes]
[Realloc: 80 → 160 bytes]

✓ String read successfully!
Length: 108 characters
Content: "This is a very long string..."

✓ Memory freed. No leaks!
```

### Starter Code

В `starter.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* read_dynamic_string() {
    int capacity = 10;
    int length = 0;
    char *buffer = malloc(capacity);
    
    if (!buffer) return NULL;
    
    printf("Enter text (press Enter to finish):\n> ");
    
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {
        // TODO: Проверить заполнение буфера
        // TODO: Если заполнен — вызвать realloc
        // TODO: Добавить символ в буфер
    }
    
    buffer[length] = '\0';
    return buffer;
}

int main() {
    char *str = read_dynamic_string();
    
    if (!str) {
        fprintf(stderr, "✗ Memory allocation failed!\n");
        return 1;
    }
    
    printf("\n✓ String read successfully!\n");
    printf("Length: %zu characters\n", strlen(str));
    printf("Content: \"%s\"\n", str);
    
    // TODO: Освободить память!
    
    return 0;
}
```

### Проверка

```bash
cd episode-07-deep-dive
gcc -Wall -o dynamic_string artifacts/dynamic_string.c
./dynamic_string

# Или автотест:
bash tests/test_dynamic_string.sh
```

**Критерий успеха:** строка любой длины читается без ошибок, память освобождается.

---

**20:15** — Динамическая строка работает. realloc освоен.

```bash
$ ./dynamic_string
Enter string: This is a very long string that requires multiple realloc calls!
You entered (67 chars): This is a very long string that requires multiple realloc calls!
✓ Memory freed successfully!
```

Файл `archive.dat` продолжает расти. **4.8MB**. Свободное место: **980MB**. Осталось **~2.5 часа**.

Пора загрузить весь архив, найти команду STOP и остановить поток.

---

## 🎯 Основная миссия: "Dynamic Loader"

### Задача

Создать **`stream_handler`** — программу для загрузки растущего файла:
1. ✅ Загрузить `archive.dat` (размер неизвестен!)
2. ✅ Использовать `realloc()` для динамического роста буфера
3. ✅ Парсить данные и найти команду `STOP_STREAM`
4. ✅ Остановить удалённый поток
5. ✅ Корректно освободить ВСЮ память (проверка valgrind/leaks)

**Критическая важность:** Утечка памяти = crash системы. Каждый malloc = обязательный free!

### Легенда

Файл `archive.dat` растёт в реальном времени. Кто-то заливает данные удалённо со скоростью 100KB/сек.

У вас 3 часа до заполнения диска.

В архиве спрятана команда остановки потока, но сначала нужно распарсить его весь.

**Формат архива:**

```
[HEADER]
  magic: "MOON" (4 байта)
  version: uint16_t
  block_count: uint16_t
  
[BLOCKS] (переменное количество)
  type: uint8_t
  size: uint32_t
  data: size байт (динамически!)
  
[INDEX]
  offset: uint32_t (для каждого блока)
  type: uint8_t
```

**Типы блоков:**
- `0x01` — TEXT
- `0x02` — BINARY
- `0x03` — COMPRESSED
- `0xFF` — **COMMAND** (команда остановки!)

**Ваша задача:**
1. Читать заголовок
2. Динамически выделять память под каждый блок
3. Найти блок типа `0xFF` (COMMAND)
4. Декодировать команду остановки
5. **Освободить всю память**

### Структуры данных

```c
typedef struct {
    char magic[4];
    uint16_t version;
    uint16_t block_count;
} Header;

typedef struct {
    uint8_t type;
    uint32_t size;
    uint8_t *data;  // Динамически выделенная память!
} Block;

typedef struct {
    uint32_t offset;
    uint8_t type;
} IndexEntry;
```

### Starter Code

В `starter.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#define TYPE_TEXT       0x01
#define TYPE_BINARY     0x02
#define TYPE_COMPRESSED 0x03
#define TYPE_COMMAND    0xFF

// TODO: Определите структуры

// Читает заголовок
Header* read_header(FILE *f) {
    Header *h = malloc(sizeof(Header));
    if (!h) return NULL;
    
    fread(h, sizeof(Header), 1, f);
    
    // Валидация magic
    if (memcmp(h->magic, "MOON", 4) != 0) {
        free(h);
        return NULL;
    }
    
    return h;
}

// Читает один блок (с malloc для data!)
Block* read_block(FILE *f) {
    // TODO: 
    // 1. malloc для Block
    // 2. Прочитать type и size
    // 3. malloc для data (размер = size)
    // 4. Прочитать data
    // 5. Вернуть Block
}

// Освобождает блок
void free_block(Block *block) {
    if (block) {
        free(block->data);  // Сначала вложенные данные
        free(block);         // Потом структуру
    }
}

int main(int argc, char *argv[]) {
    // TODO:
    // 1. Открыть файл
    // 2. Прочитать заголовок
    // 3. Выделить массив блоков (malloc)
    // 4. Загрузить каждый блок
    // 5. Найти блок TYPE_COMMAND
    // 6. Вывести команду остановки
    // 7. Освободить всё (free)
    
    return 0;
}
```

---

## 🎬 DEBRIEFING

```
╔═══════════════════════════════════════════════════════════╗
║      🎯 АРХИВ ЗАГРУЖЕН! ПОТОК ОСТАНОВЛЕН!                 ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  ✓ Файл прочитан: 47.3 MB (динамический размер)          ║
║  ✓ Блоков загружено: 2,847                               ║
║  ✓ Память выделена: 49,823,744 байт                      ║
║  ✓ Индекс построен: 2,847 записей                        ║
║  ✓ Блок COMMAND найден: offset 0x2F4A8B0                 ║
║                                                           ║
║  [!] КОМАНДА ОСТАНОВКИ ДЕКОДИРОВАНА:                     ║
║                                                           ║
║     STOP_STREAM 185.220.101.47:8443                      ║
║     AUTH_TOKEN: 4f3a2c1b9e8d7a6f                         ║
║                                                           ║
║  ✓ Отправлено на удалённый сервер                        ║
║  ✓ Поток остановлен!                                     ║
║  ✓ Память освобождена: 100% (утечек нет)                 ║
║                                                           ║
║  📍 Последнее сообщение от V.:                           ║
║     "Динамическая память освоена.                        ║
║      Но помни: с большой силой приходит большая          ║
║      ответственность. Каждый malloc — обещание.          ║
║      Каждый free — выполнение обещания.                  ║
║                                                           ║
║      Episode 08 — последний экзамен:                     ║
║      Научись находить нарушенные обещания. — V."         ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**20:15** — Поток остановлен. Диск спасён. Вы освобождаете всю память (все free вызваны корректно).

Делаете паузу. Кофе. Глубокий вдох. Три эпизода позади.

**21:00** — Новое сообщение на защищённый канал. От V.

```
╔═══════════════════════════════════════════════════════════╗
║  От: V.                                                   ║
║  Тема: Инструмент мониторинга                            ║
║  Время: 21:00                                            ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  "Используй эту программу для мониторинга активности Z.  ║
║   Она будет логировать все попытки доступа.              ║
║   Запусти и оставь работать. — V."                       ║
║                                                           ║
║  Вложение: moonlight_monitor.c                           ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

Вы доверяете V. Компилируете. Запускаете.

**21:30** — Программа работает. Логи пишутся. Всё штатно.

**22:30** — Система начинает притормаживать...

```bash
$ free -h
              total        used        free
Mem:           16Gi        4.1Gi       11Gi  # Память растёт...
```

**00:15** — Система серьёзно тормозит. Swap активирован.

**01:30** — **КРИТИЧЕСКИЙ УРОВЕНЬ:**

```bash
$ free -h
              total        used        free      
Mem:           16Gi        15Gi        512Mi  🔥
Swap:          8Gi         3.2Gi       4.8Gi  ← SWAP активен!
```

Вы анализируете код программы... и замираете.

Там **утечки памяти**. В нескольких местах.

Проверяете автора файла:

```bash
$ strings moonlight_monitor.c | grep -i author
// Author: Z. (Infiltration Module v2.1)
// Purpose: Resource Exhaustion Attack
```

**Это НЕ от V. Это ТРОЯН от Z.!**

**02:02** — SMS:

```
╔═══════════════════════════════════════════════════════════╗
║  От: +7-XXX-XXX-XXXX (Z.)                                 ║
║                                                           ║
║  "Поздравляю, ты запустил мою программу.                 ║
║   Утечка памяти — это не баг. Это оружие.                ║
║                                                           ║
║   Через 15 минут твоя система рухнет.                    ║
║   Все данные операции MOONLIGHT будут уничтожены.        ║
║                                                           ║
║   Но я дам тебе шанс: найди ВСЕ утечки.                  ║
║   Докажи инструментами. Исправь код.                     ║
║                                                           ║
║   Если справишься — получишь координаты встречи          ║
║   с настоящим V. на Красной площади.                     ║
║                                                           ║
║   Таймер пошёл. — Z."                                    ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**🎯 CLIFFHANGER:**
- Троянская программа от Z., не от V.!
- Утечка памяти как оружие DoS-атаки
- Система рухнет через 15 минут
- Последний тест: найти ВСЕ утечки
- Финал Season 2 в Episode 08

**Продолжение в Episode 08: "Fragmentation" (ФИНАЛ)** →

### 📊 Статистика:
- ⏱️ Среднее время: 90-120 минут (с промежуточной задачей)
- 🎓 Новые навыки: **malloc**, **free**, **realloc**, **heap management**
- 🏆 Достижение: **"Heap Master"**

### 🔓 Skill Unlocked: **Dynamic Memory Mastery**
```
[████████████████████] 100%

Вы освоили:
✓ Выделение памяти (malloc, calloc)
✓ Изменение размера (realloc)
✓ Освобождение памяти (free)
✓ Работу с динамическими структурами
✓ Двумерные динамические массивы
✓ Lifecycle управления памятью
✓ Работу с файлами неизвестного размера
```

---

## 🎨 Easter Eggs

🔍 **Скрытые детали:**
- Heap-аллокатор в glibc использует алгоритм ptmalloc2
- Адрес 0x600000000000 — область mmap для больших аллокаций (64-bit)
- Удвоение capacity в realloc — amortized O(1) сложность
- Команда STOP_STREAM — реальный паттерн управления потоками

🎬 **Отсылки:**
- Растущий файл — атака "disk fill" из real-world hacking
- Метафора склада — из книги "Expert C Programming"
- malloc/free — прямой аналог new/delete в C++

---

## 🎁 Артефакт

После выполнения вы получите:
- **Навык**: dynamic memory management на уровне эксперта
- **Инструмент**: `dynamic_loader` — загрузчик файлов любого размера
- **Понимание**: Stack vs Heap, lifecycle памяти
- **Готовность**: к Episode 08 (поиск утечек)

---

## 🔗 Навигация

- [← Episode 06: Pointer Game](../episode-06-pointer-game/README.md)
- [→ Episode 08: Fragmentation](../episode-08-fragmentation/README.md)
- [📋 Season 2: Memory & Pointers](../README.md)
- [🏠 Главная страница](../../README.md)

---

> *"With great power comes great responsibility. Every malloc is a promise. Every free is keeping that promise."* — V.

```
// DYNAMIC MEMORY MASTERED
// HEAP ALLOCATED: 49,823,744 BYTES
// ALL FREED: NO LEAKS
// STREAM STOPPED
// READY FOR THE FINAL TEST
//
// TIME: 21:47
// DEADLINE: Episode 08 awaits
```
