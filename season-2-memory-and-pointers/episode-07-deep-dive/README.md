# Episode 07: "Deep Dive" 💾

> *"Static memory is a cage. Dynamic memory is freedom — and responsibility."*

---

## 🎬 BRIEFING

```
╔══════════════════════════════════════════════════════════╗
║  ЛОКАЦИЯ: Safe House, Кузьминки, Москва                 ║
║  ВРЕМЯ:   19:30, среда, 1 октября                       ║
║  СТАТУС:  🔴 FILE GROWING REMOTELY - ATTACK DETECTED     ║
╚══════════════════════════════════════════════════════════╝
```

**ВРЕМЕННАЯ ЛИНИЯ:**
```
13:45  ✅ Цепочка указателей пройдена, координаты убежища найдены
15:00  📧 Новый файл от V.: archive.dat (размер: 2.4 KB)
15:30  📊 Анализ структуры файла начат
17:00  ⚠️  Попытка загрузить в статический массив — переполнение!
17:45  🚨 КРИТИЧЕСКОЕ: Файл растёт в реальном времени!
18:15  💡 Обнаружен удалённый поток данных
19:30  🎯 Решение: динамическое выделение памяти + отслеживание
```

### 🔐 СИТУАЦИЯ — ФАЙЛ РАСТЁТ!

После расшифровки цепочки указателей вы получили координаты безопасного убежища и адрес heap-памяти: `0x600000000000`. V. подготовил вас к следующему шагу.

**15:00** — На защищённый канал приходит файл `archive.dat`. Метаданные:

```
Имя:     archive.dat
Размер:  2.4 KB (при получении)
Тип:     Structured archive
Отправитель: V. (зашифрованный канал)
Сообщение: "Статические массивы больше не работают. Heap или ничего."
```

Вы начинаете анализ. Пробуете загрузить в статический массив:

```c
char buffer[4096];  // 4KB — должно хватить, верно?
FILE *f = fopen("archive.dat", "rb");
size_t read = fread(buffer, 1, sizeof(buffer), f);
printf("Read: %zu bytes\n", read);
```

**17:00** — Программа падает:
```
*** buffer overflow detected ***
Read: 4096 bytes (buffer full!)
*** stack smashing detected ***
Aborted (core dumped)
```

Вы смотрите на размер файла снова... **Он изменился!**

```bash
$ ls -lh archive.dat
-rw-r--r-- 1 user user 6.8K Oct 1 17:00 archive.dat  # Было 2.4KB!
```

---

### 🚨 ТВИСТ — ДИНАМИЧЕСКИЙ РОСТ В 17:45

Вы наблюдаете за файлом в реальном времени:

```
17:00  →  6.8 KB
17:15  →  12.3 KB  (+5.5KB за 15 минут!)
17:30  →  18.7 KB
17:45  →  25.1 KB  (продолжает расти!)
```

**Кто-то заливает данные в файл удалённо!**

Вы проверяете сетевые подключения:

```bash
$ netstat -an | grep ESTABLISHED
tcp  0  0  192.168.1.42:8443  185.220.101.X:443  ESTABLISHED
         ↑ ваш компьютер        ↑ неизвестный сервер
```

Входящее соединение. Данные поступают непрерывно.

SMS на телефон:

```
╔═══════════════════════════════════════════════════════════╗
║  От: +7-XXX-XXX-XXXX (неизвестный)                        ║
║  Время: 17:47                                             ║
║                                                           ║
║  "Думаешь, V. даёт тебе всё просто так?                  ║
║   Каждая секунда = +100KB данных.                        ║
║   Найди источник за 3 часа.                              ║
║   Или твой диск переполнится. — Z."                      ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

Вы проверяете свободное место:

```bash
$ df -h .
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1       50G   48G   1.2G  98%  /
                           ↑ Осталось 1.2GB!
```

**Математика:**
- Скорость роста: ~100KB/сек = 6MB/мин = 360MB/час
- Свободное место: 1.2GB
- **Время до заполнения диска: ~3.3 часа**

### 🎯 ЗАДАЧА — ОСТАНОВИТЬ ПОТОК

**Что нужно сделать:**
1. ✅ Создать `dynamic_loader` — загрузчик с динамической памятью
2. ✅ Парсить растущий файл в реальном времени
3. ✅ Найти скрытую команду остановки потока в данных
4. ✅ Остановить удалённую загрузку
5. ✅ Корректно освободить всю память

**Сложность:** 🔴 Hard  
**Новые навыки:** malloc, free, calloc, realloc, heap management, работа с растущими данными  
**Deadline:** ⏰ 3 часа до заполнения диска

```
╔══════════════════════════════════════════════════════════╗
║  [!] КРИТИЧЕСКИ ВАЖНО:                                   ║
║  Каждый malloc ДОЛЖЕН иметь соответствующий free!        ║
║  При работе с большими файлами утечка = краш.            ║
║  Статические массивы здесь бессильны.                    ║
╚══════════════════════════════════════════════════════════╝
```

---

## 📚 ТЕОРИЯ: Динамическая память в C

### 💡 Зачем нужна динамическая память?

**Проблемы статической памяти:**
- 🚫 **Фиксированный размер** — объявляется при компиляции
- 🚫 **Ограничена стеком** — обычно ~8MB
- 🚫 **Не растёт** — нельзя изменить размер
- 🚫 **Умирает со scope** — нельзя вернуть из функции

**Когда нужна динамическая память:**
- 📁 **Файлы неизвестного размера** — загрузка данных
- 🌐 **Сетевые буферы** — пакеты переменной длины
- 🗂️ **Структуры данных** — деревья, графы, списки
- 🎮 **Игры** — динамические объекты, частицы
- 🤖 **AI/ML** — матрицы весов, датасеты

---

### 1. Stack vs Heap — две области памяти

**📊 МЕТАФОРА: КВАРТИРА vs СКЛАД**

```
╔═══════════════════════════════════════════════════════════╗
║  ПАМЯТЬ ПРОГРАММЫ — ДВА МИРА                              ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  🏠 STACK (КВАРТИРА) — 8MB                                ║
║  ┌──────────────────────────────────────┐                ║
║  │ Локальные переменные                 │                ║
║  │ ┌──────┐ ┌──────┐ ┌──────┐          │                ║
║  │ │ int x│ │char c│ │arr[5]│          │ Автоматическое║
║  │ └──────┘ └──────┘ └──────┘          │ Быстрое       ║
║  │  ↑ Вышел из функции — всё исчезло!  │ Ограниченное  ║
║  └──────────────────────────────────────┘                ║
║                                                           ║
║  🏗️ HEAP (СКЛАД) — Гигабайты                             ║
║  ┌──────────────────────────────────────┐                ║
║  │ Динамические данные                  │                ║
║  │  [███████    ] [████] [██████████]   │ Ручное        ║
║  │   malloc()     malloc()  malloc()    │ Медленнее     ║
║  │      ↑           ↑          ↑        │ Огромное      ║
║  │   Живут до free()!                   │               ║
║  └──────────────────────────────────────┘                ║
║                                                           ║
║  КВАРТИРА (Stack):                                       ║
║  + Быстрая уборка (автоматическая)                       ║
║  - Мало места (8MB)                                      ║
║  - Нельзя расширить                                      ║
║                                                           ║
║  СКЛАД (Heap):                                           ║
║  + Огромное пространство (гигабайты)                     ║
║  + Можно арендовать сколько нужно                        ║
║  - Нужно вручную убирать (free)                          ║
║  - Медленнее доступ                                      ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**Код:**

```c
// STACK (квартира)
void function() {
    int x = 42;           // Выделено на стеке
    char name[10];        // Тоже на стеке
    // При выходе из функции — всё автоматически освобождается
}

// HEAP (склад)
void function() {
    int *p = malloc(sizeof(int));    // Арендуем место на складе
    *p = 42;
    // p не освободится автоматически!
    free(p);  // Нужно вернуть "ключ от ячейки"
}
```

**📊 Визуализация в памяти:**

```
┌─────────────────────────────────────────┐
│ АДРЕСНОЕ ПРОСТРАНСТВО ПРОГРАММЫ         │
├─────────────────────────────────────────┤
│ 0xFFFFFFFF                              │
│ ┌─────────────────────────────┐         │
│ │ STACK (растёт вниз ↓)       │         │
│ │ ┌─────┐ ← текущая функция   │         │
│ │ │ int │                      │  ~8MB  │
│ │ └─────┘                      │         │
│ │   ...                        │         │
│ └─────────────────────────────┘         │
│                                         │
│         ← свободная область →           │
│                                         │
│ ┌─────────────────────────────┐         │
│ │ HEAP (растёт вверх ↑)       │         │
│ │ [███] [██] [████████]       │  Гига-  │
│ │  ↑malloc   ↑malloc          │  байты  │
│ │                             │         │
│ └─────────────────────────────┘         │
│ 0x00000000                              │
└─────────────────────────────────────────┘
```

---

### 2. malloc() — аренда памяти

**📊 МЕТАФОРА: АРЕНДА ЯЧЕЙКИ НА СКЛАДЕ**

```
╔═══════════════════════════════════════════════════════════╗
║  СКЛАД HEAP — АРЕНДА ЯЧЕЕК                                ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  ВЫ: "Хочу арендовать ячейку на 100 байт"                ║
║       ↓                                                   ║
║  СКЛАД (malloc): "Вот ключ: адрес 0x600012345000"        ║
║       ↓                                                   ║
║  ┌─────────────────────────┐                             ║
║  │ Ячейка #0x600012345000  │ ← Ваша арендованная память  ║
║  │ ┌───────────────┐       │                             ║
║  │ │ 100 байт      │       │   Можете хранить что угодно ║
║  │ │ [ваши данные] │       │   Живёт до free()!          ║
║  │ └───────────────┘       │                             ║
║  └─────────────────────────┘                             ║
║         ↑                                                 ║
║    int *p = malloc(100);  ← p хранит "ключ" (адрес)      ║
║                                                           ║
║  ПРАВИЛО: Получил ключ (malloc) → верни ключ (free)      ║
║           Иначе ячейка навсегда заблокирована! (утечка)  ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**Синтаксис:**

```c
#include <stdlib.h>

// malloc - memory allocation
void *malloc(size_t size);

// Примеры
int *p = malloc(sizeof(int));           // Арендуем 4 байта
int *arr = malloc(10 * sizeof(int));    // Арендуем 40 байт (массив из 10 int)
char *str = malloc(100);                 // Арендуем 100 байт для строки

// КРИТИЧЕСКИ ВАЖНО: проверить на NULL!
if (p == NULL) {
    fprintf(stderr, "Склад переполнен! Нет свободных ячеек!\n");
    return 1;
}

*p = 42;  // Используем

free(p);  // Вернули ключ — ячейка свободна для других
```

**⚠️ Важные детали:**
- `malloc()` возвращает `void*` — универсальный указатель
- Память **НЕ инициализирована** — содержит мусор!
- **ВСЕГДА проверяйте на NULL** — память может кончиться
- Размер задаётся в **байтах** — используйте `sizeof()`

---

### 3. free() — возврат ключа

```c
int *p = malloc(100);  // Арендовали
// ... используем ...
free(p);  // Вернули ключ

// После free():
// - Память освобождена
// - p больше нельзя разыменовывать!
// - Можно обнулить: p = NULL (good practice)
```

**📊 Lifecycle памяти:**

```
╔═══════════════════════════════════════════════════════════╗
║  ЖИЗНЕННЫЙ ЦИКЛ ДИНАМИЧЕСКОЙ ПАМЯТИ                       ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  1. ВЫДЕЛЕНИЕ (malloc)                                    ║
║     int *p = malloc(100);                                 ║
║     ┌────────────┐                                        ║
║     │ Heap block │ ← выделено, содержит МУСОР!           ║
║     └────────────┘                                        ║
║          ↑                                                ║
║          p (ключ от ячейки)                               ║
║                                                           ║
║  2. ИСПОЛЬЗОВАНИЕ                                         ║
║     *p = 42;                                              ║
║     ┌────────────┐                                        ║
║     │  p = 42    │ ← содержит данные                     ║
║     └────────────┘                                        ║
║                                                           ║
║  3. ОСВОБОЖДЕНИЕ (free)                                   ║
║     free(p);                                              ║
║     ┌────────────┐                                        ║
║     │   FREE!    │ ← освобождено                         ║
║     └────────────┘                                        ║
║          ⨯                                                ║
║     p теперь ОПАСЕН! (dangling pointer)                   ║
║                                                           ║
║  4. ОБНУЛЕНИЕ (good practice)                             ║
║     p = NULL;                                             ║
║     p = NULL → безопасно                                  ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

---

### 4. calloc() — malloc с обнулением

```c
// malloc: выделяет память с МУСОРОМ
int *arr1 = malloc(10 * sizeof(int));
// arr1[0] может быть = 2394857 (случайный мусор!)

// calloc: выделяет память и ОБНУЛЯЕТ
int *arr2 = calloc(10, sizeof(int));
// arr2[0] = 0, arr2[1] = 0, ... (все нули)

free(arr1);
free(arr2);
```

**Когда использовать:**
- `malloc` — когда сразу заполняете данными (быстрее)
- `calloc` — когда нужны нули (безопаснее, но медленнее)

---

### 5. realloc() — изменение размера

**📊 МЕТАФОРА: ПЕРЕЕЗД НА БОЛЬШУЮ ЯЧЕЙКУ**

```
╔═══════════════════════════════════════════════════════════╗
║  REALLOC — ПЕРЕЕЗД В БОЛЬШУЮ ЯЧЕЙКУ                       ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  БЫЛО: арендовали 10 байт                                 ║
║  ┌──────────┐                                             ║
║  │ 10 байт  │ ← p = 0x1000                                ║
║  │ [данные] │                                             ║
║  └──────────┘                                             ║
║                                                           ║
║  realloc(p, 20);  ← "Хочу 20 байт!"                       ║
║                                                           ║
║  СТАЛО: 2 варианта                                        ║
║                                                           ║
║  Вариант A: Расширили на месте                            ║
║  ┌────────────────────┐                                   ║
║  │ 20 байт            │ ← p = 0x1000 (тот же адрес!)     ║
║  │ [данные][........] │                                   ║
║  └────────────────────┘                                   ║
║                                                           ║
║  Вариант B: Переехали (нет места рядом)                   ║
║  ┌──────────┐ (старое)                                    ║
║  │ FREE!    │ ← 0x1000 освобождено                        ║
║  └──────────┘                                             ║
║                                                           ║
║  ┌────────────────────┐ (новое)                           ║
║  │ 20 байт            │ ← p = 0x2000 (НОВЫЙ адрес!)      ║
║  │ [данные][........] │   данные скопированы             ║
║  └────────────────────┘                                   ║
║                                                           ║
║  ⚠️ ВАЖНО: адрес может измениться!                        ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**Безопасное использование:**

```c
int *arr = malloc(10 * sizeof(int));

// ❌ ОПАСНО: если вернёт NULL, arr потеряется!
arr = realloc(arr, 20 * sizeof(int));

// ✅ ПРАВИЛЬНО: используем временную переменную
int *temp = realloc(arr, 20 * sizeof(int));
if (temp != NULL) {
    arr = temp;  // Успех! Обновляем указатель
} else {
    // Ошибка! arr ещё валиден, можно освободить
    free(arr);
    return 1;
}

// Используем увеличенный массив
arr[15] = 42;

free(arr);
```

---

### 6. Динамические строки

**Задача:** прочитать строку неизвестной длины.

```c
char* read_dynamic_string() {
    int capacity = 10;  // Начальная вместимость
    int length = 0;
    char *buffer = malloc(capacity);
    
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {
        // Если буфер заполнен — увеличиваем
        if (length + 1 >= capacity) {
            capacity *= 2;  // Удваиваем!
            char *temp = realloc(buffer, capacity);
            if (!temp) {
                free(buffer);
                return NULL;
            }
            buffer = temp;
        }
        
        buffer[length++] = c;
    }
    
    buffer[length] = '\0';
    return buffer;  // Вызывающий ДОЛЖЕН free()!
}
```

**Паттерн роста:**
```
Capacity: 10 → 20 → 40 → 80 → 160 → ...
         (удвоение при заполнении)
```

---

### 7. Двумерные динамические массивы

**Метод 1: Массив указателей**

```c
int rows = 3, cols = 4;

// Выделить массив указателей на строки
int **matrix = malloc(rows * sizeof(int*));

// Выделить каждую строку отдельно
for (int i = 0; i < rows; i++) {
    matrix[i] = malloc(cols * sizeof(int));
}

// Использование
matrix[1][2] = 42;

// Освобождение (в обратном порядке!)
for (int i = 0; i < rows; i++) {
    free(matrix[i]);  // Сначала строки
}
free(matrix);  // Потом массив указателей
```

**Метод 2: Один блок** (эффективнее):

```c
int *matrix = malloc(rows * cols * sizeof(int));

// Доступ как matrix[i][j]:
#define INDEX(i, j) ((i) * cols + (j))
matrix[INDEX(1, 2)] = 42;

free(matrix);  // Одно освобождение!
```

---

### 8. Распространённые ошибки

```c
// ❌ Утечка памяти
void leak() {
    int *p = malloc(100);
    // Забыли free(p)!
}  // p исчезает, но память не освобождена!

// ❌ Double free
int *p = malloc(100);
free(p);
free(p);  // КРАШ!

// ❌ Use after free
int *p = malloc(100);
free(p);
*p = 42;  // КРАШ! Память уже не наша!

// ❌ Потерянный указатель
int *p = malloc(100);
p = malloc(200);  // Старый блок потерян! Утечка!

// ✅ Правильно
int *p = malloc(100);
if (p == NULL) {
    return 1;
}
*p = 42;
free(p);
p = NULL;  // Good practice
```

---

## 🎯 ПРОМЕЖУТОЧНАЯ ЗАДАЧА: "Dynamic String"

> *"Перед загрузкой архива переменного размера, научитесь работать с realloc."*

### Задача

Реализовать функцию `read_dynamic_string()`, которая читает строку **любой длины** из stdin, используя `realloc` для роста буфера.

**Требования:**
1. Начальная вместимость: 10 байт
2. При заполнении — удваивать размер буфера
3. Выводить сообщения о realloc
4. Корректно освобождать память

**Ожидаемый вывод:**
```
Enter text (press Enter to finish):
> This is a very long string that will trigger realloc multiple times because it exceeds initial capacity
[Realloc: 10 → 20 bytes]
[Realloc: 20 → 40 bytes]
[Realloc: 40 → 80 bytes]
[Realloc: 80 → 160 bytes]

✓ String read successfully!
Length: 108 characters
Content: "This is a very long string..."

✓ Memory freed. No leaks!
```

### Starter Code

В `starter.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* read_dynamic_string() {
    int capacity = 10;
    int length = 0;
    char *buffer = malloc(capacity);
    
    if (!buffer) return NULL;
    
    printf("Enter text (press Enter to finish):\n> ");
    
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {
        // TODO: Проверить заполнение буфера
        // TODO: Если заполнен — вызвать realloc
        // TODO: Добавить символ в буфер
    }
    
    buffer[length] = '\0';
    return buffer;
}

int main() {
    char *str = read_dynamic_string();
    
    if (!str) {
        fprintf(stderr, "✗ Memory allocation failed!\n");
        return 1;
    }
    
    printf("\n✓ String read successfully!\n");
    printf("Length: %zu characters\n", strlen(str));
    printf("Content: \"%s\"\n", str);
    
    // TODO: Освободить память!
    
    return 0;
}
```

### Проверка

```bash
cd episode-07-deep-dive
gcc -Wall -o dynamic_string artifacts/dynamic_string.c
./dynamic_string

# Или автотест:
bash tests/test_dynamic_string.sh
```

---

## 🎯 Основная миссия: "Dynamic Loader"

### Легенда

Файл `archive.dat` растёт в реальном времени. Кто-то заливает данные удалённо со скоростью 100KB/сек.

У вас 3 часа до заполнения диска.

В архиве спрятана команда остановки потока, но сначала нужно распарсить его весь.

**Формат архива:**

```
[HEADER]
  magic: "MOON" (4 байта)
  version: uint16_t
  block_count: uint16_t
  
[BLOCKS] (переменное количество)
  type: uint8_t
  size: uint32_t
  data: size байт (динамически!)
  
[INDEX]
  offset: uint32_t (для каждого блока)
  type: uint8_t
```

**Типы блоков:**
- `0x01` — TEXT
- `0x02` — BINARY
- `0x03` — COMPRESSED
- `0xFF` — **COMMAND** (команда остановки!)

**Ваша задача:**
1. Читать заголовок
2. Динамически выделять память под каждый блок
3. Найти блок типа `0xFF` (COMMAND)
4. Декодировать команду остановки
5. **Освободить всю память**

### Структуры данных

```c
typedef struct {
    char magic[4];
    uint16_t version;
    uint16_t block_count;
} Header;

typedef struct {
    uint8_t type;
    uint32_t size;
    uint8_t *data;  // Динамически выделенная память!
} Block;

typedef struct {
    uint32_t offset;
    uint8_t type;
} IndexEntry;
```

### Starter Code

В `starter.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#define TYPE_TEXT       0x01
#define TYPE_BINARY     0x02
#define TYPE_COMPRESSED 0x03
#define TYPE_COMMAND    0xFF

// TODO: Определите структуры

// Читает заголовок
Header* read_header(FILE *f) {
    Header *h = malloc(sizeof(Header));
    if (!h) return NULL;
    
    fread(h, sizeof(Header), 1, f);
    
    // Валидация magic
    if (memcmp(h->magic, "MOON", 4) != 0) {
        free(h);
        return NULL;
    }
    
    return h;
}

// Читает один блок (с malloc для data!)
Block* read_block(FILE *f) {
    // TODO: 
    // 1. malloc для Block
    // 2. Прочитать type и size
    // 3. malloc для data (размер = size)
    // 4. Прочитать data
    // 5. Вернуть Block
}

// Освобождает блок
void free_block(Block *block) {
    if (block) {
        free(block->data);  // Сначала вложенные данные
        free(block);         // Потом структуру
    }
}

int main(int argc, char *argv[]) {
    // TODO:
    // 1. Открыть файл
    // 2. Прочитать заголовок
    // 3. Выделить массив блоков (malloc)
    // 4. Загрузить каждый блок
    // 5. Найти блок TYPE_COMMAND
    // 6. Вывести команду остановки
    // 7. Освободить всё (free)
    
    return 0;
}
```

---

## 🎓 КОНТРОЛЬНЫЕ ВОПРОСЫ

### Базовое понимание

1. **Stack vs Heap:**
   - В чём главное отличие Stack от Heap?
   - Почему Stack быстрее, но ограничен?
   - Когда выбрать Stack, а когда Heap?

2. **malloc:**
   - Что возвращает malloc при ошибке?
   - Почему ОБЯЗАТЕЛЬНО проверять на NULL?
   - Инициализирована ли память после malloc?

3. **Метафора склада:**
   - Объясните malloc как "аренду ячейки"
   - Что значит "вернуть ключ" (free)?
   - Что произойдёт, если потерять ключ?

### Практическое применение

4. **Lifecycle:**
   - Опишите полный lifecycle динамической памяти
   - Что произойдёт после free(p), если разыменовать *p?
   - Зачем обнулять указатель после free?

5. **realloc:**
   - Может ли realloc изменить адрес?
   - Почему опасно: `arr = realloc(arr, new_size)`?
   - Как безопасно использовать realloc?

6. **calloc vs malloc:**
   - В чём разница?
   - Когда использовать calloc?
   - Что быстрее и почему?

### Анализ кода

7. **Найдите утечку:**
```c
void process() {
    int *data = malloc(100 * sizeof(int));
    for (int i = 0; i < 100; i++) {
        data[i] = i * 2;
    }
    printf("Sum: %d\n", data[0] + data[99]);
}  // Что не так?
```

8. **Найдите ошибку:**
```c
char* get_string() {
    char *str = malloc(10);
    strcpy(str, "Hello");
    free(str);
    return str;  // Проблема?
}
```

9. **Double free:**
```c
int *p = malloc(100);
free(p);
free(p);  // Что произойдёт?
```

### Сюжет

10. **Динамический рост файла:**
    - Почему статический массив не помог?
    - Как malloc решает проблему растущего файла?
    - Что произойдёт, если забыть free при 1000 блоков?

11. **Метафоры:**
    - Объясните Stack vs Heap через метафору квартиры и склада
    - Как метафора "аренды" помогает понять malloc/free?

### Продвинутые вопросы

12. **Двумерные массивы:**
    - Сравните два способа создания динамической матрицы
    - Какой способ эффективнее и почему?
    - Как правильно освободить матрицу из указателей?

13. **Оптимизация:**
    - Почему realloc удваивает размер, а не увеличивает на 1?
    - Что такое amortized O(1)?

14. **Утечки:**
    - Что такое memory leak?
    - Как найти утечки? (preview Episode 08)

15. **Задача:**
```c
// Реализуйте динамический массив, который растёт автоматически
typedef struct {
    int *data;
    int size;
    int capacity;
} DynamicArray;

DynamicArray* create_array();
void push(DynamicArray *arr, int value);
void destroy_array(DynamicArray *arr);
```

---

## ✅ Проверка

```bash
# Промежуточная задача
gcc -Wall -o dynamic_string artifacts/dynamic_string.c
echo "Very long test string here" | ./dynamic_string

# Основная задача
make
./dynamic_loader archive.dat

# Автотесты
make test
```

**Критерии успеха:**
- ✅ Промежуточная задача работает (realloc срабатывает)
- ✅ Все блоки загружены динамически
- ✅ Команда остановки найдена
- ✅ Вся память освобождена (нет утечек)
- ✅ Valgrind показывает: "All heap blocks were freed"

---

## 🎬 DEBRIEFING

```
╔═══════════════════════════════════════════════════════════╗
║      🎯 АРХИВ ЗАГРУЖЕН! ПОТОК ОСТАНОВЛЕН!                 ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  ✓ Файл прочитан: 47.3 MB (динамический размер)          ║
║  ✓ Блоков загружено: 2,847                               ║
║  ✓ Память выделена: 49,823,744 байт                      ║
║  ✓ Индекс построен: 2,847 записей                        ║
║  ✓ Блок COMMAND найден: offset 0x2F4A8B0                 ║
║                                                           ║
║  [!] КОМАНДА ОСТАНОВКИ ДЕКОДИРОВАНА:                     ║
║                                                           ║
║     STOP_STREAM 185.220.101.47:8443                      ║
║     AUTH_TOKEN: 4f3a2c1b9e8d7a6f                         ║
║                                                           ║
║  ✓ Отправлено на удалённый сервер                        ║
║  ✓ Поток остановлен!                                     ║
║  ✓ Память освобождена: 100% (утечек нет)                 ║
║                                                           ║
║  📍 Последнее сообщение от V.:                           ║
║     "Динамическая память освоена.                        ║
║      Но помни: с большой силой приходит большая          ║
║      ответственность. Каждый malloc — обещание.          ║
║      Каждый free — выполнение обещания.                  ║
║                                                           ║
║      Episode 08 — последний экзамен:                     ║
║      Научись находить нарушенные обещания. — V."         ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

### 📊 Статистика:
- ⏱️ Среднее время: 90-120 минут (с промежуточной задачей)
- 🎓 Новые навыки: **malloc**, **free**, **realloc**, **heap management**
- 🏆 Достижение: **"Heap Master"**

### 🔓 Skill Unlocked: **Dynamic Memory Mastery**
```
[████████████████████] 100%

Вы освоили:
✓ Выделение памяти (malloc, calloc)
✓ Изменение размера (realloc)
✓ Освобождение памяти (free)
✓ Работу с динамическими структурами
✓ Двумерные динамические массивы
✓ Lifecycle управления памятью
✓ Работу с файлами неизвестного размера
```

---

## 🎨 Easter Eggs

🔍 **Скрытые детали:**
- Heap-аллокатор в glibc использует алгоритм ptmalloc2
- Адрес 0x600000000000 — область mmap для больших аллокаций (64-bit)
- Удвоение capacity в realloc — amortized O(1) сложность
- Команда STOP_STREAM — реальный паттерн управления потоками

🎬 **Отсылки:**
- Растущий файл — атака "disk fill" из real-world hacking
- Метафора склада — из книги "Expert C Programming"
- malloc/free — прямой аналог new/delete в C++

---

## 🎁 Артефакт

После выполнения вы получите:
- **Навык**: dynamic memory management на уровне эксперта
- **Инструмент**: `dynamic_loader` — загрузчик файлов любого размера
- **Понимание**: Stack vs Heap, lifecycle памяти
- **Готовность**: к Episode 08 (поиск утечек)

---

## 🔗 Навигация

- [← Episode 06: Pointer Game](../episode-06-pointer-game/README.md)
- [→ Episode 08: Fragmentation](../episode-08-fragmentation/README.md)
- [📋 Season 2: Memory & Pointers](../README.md)
- [🏠 Главная страница](../../README.md)

---

> *"With great power comes great responsibility. Every malloc is a promise. Every free is keeping that promise."* — V.

```
// DYNAMIC MEMORY MASTERED
// HEAP ALLOCATED: 49,823,744 BYTES
// ALL FREED: NO LEAKS
// STREAM STOPPED
// READY FOR THE FINAL TEST
//
// TIME: 21:47
// DEADLINE: Episode 08 awaits
```
