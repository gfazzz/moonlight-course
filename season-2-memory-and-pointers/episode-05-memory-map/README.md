# Episode 05: "Memory Map" 🗺️

> *"Arrays are the foundation. Master them, and memory becomes your ally."*

---

## 🎬 BRIEFING

```
╔══════════════════════════════════════════════════════════╗
║  ЛОКАЦИЯ: Безопасная квартира, Таганка, Москва          ║
║  ВРЕМЯ:   08:47, среда, 1 октября                       ║
║  СТАТУС:  🔴 COMPROMISED — EMERGENCY PROTOCOL            ║
╚══════════════════════════════════════════════════════════╝
```

**ВРЕМЕННАЯ ЛИНИЯ:**
```
06:30  ⏰ Просыпаетесь после короткого сна
06:45  📧 Проверяете зашифрованный канал
07:15  📦 Новый файл от V.: memory_dump.dat
08:00  ☕ Анализ структуры файла начат
08:23  📞 Звонок Дмитрию Орлову (консультация по memory forensics)
08:47  🎯 Обнаружена сложная структура данных
09:12  🚨 КРИТИЧЕСКОЕ ОТКРЫТИЕ: GPS-координаты вашей квартиры!
09:13  ⚠️  SMS от Z.: "6 часов до эвакуации"
10:42  📞 Звонок от Анны Ковалёвой (forensics specialist, помощь)
13:45  ✅ Все блоки памяти распарсены
15:00  🎯 CLIFFHANGER: Новый файл pointers.dat → Episode 06
```

---

## 🎭 ПЕРСОНАЖИ ЭПИЗОДА

**Появляются в этом эпизоде:**

🔄 **Виктор Петров** (V.)
- **Роль:** Отправитель файла memory_dump.dat
- **Момент:** 07:15 — файл приходит на защищённый канал
- **Связь:** Продолжает помогать издалека, оставляя подсказки

🔄 **Дмитрий Орлов** — Senior Embedded Engineer @ Аэрофлот
- **Роль:** Консультант по memory forensics
- **Момент:** 08:23 — вы звоните ему за помощью с парсингом
- **Реплика:** *"Дампы памяти — моя специальность. В авионике мы парсим их каждый день. Покажи hex."*
- **Помощь:** Объясняет структуру бинарных данных, предлагает использовать sizeof

🆕 **Анна Ковалёва** — Forensics Specialist, бывшая коллега из ФСБ
- **ВПЕРВЫЕ ПОЯВЛЯЕТСЯ!**
- **Момент:** 10:42 — звонит сама после вашего обращения через старые каналы
- **Реплика:** *"Слышала, у тебя проблемы с дампом. Я специализируюсь на memory analysis. Могу помочь — но быстро, мне нужно уходить через 20 минут."*
- **Личность:** 32 года, работала с вами 4 года назад в отделе "К", перешла в частное агентство
- **Помощь:** Объясняет метафору "склад с контейнерами", подсказывает про checksum

⚔️ **Полковник Крылов** (агенты Z.)
- **Роль:** Антагонист, отправитель SMS-угрозы
- **Момент:** 09:13 — SMS "Мы знаем, где ты"
- **Статус:** Активно преследует вас

> **Expanded Cast в действии:** Дмитрий и Виктор возвращаются из Season 1, Анна появляется впервые. Все три союзника помогают в разное время, создавая ощущение команды.

### 🔐 СИТУАЦИЯ — КРИТИЧЕСКАЯ

После расшифровки сообщения Виктора и создания вашего первого инструмента (`moonlight-decoder`), вы думали, что самое сложное позади.

Но в 07:15 утра на защищённый канал приходит новый файл — `memory_dump.dat`.

**Метаданные файла:**
```
Имя:     memory_dump.dat
Размер:  2.4 KB
Тип:     Binary dump
Отправитель: V. (зашифрованный канал)
Сообщение: "Это не просто данные. Это карта. Парси быстро."
```

Вы открываете файл в hex-редакторе:

```
Offset    Hex                                            ASCII
--------  ---------------------------------------------  ----------------
00000000  FF FF 01 05 48 65 6C 6C 6F 48 FF FF FF 02 08  ..▓.Hello▓..▓..
00000010  42 8E 5C 40 42 17 13 42 AA FF 03 04 65 12 34  B.\@B..B▓.▓.e.4
00000020  56 BC FF FF FF 01 0A 53 65 63 72 65 74 4D 73  V▓...▓.SecretMs
00000030  67 4D FF FF 02 08 41 A3 5D 40 43 8F 21 42 C1  g▓..▓.A.]@C.!B.
```

**Что вы понимаете:**
- Данные **структурированы**, но хаотично расположены
- Между блоками валидных данных есть "**мусор**" (байты `FF`)
- Каждый блок начинается с **типом** и **размером**
- Это похоже на **дамп памяти** какой-то программы

Виктор оставил подсказку: *"Карта памяти откроет первую дверь"*.

---

### 🚨 ТВИСТ — ОБНАРУЖЕНИЕ В 09:12

После парсинга первых блоков вы замираете. В блоке COORDINATES находите:

```
Координаты #1: 55.7413° N, 37.6253° E
Координаты #2: 55.7415° N, 37.6250° E
Координаты #3: 55.7410° N, 37.6255° E
```

Вы открываете карту. Эти координаты образуют **треугольник с радиусом 50 метров**.

**Центр треугольника:** улица Таганская, дом 17, квартира 42.

**Ваша квартира.**

Вы бросаетесь к окну. На улице — обычное утро. Люди идут на работу. Ничего подозрительного.

Но теперь вы знаете: **кто-то знает, где вы**.

Телефон вибрирует. SMS с неизвестного номера:

```
╔═══════════════════════════════════════════════════════════╗
║  От: +7-XXX-XXX-XXXX                                      ║
║  Время: 09:13                                             ║
║                                                           ║
║  "Мы знаем, где ты. Дамп памяти — это не просто данные.  ║
║   Это доказательства. Найди их ВСЕ за 6 часов.           ║
║                                                           ║
║   Или мы найдём тебя первыми.                            ║
║                                                           ║
║   Не пытайся бежать. Следим. — Z."                       ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

Руки трясутся. Адреналин бьёт в виски.

**У вас есть 6 часов, чтобы:**
1. ✅ Распарсить ВСЕ блоки памяти
2. ✅ Найти скрытые доказательства
3. ✅ Подготовиться к эвакуации
4. ✅ Понять, кто такой Z.

**Время пошло.**

**08:20** — Вы пытаетесь открыть файл в текстовом редакторе. Мусор. Hex-редакторе — чуть лучше, но как это парсить?

Вам нужно вспомнить основы работы с массивами и бинарными данными...

---

## 📚 THEORY 1: Массивы — основа работы с данными

### 💡 Зачем это нужно?

Дамп памяти — это массив байтов. Чтобы его распарсить, нужно понять, как в C работают массивы.

**Массивы используются везде:**
- 📦 **Протоколы**: Парсинг сетевых пакетов (TCP/IP, HTTP)
- 🔐 **Криптография**: Работа с ключами, шифртекстами
- 💾 **Файлы**: Чтение/запись бинарных форматов
- 🎮 **Графика**: Пиксели, текстуры
- 🤖 **AI**: Матрицы весов

**Ваша задача:** распарсить бинарный дамп памяти — это тоже массив байтов!

### 1. Массивы — упорядоченные данные

**Массив** — это последовательность элементов одного типа, расположенных в памяти **подряд** (contiguous).

```c
// Объявление и инициализация
int numbers[5] = {10, 20, 30, 40, 50};

// Доступ к элементам (индексация с 0)
int first = numbers[0];   // 10
int last = numbers[4];    // 50

// Размер массива
int size = sizeof(numbers) / sizeof(numbers[0]);  // 5
```

**📊 Метафора: СКЛАД С КОНТЕЙНЕРАМИ**

```
╔════════════════════════════════════════════════════════╗
║  СКЛАД ПАМЯТИ — МАССИВ numbers[5]                     ║
╠════════════════════════════════════════════════════════╣
║                                                        ║
║  ┌──────┬──────┬──────┬──────┬──────┐                ║
║  │  10  │  20  │  30  │  40  │  50  │ ← Контейнеры   ║
║  └──────┴──────┴──────┴──────┴──────┘                ║
║    [0]    [1]    [2]    [3]    [4]   ← Номера        ║
║     ↑                                                  ║
║     numbers[0] — первый контейнер!                    ║
║                                                        ║
║  🚛 Грузчик (CPU):                                    ║
║  "Дайте мне контейнер №2" → numbers[2] → достаёт 30  ║
║                                                        ║
║  Правила склада:                                      ║
║  ✅ Все контейнеры одинакового типа (int)             ║
║  ✅ Стоят подряд (contiguous memory)                  ║
║  ✅ Нумерация с 0 (первый = [0])                      ║
║  ⚠️  Нельзя запросить [5] — склад кончился!          ║
║                                                        ║
╚════════════════════════════════════════════════════════╝
```

**📊 Визуализация в памяти:**
```
Адрес     Индекс  Значение
┌────────┬───────┬─────────┐
│ 0x1000 │ [0]   │   10    │  ← numbers[0]
│ 0x1004 │ [1]   │   20    │  ← numbers[1]
│ 0x1008 │ [2]   │   30    │  ← numbers[2]
│ 0x100C │ [3]   │   40    │  ← numbers[3]
│ 0x1010 │ [4]   │   50    │  ← numbers[4]
└────────┴───────┴─────────┘
     ↑ Каждый int занимает 4 байта (обычно)
```

**🔑 Важно:**
- ✅ Индексация начинается с **0** (первый элемент — `arr[0]`)
- ✅ Размер массива **фиксирован** при объявлении
- ⚠️ Выход за границы массива — **undefined behavior (UB)**! Может краш, может молча перезаписать память

---

## 🔍 КОНТРОЛЬНЫЕ ВОПРОСЫ (THEORY 1)

**Проверьте понимание массивов:**

1. **Базовое:** Почему первый элемент массива — `arr[0]`, а не `arr[1]`?
2. **sizeof:** Дан массив `int numbers[20]`. Чему равно `sizeof(numbers)`?
3. **Границы:** Что произойдёт при обращении к `data[10]`, если массив `int data[10]`?
4. **Формула:** Объясните формулу `sizeof(arr) / sizeof(arr[0])` для получения длины массива.

<details>
<summary>💡 Показать ответы</summary>

1. Индекс = смещение от начала. Первый элемент = +0 байт.
2. 80 байт (20 элементов × 4 байта на int)
3. **Ошибка!** Выход за границы. Валидные индексы: 0-9.
4. Общий размер массива / размер одного элемента = количество элементов.

</details>

---

**08:23** — Вы звоните **Дмитрию Орлову**. Embedded engineer, работает с дампами памяти каждый день.

```
╔════════════════════════════════════════════════════════╗
║  📞 ВЫЗОВ: Дмитрий Орлов                              ║
║  Статус: Senior Embedded Engineer @ Аэрофлот          ║
╚════════════════════════════════════════════════════════╝
```

— **Дима, срочно. Дамп памяти 2.4KB. Структурирован, но формат непонятен.**  
— *Окей. Hex dump покажи.*

Вы пересылаете первые 100 байт.

— *Вижу. Кастомный формат. Блоки с FF-маркерами. Тип, размер, payload. Парси как массив байтов. И помни про строки — они заканчиваются нулём.*  
— **Строки?**  
— *Ага. В C строка = массив char с '\0' в конце. Без '\0' — не строка. Функции типа printf не остановятся, будет мусор.*

Дмитрий отправляет пример кода.

— *sizeof используй для расчётов. Удачи. Если от Viktor — значит важно.*

**08:35** — Теперь понятно: в дампе есть строки. Нужно разобраться, как они работают...

---

## 📚 THEORY 2: Строки в C

### Строки — массивы символов с '\0'

**В C нет отдельного типа "строка"!** Строка — это массив `char`, заканчивающийся **нулевым символом** `'\0'` (null terminator).

```c
// Три способа создания строки
char str1[] = "Hello";                    // Автоматический размер (6 байт с '\0')
char str2[10] = "World";                  // Явный размер (остальное заполнено '\0')
char str3[] = {'H', 'i', '\0'};          // Посимвольно

// ❌ ОШИБКА: нет завершающего '\0'
char bad[] = {'B', 'a', 'd'};            // Не строка! Функции вроде printf не остановятся!
```

**📊 Метафора: ПОЕЗД С ВАГОНАМИ**

```
╔════════════════════════════════════════════════════════╗
║  СТРОКА КАК ПОЕЗД: "Hello"                             ║
╠════════════════════════════════════════════════════════╝
║                                                        
║  🚂┌───┬───┬───┬───┬───┬────┐🛑                      
║    │ H │ e │ l │ l │ o │ \0 │  ← СТОП-сигнал!       
║    └───┴───┴───┴───┴───┴────┘                        
║    [0] [1] [2] [3] [4] [5]                           
║                         ↑                             
║                    Нулевой терминатор =               
║                    красный сигнал светофора:          
║                    "СТРОКА КОНЧИЛАСЬ!"                
║                                                        
║  Без '\0' поезд не остановится! 💥                    
╚════════════════════════════════════════════════════════
```

**📊 Визуализация в памяти:**
```
str1: "Hello"
┌───┬───┬───┬───┬───┬────┐
│ H │ e │ l │ l │ o │ \0 │
└───┴───┴───┴───┴───┴────┘
 [0] [1] [2] [3] [4] [5]
                       ↑
              Нулевой терминатор!
              Сигнал "строка кончилась"

str2: "World" (размер 10)
┌───┬───┬───┬───┬───┬────┬────┬────┬────┬────┐
│ W │ o │ r │ l │ d │ \0 │ \0 │ \0 │ \0 │ \0 │
└───┴───┴───┴───┴───┴────┴────┴────┴────┴────┘
 [0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
                     ↑
            Остальное — нули
```

**⚠️ Критически важно:**
```c
char name[5] = "Alice";  // ❌ ОШИБКА! "Alice" = 5 букв + '\0' = 6 байт!
char name[6] = "Alice";  // ✅ Правильно
```

---

### 3. Стандартная библиотека `string.h`

```c
#include <string.h>

// Длина строки (без '\0')
size_t len = strlen("Hello");  // 5

// Копирование
char dest[20];
strcpy(dest, "Copy this");

// Сравнение (0 = равны, <0 или >0 = различны)
if (strcmp(str1, str2) == 0) {
    printf("Strings are equal\n");
}

// Конкатенация (добавление в конец)
strcat(dest, " more text");
```

**⚠️ Опасность**: `strcpy` и `strcat` не проверяют размер буфера → переполнение!

**Безопасные версии**:
```c
strncpy(dest, source, sizeof(dest) - 1);
dest[sizeof(dest) - 1] = '\0';  // Гарантируем завершение

strncat(dest, source, sizeof(dest) - strlen(dest) - 1);
```

---

## 🔍 КОНТРОЛЬНЫЕ ВОПРОСЫ (THEORY 2)

**Проверьте понимание строк:**

5. **Размер:** Сколько байт занимает строка `"Hello"`? 5 или 6? Почему?
6. **Ошибка:** Что произойдёт при `char name[5] = "Alice"`?
7. **Функции:** В чём опасность `strcpy()`? Как её избежать?
8. **Сравнение:** Почему `if (str1 == str2)` НЕ сравнивает строки? Что использовать?

<details>
<summary>💡 Показать ответы</summary>

5. **6 байт** — 5 символов + нулевой терминатор '\0'
6. **Переполнение буфера!** "Alice" = 6 байт, а массив только 5
7. `strcpy` не проверяет размер буфера → использовать `strncpy` с проверкой размера
8. `==` сравнивает адреса, не содержимое! Использовать `strcmp(str1, str2) == 0`

</details>

---

**10:42** — Телефон звонит. Неизвестный номер. Вы берёте трубку.

— *Слышала, у тебя проблемы с дампом памяти.*

Женский голос. Знакомый, но вы не можете вспомнить...

— **Кто это?**  
— *Анна. Анна Ковалёва. Мы работали вместе четыре года назад. Отдел "К".*

**Анна Ковалёва.** Forensics specialist. Вы помните — она уволилась два года назад, перешла в частное агентство.

— *Я специализируюсь на memory analysis и data recovery. Могу помочь — но быстро, мне нужно уходить через 20 минут.*  
— **Как ты узнала?**  
— *Старые каналы всё ещё работают. Покажи hex dump.*

Вы отправляете структуру блока.

— *Вижу checksum в конце каждого блока. XOR всех байтов payload. Проверяй целостность — если Z. подменил данные, checksum не сойдётся. И смотри на многомерные массивы для координат.*  
— **Координат?**  
— *GPS обычно хранят как массив float[3][2]: широта/долгота для нескольких точек. Парси аккуратно.*

Пауза.

— *Будь осторожен. Если это связано с Viktor... За тобой следят. Удачи.*

Звонок обрывается.

**10:45** — Теперь ясно: в дампе есть координаты. Многомерные массивы. Нужно разобраться...

---

## 📚 THEORY 3: sizeof, многомерные массивы и ошибки

### 1. Многомерные массивы

```c
// Двумерный массив (матрица)
int matrix[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// Доступ к элементу
int value = matrix[1][2];  // 7

// Обход всех элементов
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 4; j++) {
        printf("%d ", matrix[i][j]);
    }
    printf("\n");
}
```

**📊 Визуализация:**
```
matrix[3][4]:
     [0]  [1]  [2]  [3]
[0]   1    2    3    4
[1]   5    6    7    8  ← matrix[1][2] = 7
[2]   9   10   11   12
```

---

### 5. Массивы и функции

```c
// Массив в функцию передаётся по указателю (без копирования!)
void process_array(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] *= 2;  // Изменения видны снаружи!
    }
}

int main() {
    int data[5] = {1, 2, 3, 4, 5};
    process_array(data, 5);  // data изменится!
    // data теперь: {2, 4, 6, 8, 10}
}
```

---

### 6. sizeof — узнать размер

**`sizeof`** — оператор, который возвращает размер типа или переменной **в байтах**.

```c
int x = 5;
printf("int занимает %zu байт\n", sizeof(int));      // 4
printf("char занимает %zu байт\n", sizeof(char));    // 1
printf("double занимает %zu байт\n", sizeof(double)); // 8
printf("x занимает %zu байт\n", sizeof(x));          // 4
```

**Зачем это нужно?** Для вычисления длины массива!

```c
int numbers[] = {10, 20, 30, 40, 50};

// Общий размер массива в байтах
int total_bytes = sizeof(numbers);  // 20 (5 элементов × 4 байта)

// Размер одного элемента
int element_bytes = sizeof(numbers[0]);  // 4

// Количество элементов
int length = sizeof(numbers) / sizeof(numbers[0]);  // 5
printf("Длина массива: %d\n", length);
```

**📊 Визуализация sizeof:**
```
╔════════════════════════════════════════╗
║  ЛИНЕЙКА ПАМЯТИ — sizeof               ║
╠════════════════════════════════════════╣
║                                        ║
║  int numbers[5] = {10, 20, 30, 40, 50};║
║                                        ║
║  [████][████][████][████][████]        ║
║   4байт 4байт 4байт 4байт 4байт        ║
║  ├──────────────────────────────┤      ║
║         sizeof(numbers) = 20           ║
║                                        ║
║  [████]  sizeof(numbers[0]) = 4        ║
║                                        ║
║  Длина = 20 / 4 = 5 элементов          ║
║                                        ║
╚════════════════════════════════════════╝
```

---

### 7. Распространённые ошибки

```c
// ❌ Выход за границы
int arr[5];
arr[5] = 100;  // Ошибка! Индексы: 0-4

// ❌ Неинициализированный массив
int data[100];
printf("%d", data[0]);  // Мусор в памяти!

// ❌ Переполнение буфера
char small[5];
strcpy(small, "This is too long");  // Переполнение!

// ✅ Правильно
char small[20];
strncpy(small, "Safe copy", sizeof(small) - 1);
small[sizeof(small) - 1] = '\0';
```

---

## 🔍 КОНТРОЛЬНЫЕ ВОПРОСЫ (THEORY 3)

**Проверьте понимание:**

9. **Многомерный массив:** Как получить значение из `float coords[3][2]` для точки 1, долготы (индекс 1)?
10. **sizeof:** Чему равно `sizeof(int arr[10])`?
11. **Функции:** Почему нельзя возвратить локальный массив из функции?
12. **Ошибки:** В чём опасность неинициализированного массива?

<details>
<summary>💡 Показать ответы</summary>

9. `coords[1][1]` — строка 1, столбец 1
10. 40 байт (10 элементов × 4 байта на int)
11. Локальный массив лежит в stack → уничтожается после выхода из функции!
12. Мусор в памяти — можно прочитать что угодно (остатки от других переменных)

</details>

---

**11:15** — Вы изучили теорию. Дмитрий и Анна дали подсказки. Теперь нужна практика перед основной миссией.

Создаёте тестовую программу для анализа массива байтов — разминка перед дампом памяти...

---

## 🎯 ПРОМЕЖУТОЧНАЯ ЗАДАЧА: "Array Analyzer"

> *"Перед тем как парсить дамп памяти, нужно освоить базовые операции с массивами."*

### Задача

Создать программу `array_analyzer.c`, которая анализирует массив байтов:

```c
unsigned char data[] = {0x42, 0x1A, 0xFF, 0x00, 0x7E};
```

**Программа должна вывести:**
```
=== BYTE ARRAY ANALYSIS ===
Array size: 5 bytes

Byte 0: 0x42 (66 decimal)
Byte 1: 0x1A (26 decimal)
Byte 2: 0xFF (255 decimal)
Byte 3: 0x00 (0 decimal)
Byte 4: 0x7E (126 decimal)

Statistics:
Sum of all bytes: 473
Min byte: 0x00 (0)
Max byte: 0xFF (255)
Average: 94.6

Index of max: 2
Index of min: 3
```

### Требования

1. Вывести каждый байт в формате hex и decimal
2. Вычислить сумму всех байтов
3. Найти минимум и максимум
4. Найти индексы min/max
5. Вычислить среднее

### Starter Code

В файле `starter.c` найдёте заготовку:

```c
#include <stdio.h>

int main() {
    unsigned char data[] = {0x42, 0x1A, 0xFF, 0x00, 0x7E};
    int size = sizeof(data) / sizeof(data[0]);
    
    printf("=== BYTE ARRAY ANALYSIS ===\n");
    printf("Array size: %d bytes\n\n", size);
    
    // TODO: Вывести каждый байт
    
    // TODO: Вычислить статистику
    
    return 0;
}
```

### Подсказки

<details>
<summary>Как найти максимум в массиве?</summary>

```c
unsigned char max = data[0];  // Предполагаем, что первый — максимальный
int max_index = 0;

for (int i = 1; i < size; i++) {
    if (data[i] > max) {
        max = data[i];
        max_index = i;
    }
}
```
</details>

<details>
<summary>Как вычислить сумму?</summary>

```c
int sum = 0;
for (int i = 0; i < size; i++) {
    sum += data[i];
}
printf("Sum: %d\n", sum);
```
</details>

### Проверка

```bash
gcc -Wall -o array_analyzer artifacts/array_analyzer.c
./array_analyzer
```

**Критерий успеха:** вывод совпадает с примером выше.

---

**12:30** — Промежуточная задача выполнена. Array analyzer работает. Вы понимаете массивы байтов.

```bash
$ ./array_analyzer
=== BYTE ARRAY ANALYSIS ===
Array size: 5 bytes
Min: 0x00, Max: 0xFF, Sum: 337, Average: 67.40
✓ Ready for memory dump parsing
```

Время вернуться к дампу от Viktor. Настоящая работа начинается...

Вы открываете `memory_dump.dat`. 2.4 KB бинарных данных. Структурированные блоки. GPS координаты. Временные метки. И что-то ещё...

**Deadline:** 6 часов до эвакуации. Осталось 3 часа 15 минут.

---

## 🎯 Основная миссия: "Карта памяти"

### Легенда

Файл `memory_dump.dat` содержит критически важные данные операции MOONLIGHT. Вы должны распарсить ВСЕ блоки и найти скрытые координаты.

Файл содержит **структуры данных** переменной длины:
- Каждая структура начинается с **заголовка** (тип и размер)
- Данные могут быть: координаты, имена файлов, временные метки
- Между структурами есть "мусор" — случайные байты для маскировки

**Ваша задача**: создать `memory_mapper` — программу, которая:
1. Читает дамп памяти
2. Находит все валидные структуры данных
3. Извлекает и выводит информацию в читаемом виде
4. Строит "карту памяти" — визуализацию расположения данных
5. **Находит GPS-координаты и доказательства**

---

### Формат данных

**Структура записи**:
```
[TYPE (1 байт)] [SIZE (1 байт)] [DATA (SIZE байт)] [CHECKSUM (1 байт)]
```

**Типы данных**:
- `0x01` — строка (имя файла)
- `0x02` — координаты (широта, долгота — по 4 байта каждая, float)
- `0x03` — временная метка (UNIX timestamp — 4 байта, uint32_t)
- `0xFF` — маркер мусора (игнорировать до следующего валидного типа)

**Checksum** — простая контрольная сумма: XOR всех байт DATA.

---

### Пример дампа

```
FF FF 01 05 48 65 6C 6C 6F 48    // Мусор + строка "Hello"
FF FF FF 02 08 [float] [float] CS // Мусор + координаты
03 04 [timestamp] CS               // Временная метка
```

---

### Технические требования

**Входные данные**: файл `memory_dump.dat` (бинарный)

**Выходные данные** (stdout):
```
=== MEMORY MAP ===
⏰ DEADLINE: 6 hours remaining

[0x0000] GARBAGE (2 bytes)
[0x0002] STRING (5 bytes): "Hello"
[0x0009] GARBAGE (3 bytes)
[0x000C] COORDINATES (8 bytes): 55.7413° N, 37.6253° E ⚠️  YOUR LOCATION!
[0x0016] TIMESTAMP (4 bytes): 2024-10-01 08:00:00 UTC
[0x001E] STRING (10 bytes): "Evidence_Z"
[0x002A] COORDINATES (8 bytes): 55.9000° N, 37.8000° E

Total structures found: 5
Total garbage bytes: 5
GPS coordinates detected: 3
⚠️  WARNING: Your location is compromised!

CRITICAL EVIDENCE FOUND:
→ "Evidence_Z" - location: 55.9000° N, 37.8000° E
→ Evacuation recommended within 6 hours
```

**Функционал**:
1. Чтение бинарного файла в массив байтов
2. Парсинг структур данных
3. Проверка checksum для валидности
4. Конвертация бинарных данных в читаемый формат
5. Вывод карты памяти с адресами
6. **Обнаружение GPS-координат и предупреждение**

---

## 📝 Задание

### Starter Code

Файл `starter.c` содержит заготовку:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define MAX_DUMP_SIZE 4096

// Типы структур
#define TYPE_STRING 0x01
#define TYPE_COORDS 0x02
#define TYPE_TIMESTAMP 0x03
#define TYPE_GARBAGE 0xFF

// TODO: Реализуйте функции

// Вычисление checksum (XOR всех байт)
uint8_t calculate_checksum(uint8_t *data, int size) {
    // ваш код здесь
}

// Парсинг строки
void parse_string(uint8_t *data, int size) {
    // ваш код здесь
}

// Парсинг координат (два float)
void parse_coordinates(uint8_t *data, int size) {
    // ваш код здесь
}

// Парсинг временной метки
void parse_timestamp(uint8_t *data, int size) {
    // ваш код здесь
}

// Конвертация UNIX timestamp в читаемый формат
void format_timestamp(uint32_t timestamp, char *buffer) {
    // ваш код здесь
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <memory_dump.dat>\n", argv[0]);
        return 1;
    }

    // TODO: 
    // 1. Открыть файл
    // 2. Прочитать в массив байтов
    // 3. Пройти по массиву, распознавая структуры
    // 4. Вывести карту памяти

    return 0;
}
```

---

## 📝 Структура эпизода

```
episode-05-memory-map/
├── README.md           ← Вы здесь
├── mission.md
├── starter.c           ← Шаблон с примерами функций
├── artifacts/
│   ├── array_analyzer.c     ← Промежуточная задача
│   └── memory_mapper.c      ← Основная задача
├── solution/
│   ├── array_analyzer_solution.c
│   ├── memory_mapper_solution.c
│   └── generate_dump.c
└── tests/
    ├── test_array_analyzer.sh
    └── test.sh
```

### 💡 Как работать:

1. **Промежуточная задача** (20-30 минут):
   - Создайте `artifacts/array_analyzer.c`
   - Реализуйте анализ массива байтов
   - Проверьте: `gcc -Wall -o array_analyzer artifacts/array_analyzer.c && ./array_analyzer`

2. **Основная задача** (60-90 минут):
   - Изучите `starter.c` — там заготовки функций с TODO
   - Создайте файл `artifacts/memory_mapper.c`
   - Реализуйте функции для парсинга разных типов данных
   - Скомпилируйте: `gcc -Wall -o memory_mapper artifacts/memory_mapper.c`
   - Запустите: `./memory_mapper memory_dump.dat`

---

### Подсказки для memory_mapper

1. **Чтение бинарного файла**:
```c
FILE *f = fopen(filename, "rb");
uint8_t buffer[MAX_DUMP_SIZE];
size_t bytes_read = fread(buffer, 1, MAX_DUMP_SIZE, f);
```

2. **Конвертация байтов в float**:
```c
float value;
memcpy(&value, &buffer[offset], sizeof(float));
```

3. **Конвертация байтов в uint32_t**:
```c
uint32_t timestamp;
memcpy(&timestamp, &buffer[offset], sizeof(uint32_t));
```

4. **Форматирование времени**:
```c
#include <time.h>
time_t t = (time_t)timestamp;
struct tm *tm_info = gmtime(&t);
strftime(buffer, 26, "%Y-%m-%d %H:%M:%S UTC", tm_info);
```

5. **Проверка GPS-координат**:
```c
// Ваша квартира: 55.7413° N, 37.6253° E
if (latitude >= 55.74 && latitude <= 55.75 &&
    longitude >= 37.62 && longitude <= 37.63) {
    printf("⚠️  YOUR LOCATION!\n");
}
```

---

## ✅ Проверка

```bash
# Сборка промежуточной задачи
gcc -Wall -o array_analyzer artifacts/array_analyzer.c
./array_analyzer

# Сборка основной задачи
make

# Тестирование
make test

# Или вручную
./memory_mapper memory_dump.dat
```

**Критерии успеха**:
- ✅ Промежуточная задача выполнена (array_analyzer)
- ✅ Все структуры данных распознаны правильно
- ✅ Checksum проверяется для каждой структуры
- ✅ Garbage-байты корректно пропускаются
- ✅ GPS-координаты обнаружены и выведено предупреждение
- ✅ Выходной формат соответствует спецификации
- ✅ Программа не падает на некорректных данных

---

## 🎬 DEBRIEFING

```
╔═══════════════════════════════════════════════════════════╗
║      🎯 КАРТА ПАМЯТИ ПОСТРОЕНА! КРИТИЧЕСКИЕ ДАННЫЕ       ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  ✓ Структуры распознаны: 27 блоков                       ║
║  ✓ Garbage-байты отфильтрованы: 143 байта                ║
║  ✓ Строки извлечены: 8 фрагментов                        ║
║  ✓ Координаты найдены: 5 точек                           ║
║  ✓ Временные метки: 7 записей                            ║
║                                                           ║
║  🚨 КРИТИЧЕСКИЕ ОБНАРУЖЕНИЯ:                             ║
║                                                           ║
║  → GPS: 55.7413° N, 37.6253° E (ВАША КВАРТИРА!)          ║
║  → "Evidence_Z" - координаты: 55.9000° N, 37.8000° E     ║
║  → Временная метка: 2024-10-01 08:00:00 UTC              ║
║  → Дополнительное сообщение: "FOLLOW THE POINTER CHAIN"  ║
║                                                           ║
║  ⏰ ВРЕМЯ ДО ЭВАКУАЦИИ: 4 часа 13 минут                  ║
║                                                           ║
║  📍 Следующий шаг:                                       ║
║     → Координаты Evidence_Z указывают на старый          ║
║       дата-центр на Варшавском шоссе                     ║
║     → Сообщение "POINTER CHAIN" — намёк на Episode 06    ║
║     → Начинайте паковать рюкзак (go-bag)                 ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**13:45** — Вы завершили парсинг. Все блоки извлечены. Координаты безопасного убежища найдены.

Собираете go-bag: ноутбук, флешки с данными, деньги, документы. Квартиру придётся оставить.

**14:58** — На защищённый канал приходит **ещё один файл** от V.: `pointers.dat`

Сообщение:
```
"Координаты убежища спрятаны в цепочке указателей.
 Но будь осторожен — не все цепочки ведут туда, куда нужно.
 Научись читать память глубже. Время пошло. — V."
```

Вы открываете файл и замираете. Там **ДВЕ цепочки указателей**...

**15:00** — Телефон вибрирует. Неизвестный номер:

```
╔═══════════════════════════════════════════════════════════╗
║  От: +7-XXX-XXX-XXXX                                      ║
║                                                           ║
║  "Думаешь, убежал? Мы знаем, что ты ищешь.               ║
║   Одна из цепочек — ловушка.                             ║
║   Выбери неправильно — раскроешь своё местоположение.    ║
║                                                           ║
║   Удачи в Episode 06, умник. — Z."                       ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

**🎯 CLIFFHANGER:**
- ДВЕ цепочки указателей — какая правильная?
- Одна ведёт к убежищу, другая — к Z.
- Deadline: эвакуация через 1 час
- Episode 06 ждёт...

**Продолжение в Episode 06: "Pointer Game"** →

### 📊 Статистика прохождения:
- ⏱️ Среднее время: 90-120 минут (с промежуточной задачей)
- 🎓 Новые навыки: **Массивы**, **Строки**, **Бинарные данные**
- 🏆 Достижение разблокировано: **"Memory Cartographer"** 

### 🔓 Skill Unlocked: **Array Mastery**
```
[████████████████████] 100%

Вы освоили:
✓ Объявление и инициализацию массивов
✓ Многомерные массивы
✓ Работу со строками (string.h)
✓ Парсинг бинарных структур
✓ Проверку целостности данных (checksum)
✓ sizeof для вычисления длины массивов
✓ Анализ GPS-координат
```

---

## 🎨 Easter Eggs

🔍 **Скрытые детали:**
- Координаты ведут к реальному дата-центру на Варшавском шоссе
- Сообщение "FOLLOW THE POINTER CHAIN" — намёк на Episode 06
- Checksum-алгоритм (XOR) используется в реальных протоколах (TCP, UDP)
- Формат данных похож на структуру PNG/JPEG chunks
- GPS координаты 55.7413° N, 37.6253° E — район Таганки в Москве
- Символ Z. — отсылка к "Zero Cool" из фильма "Хакеры"

🎬 **Отсылки:**
- "Карта памяти" — как в фильме "The Matrix" (memory residuals)
- Дамп памяти — настоящая техника цифровой криминалистики
- ASCII-визуализация — классика reverse engineering
- Deadline 6 часов — паттерн из шпионских триллеров
- SMS от неизвестного — как в "Jason Bourne"

---

## 🎁 Артефакт

После выполнения миссии вы получите:
- **Навык**: работа с массивами и строками на уровне профессионала
- **Инструмент**: `memory_mapper` — парсер бинарных данных
- **Инструмент**: `array_analyzer` — анализатор массивов
- **Знание**: понимание layout данных в памяти (memory layout)
- **Сюжет**: GPS-координаты убежища и предупреждение о слежке

**Эти инструменты критически важны для Episode 06!**

---

## 🔗 Навигация

- [← Episode 04: First Tool](../../season-1-foundations/episode-04-first-tool/README.md)
- [→ Episode 06: Pointer Game](../episode-06-pointer-game/README.md)
- [📋 Season 2: Memory & Pointers](../README.md)
- [🏠 Главная страница](../../README.md)

---

> *"Arrays and strings are the alphabet of systems programming. Learn to read memory like a book — your life may depend on it."* — V.

```
// MEMORY MAP COMPLETE
// GPS COORDINATES DETECTED: 55.7413° N, 37.6253° E
// DEADLINE: 6 HOURS TO EVACUATION
// POINTER CHAIN LOCATED: 0x7F8A12345000
// NEXT EPISODE UNLOCKED
//
// TIME REMAINING: 04:13:47
// STATUS: COMPROMISED
// NEXT MOVE: FOLLOW THE POINTERS
```
