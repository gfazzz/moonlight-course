# Episode 05: "Memory Map" 🗺️

> *"Arrays are the foundation. Master them, and memory becomes your ally."*

---

## 🎬 BRIEFING

```
╔══════════════════════════════════════════════════════════╗
║  ЛОКАЦИЯ: Безопасная квартира, Таганка, Москва          ║
║  ВРЕМЯ:   08:47, среда, 1 октября                       ║
║  СТАТУС:  🔴 COMPROMISED — EMERGENCY PROTOCOL            ║
╚══════════════════════════════════════════════════════════╝
```

**ВРЕМЕННАЯ ЛИНИЯ:**
```
06:30  ⏰ Просыпаетесь после короткого сна
06:45  📧 Проверяете зашифрованный канал
07:15  📦 Новый файл от V.: memory_dump.dat
08:00  ☕ Анализ структуры файла начат
08:47  🎯 Обнаружена сложная структура данных
09:12  🚨 КРИТИЧЕСКОЕ ОТКРЫТИЕ: GPS-координаты вашей квартиры!
09:13  ⚠️  DEADLINE: Эвакуация через 6 часов
```

### 🔐 СИТУАЦИЯ — КРИТИЧЕСКАЯ

После расшифровки сообщения Виктора и создания вашего первого инструмента (`moonlight-decoder`), вы думали, что самое сложное позади.

Но в 07:15 утра на защищённый канал приходит новый файл — `memory_dump.dat`.

**Метаданные файла:**
```
Имя:     memory_dump.dat
Размер:  2.4 KB
Тип:     Binary dump
Отправитель: V. (зашифрованный канал)
Сообщение: "Это не просто данные. Это карта. Парси быстро."
```

Вы открываете файл в hex-редакторе:

```
Offset    Hex                                            ASCII
--------  ---------------------------------------------  ----------------
00000000  FF FF 01 05 48 65 6C 6C 6F 48 FF FF FF 02 08  ..▓.Hello▓..▓..
00000010  42 8E 5C 40 42 17 13 42 AA FF 03 04 65 12 34  B.\@B..B▓.▓.e.4
00000020  56 BC FF FF FF 01 0A 53 65 63 72 65 74 4D 73  V▓...▓.SecretMs
00000030  67 4D FF FF 02 08 41 A3 5D 40 43 8F 21 42 C1  g▓..▓.A.]@C.!B.
```

**Что вы понимаете:**
- Данные **структурированы**, но хаотично расположены
- Между блоками валидных данных есть "**мусор**" (байты `FF`)
- Каждый блок начинается с **типом** и **размером**
- Это похоже на **дамп памяти** какой-то программы

Виктор оставил подсказку: *"Карта памяти откроет первую дверь"*.

---

### 🚨 ТВИСТ — ОБНАРУЖЕНИЕ В 09:12

После парсинга первых блоков вы замираете. В блоке COORDINATES находите:

```
Координаты #1: 55.7413° N, 37.6253° E
Координаты #2: 55.7415° N, 37.6250° E
Координаты #3: 55.7410° N, 37.6255° E
```

Вы открываете карту. Эти координаты образуют **треугольник с радиусом 50 метров**.

**Центр треугольника:** улица Таганская, дом 17, квартира 42.

**Ваша квартира.**

Вы бросаетесь к окну. На улице — обычное утро. Люди идут на работу. Ничего подозрительного.

Но теперь вы знаете: **кто-то знает, где вы**.

Телефон вибрирует. SMS с неизвестного номера:

```
╔═══════════════════════════════════════════════════════════╗
║  От: +7-XXX-XXX-XXXX                                      ║
║  Время: 09:13                                             ║
║                                                           ║
║  "Мы знаем, где ты. Дамп памяти — это не просто данные.  ║
║   Это доказательства. Найди их ВСЕ за 6 часов.           ║
║                                                           ║
║   Или мы найдём тебя первыми.                            ║
║                                                           ║
║   Не пытайся бежать. Следим. — Z."                       ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

Руки трясутся. Адреналин бьёт в виски.

**У вас есть 6 часов, чтобы:**
1. ✅ Распарсить ВСЕ блоки памяти
2. ✅ Найти скрытые доказательства
3. ✅ Подготовиться к эвакуации
4. ✅ Понять, кто такой Z.

**Время пошло.**

### 🎯 ЗАДАЧА

Создать **`memory_mapper`** — программу для парсинга бинарных структур данных:
1. ✅ Прочитать дамп памяти
2. ✅ Распознать типы данных (строки, координаты, временные метки)
3. ✅ Проверить целостность (checksum)
4. ✅ Построить визуальную карту памяти
5. ✅ Извлечь ВСЕ скрытые сообщения

**Сложность:** 🟡 Medium  
**Новые навыки:** Массивы, строки, бинарные данные, структуры в памяти  
**Deadline:** ⏰ 6 часов до эвакуации

```
╔══════════════════════════════════════════════════════════╗
║  [!] КРИТИЧЕСКИ ВАЖНО:                                   ║
║  Это первый шаг в понимании того,                        ║
║  как данные хранятся на низком уровне.                   ║
║  Виктор не просто так прислал этот файл...               ║
║  И теперь за вами следят.                                ║
╚══════════════════════════════════════════════════════════╝
```

---

## 📚 ТЕОРИЯ: Массивы и строки в C

### 💡 Зачем это нужно в реальности?

**Массивы** — это фундамент:
- 📦 **Протоколы**: Парсинг сетевых пакетов (TCP/IP, HTTP)
- 🔐 **Криптография**: Работа с ключами, шифртекстами
- 🎮 **Графика**: Пиксели, вершины, текстуры
- 💾 **Файлы**: Чтение/запись бинарных форматов
- 🤖 **AI**: Матрицы весов, датасеты

Без массивов **невозможно** работать с реальными данными!

### 1. Массивы — упорядоченные данные

**Массив** — это последовательность элементов одного типа, расположенных в памяти **подряд** (contiguous).

```c
// Объявление и инициализация
int numbers[5] = {10, 20, 30, 40, 50};

// Доступ к элементам (индексация с 0)
int first = numbers[0];   // 10
int last = numbers[4];    // 50

// Размер массива
int size = sizeof(numbers) / sizeof(numbers[0]);  // 5
```

**📊 Метафора: СКЛАД С КОНТЕЙНЕРАМИ**

```
╔════════════════════════════════════════════════════════╗
║  СКЛАД ПАМЯТИ — МАССИВ numbers[5]                     ║
╠════════════════════════════════════════════════════════╣
║                                                        ║
║  ┌──────┬──────┬──────┬──────┬──────┐                ║
║  │  10  │  20  │  30  │  40  │  50  │ ← Контейнеры   ║
║  └──────┴──────┴──────┴──────┴──────┘                ║
║    [0]    [1]    [2]    [3]    [4]   ← Номера        ║
║     ↑                                                  ║
║     numbers[0] — первый контейнер!                    ║
║                                                        ║
║  🚛 Грузчик (CPU):                                    ║
║  "Дайте мне контейнер №2" → numbers[2] → достаёт 30  ║
║                                                        ║
║  Правила склада:                                      ║
║  ✅ Все контейнеры одинакового типа (int)             ║
║  ✅ Стоят подряд (contiguous memory)                  ║
║  ✅ Нумерация с 0 (первый = [0])                      ║
║  ⚠️  Нельзя запросить [5] — склад кончился!          ║
║                                                        ║
╚════════════════════════════════════════════════════════╝
```

**📊 Визуализация в памяти:**
```
Адрес     Индекс  Значение
┌────────┬───────┬─────────┐
│ 0x1000 │ [0]   │   10    │  ← numbers[0]
│ 0x1004 │ [1]   │   20    │  ← numbers[1]
│ 0x1008 │ [2]   │   30    │  ← numbers[2]
│ 0x100C │ [3]   │   40    │  ← numbers[3]
│ 0x1010 │ [4]   │   50    │  ← numbers[4]
└────────┴───────┴─────────┘
     ↑ Каждый int занимает 4 байта (обычно)
```

**🔑 Важно:**
- ✅ Индексация начинается с **0** (первый элемент — `arr[0]`)
- ✅ Размер массива **фиксирован** при объявлении
- ⚠️ Выход за границы массива — **undefined behavior (UB)**! Может краш, может молча перезаписать память

---

### 2. Строки — массивы символов

**В C нет отдельного типа "строка"!** Строка — это массив `char`, заканчивающийся **нулевым символом** `'\0'` (null terminator).

```c
// Три способа создания строки
char str1[] = "Hello";                    // Автоматический размер (6 байт с '\0')
char str2[10] = "World";                  // Явный размер (остальное заполнено '\0')
char str3[] = {'H', 'i', '\0'};          // Посимвольно

// ❌ ОШИБКА: нет завершающего '\0'
char bad[] = {'B', 'a', 'd'};            // Не строка! Функции вроде printf не остановятся!
```

**📊 Метафора: ПОЕЗД С ВАГОНАМИ**

```
╔════════════════════════════════════════════════════════╗
║  СТРОКА КАК ПОЕЗД: "Hello"                             ║
╠════════════════════════════════════════════════════════╝
║                                                        
║  🚂┌───┬───┬───┬───┬───┬────┐🛑                      
║    │ H │ e │ l │ l │ o │ \0 │  ← СТОП-сигнал!       
║    └───┴───┴───┴───┴───┴────┘                        
║    [0] [1] [2] [3] [4] [5]                           
║                         ↑                             
║                    Нулевой терминатор =               
║                    красный сигнал светофора:          
║                    "СТРОКА КОНЧИЛАСЬ!"                
║                                                        
║  Без '\0' поезд не остановится! 💥                    
╚════════════════════════════════════════════════════════
```

**📊 Визуализация в памяти:**
```
str1: "Hello"
┌───┬───┬───┬───┬───┬────┐
│ H │ e │ l │ l │ o │ \0 │
└───┴───┴───┴───┴───┴────┘
 [0] [1] [2] [3] [4] [5]
                       ↑
              Нулевой терминатор!
              Сигнал "строка кончилась"

str2: "World" (размер 10)
┌───┬───┬───┬───┬───┬────┬────┬────┬────┬────┐
│ W │ o │ r │ l │ d │ \0 │ \0 │ \0 │ \0 │ \0 │
└───┴───┴───┴───┴───┴────┴────┴────┴────┴────┘
 [0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
                     ↑
            Остальное — нули
```

**⚠️ Критически важно:**
```c
char name[5] = "Alice";  // ❌ ОШИБКА! "Alice" = 5 букв + '\0' = 6 байт!
char name[6] = "Alice";  // ✅ Правильно
```

---

### 3. Стандартная библиотека `string.h`

```c
#include <string.h>

// Длина строки (без '\0')
size_t len = strlen("Hello");  // 5

// Копирование
char dest[20];
strcpy(dest, "Copy this");

// Сравнение (0 = равны, <0 или >0 = различны)
if (strcmp(str1, str2) == 0) {
    printf("Strings are equal\n");
}

// Конкатенация (добавление в конец)
strcat(dest, " more text");
```

**⚠️ Опасность**: `strcpy` и `strcat` не проверяют размер буфера → переполнение!

**Безопасные версии**:
```c
strncpy(dest, source, sizeof(dest) - 1);
dest[sizeof(dest) - 1] = '\0';  // Гарантируем завершение

strncat(dest, source, sizeof(dest) - strlen(dest) - 1);
```

---

### 4. Многомерные массивы

```c
// Двумерный массив (матрица)
int matrix[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// Доступ к элементу
int value = matrix[1][2];  // 7

// Обход всех элементов
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 4; j++) {
        printf("%d ", matrix[i][j]);
    }
    printf("\n");
}
```

**📊 Визуализация:**
```
matrix[3][4]:
     [0]  [1]  [2]  [3]
[0]   1    2    3    4
[1]   5    6    7    8  ← matrix[1][2] = 7
[2]   9   10   11   12
```

---

### 5. Массивы и функции

```c
// Массив в функцию передаётся по указателю (без копирования!)
void process_array(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] *= 2;  // Изменения видны снаружи!
    }
}

int main() {
    int data[5] = {1, 2, 3, 4, 5};
    process_array(data, 5);  // data изменится!
    // data теперь: {2, 4, 6, 8, 10}
}
```

---

### 6. sizeof — узнать размер

**`sizeof`** — оператор, который возвращает размер типа или переменной **в байтах**.

```c
int x = 5;
printf("int занимает %zu байт\n", sizeof(int));      // 4
printf("char занимает %zu байт\n", sizeof(char));    // 1
printf("double занимает %zu байт\n", sizeof(double)); // 8
printf("x занимает %zu байт\n", sizeof(x));          // 4
```

**Зачем это нужно?** Для вычисления длины массива!

```c
int numbers[] = {10, 20, 30, 40, 50};

// Общий размер массива в байтах
int total_bytes = sizeof(numbers);  // 20 (5 элементов × 4 байта)

// Размер одного элемента
int element_bytes = sizeof(numbers[0]);  // 4

// Количество элементов
int length = sizeof(numbers) / sizeof(numbers[0]);  // 5
printf("Длина массива: %d\n", length);
```

**📊 Визуализация sizeof:**
```
╔════════════════════════════════════════╗
║  ЛИНЕЙКА ПАМЯТИ — sizeof               ║
╠════════════════════════════════════════╣
║                                        ║
║  int numbers[5] = {10, 20, 30, 40, 50};║
║                                        ║
║  [████][████][████][████][████]        ║
║   4байт 4байт 4байт 4байт 4байт        ║
║  ├──────────────────────────────┤      ║
║         sizeof(numbers) = 20           ║
║                                        ║
║  [████]  sizeof(numbers[0]) = 4        ║
║                                        ║
║  Длина = 20 / 4 = 5 элементов          ║
║                                        ║
╚════════════════════════════════════════╝
```

---

### 7. Распространённые ошибки

```c
// ❌ Выход за границы
int arr[5];
arr[5] = 100;  // Ошибка! Индексы: 0-4

// ❌ Неинициализированный массив
int data[100];
printf("%d", data[0]);  // Мусор в памяти!

// ❌ Переполнение буфера
char small[5];
strcpy(small, "This is too long");  // Переполнение!

// ✅ Правильно
char small[20];
strncpy(small, "Safe copy", sizeof(small) - 1);
small[sizeof(small) - 1] = '\0';
```

---

## 🎯 ПРОМЕЖУТОЧНАЯ ЗАДАЧА: "Array Analyzer"

> *"Перед тем как парсить дамп памяти, нужно освоить базовые операции с массивами."*

### Задача

Создать программу `array_analyzer.c`, которая анализирует массив байтов:

```c
unsigned char data[] = {0x42, 0x1A, 0xFF, 0x00, 0x7E};
```

**Программа должна вывести:**
```
=== BYTE ARRAY ANALYSIS ===
Array size: 5 bytes

Byte 0: 0x42 (66 decimal)
Byte 1: 0x1A (26 decimal)
Byte 2: 0xFF (255 decimal)
Byte 3: 0x00 (0 decimal)
Byte 4: 0x7E (126 decimal)

Statistics:
Sum of all bytes: 473
Min byte: 0x00 (0)
Max byte: 0xFF (255)
Average: 94.6

Index of max: 2
Index of min: 3
```

### Требования

1. Вывести каждый байт в формате hex и decimal
2. Вычислить сумму всех байтов
3. Найти минимум и максимум
4. Найти индексы min/max
5. Вычислить среднее

### Starter Code

В файле `starter.c` найдёте заготовку:

```c
#include <stdio.h>

int main() {
    unsigned char data[] = {0x42, 0x1A, 0xFF, 0x00, 0x7E};
    int size = sizeof(data) / sizeof(data[0]);
    
    printf("=== BYTE ARRAY ANALYSIS ===\n");
    printf("Array size: %d bytes\n\n", size);
    
    // TODO: Вывести каждый байт
    
    // TODO: Вычислить статистику
    
    return 0;
}
```

### Подсказки

<details>
<summary>Как найти максимум в массиве?</summary>

```c
unsigned char max = data[0];  // Предполагаем, что первый — максимальный
int max_index = 0;

for (int i = 1; i < size; i++) {
    if (data[i] > max) {
        max = data[i];
        max_index = i;
    }
}
```
</details>

<details>
<summary>Как вычислить сумму?</summary>

```c
int sum = 0;
for (int i = 0; i < size; i++) {
    sum += data[i];
}
printf("Sum: %d\n", sum);
```
</details>

### Проверка

```bash
gcc -Wall -o array_analyzer artifacts/array_analyzer.c
./array_analyzer
```

**Критерий успеха:** вывод совпадает с примером выше.

---

## 🎯 Основная миссия: "Карта памяти"

### Легенда

После успешного анализа массива байтов, вы готовы к парсингу дампа памяти.

Файл содержит **структуры данных** переменной длины:
- Каждая структура начинается с **заголовка** (тип и размер)
- Данные могут быть: координаты, имена файлов, временные метки
- Между структурами есть "мусор" — случайные байты для маскировки

**Ваша задача**: создать `memory_mapper` — программу, которая:
1. Читает дамп памяти
2. Находит все валидные структуры данных
3. Извлекает и выводит информацию в читаемом виде
4. Строит "карту памяти" — визуализацию расположения данных
5. **Находит GPS-координаты и доказательства**

---

### Формат данных

**Структура записи**:
```
[TYPE (1 байт)] [SIZE (1 байт)] [DATA (SIZE байт)] [CHECKSUM (1 байт)]
```

**Типы данных**:
- `0x01` — строка (имя файла)
- `0x02` — координаты (широта, долгота — по 4 байта каждая, float)
- `0x03` — временная метка (UNIX timestamp — 4 байта, uint32_t)
- `0xFF` — маркер мусора (игнорировать до следующего валидного типа)

**Checksum** — простая контрольная сумма: XOR всех байт DATA.

---

### Пример дампа

```
FF FF 01 05 48 65 6C 6C 6F 48    // Мусор + строка "Hello"
FF FF FF 02 08 [float] [float] CS // Мусор + координаты
03 04 [timestamp] CS               // Временная метка
```

---

### Технические требования

**Входные данные**: файл `memory_dump.dat` (бинарный)

**Выходные данные** (stdout):
```
=== MEMORY MAP ===
⏰ DEADLINE: 6 hours remaining

[0x0000] GARBAGE (2 bytes)
[0x0002] STRING (5 bytes): "Hello"
[0x0009] GARBAGE (3 bytes)
[0x000C] COORDINATES (8 bytes): 55.7413° N, 37.6253° E ⚠️  YOUR LOCATION!
[0x0016] TIMESTAMP (4 bytes): 2024-10-01 08:00:00 UTC
[0x001E] STRING (10 bytes): "Evidence_Z"
[0x002A] COORDINATES (8 bytes): 55.9000° N, 37.8000° E

Total structures found: 5
Total garbage bytes: 5
GPS coordinates detected: 3
⚠️  WARNING: Your location is compromised!

CRITICAL EVIDENCE FOUND:
→ "Evidence_Z" - location: 55.9000° N, 37.8000° E
→ Evacuation recommended within 6 hours
```

**Функционал**:
1. Чтение бинарного файла в массив байтов
2. Парсинг структур данных
3. Проверка checksum для валидности
4. Конвертация бинарных данных в читаемый формат
5. Вывод карты памяти с адресами
6. **Обнаружение GPS-координат и предупреждение**

---

## 📝 Задание

### Starter Code

Файл `starter.c` содержит заготовку:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define MAX_DUMP_SIZE 4096

// Типы структур
#define TYPE_STRING 0x01
#define TYPE_COORDS 0x02
#define TYPE_TIMESTAMP 0x03
#define TYPE_GARBAGE 0xFF

// TODO: Реализуйте функции

// Вычисление checksum (XOR всех байт)
uint8_t calculate_checksum(uint8_t *data, int size) {
    // ваш код здесь
}

// Парсинг строки
void parse_string(uint8_t *data, int size) {
    // ваш код здесь
}

// Парсинг координат (два float)
void parse_coordinates(uint8_t *data, int size) {
    // ваш код здесь
}

// Парсинг временной метки
void parse_timestamp(uint8_t *data, int size) {
    // ваш код здесь
}

// Конвертация UNIX timestamp в читаемый формат
void format_timestamp(uint32_t timestamp, char *buffer) {
    // ваш код здесь
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <memory_dump.dat>\n", argv[0]);
        return 1;
    }

    // TODO: 
    // 1. Открыть файл
    // 2. Прочитать в массив байтов
    // 3. Пройти по массиву, распознавая структуры
    // 4. Вывести карту памяти

    return 0;
}
```

---

## 📝 Структура эпизода

```
episode-05-memory-map/
├── README.md           ← Вы здесь
├── mission.md
├── starter.c           ← Шаблон с примерами функций
├── artifacts/
│   ├── array_analyzer.c     ← Промежуточная задача
│   └── memory_mapper.c      ← Основная задача
├── solution/
│   ├── array_analyzer_solution.c
│   ├── memory_mapper_solution.c
│   └── generate_dump.c
└── tests/
    ├── test_array_analyzer.sh
    └── test.sh
```

### 💡 Как работать:

1. **Промежуточная задача** (20-30 минут):
   - Создайте `artifacts/array_analyzer.c`
   - Реализуйте анализ массива байтов
   - Проверьте: `gcc -Wall -o array_analyzer artifacts/array_analyzer.c && ./array_analyzer`

2. **Основная задача** (60-90 минут):
   - Изучите `starter.c` — там заготовки функций с TODO
   - Создайте файл `artifacts/memory_mapper.c`
   - Реализуйте функции для парсинга разных типов данных
   - Скомпилируйте: `gcc -Wall -o memory_mapper artifacts/memory_mapper.c`
   - Запустите: `./memory_mapper memory_dump.dat`

---

### Подсказки для memory_mapper

1. **Чтение бинарного файла**:
```c
FILE *f = fopen(filename, "rb");
uint8_t buffer[MAX_DUMP_SIZE];
size_t bytes_read = fread(buffer, 1, MAX_DUMP_SIZE, f);
```

2. **Конвертация байтов в float**:
```c
float value;
memcpy(&value, &buffer[offset], sizeof(float));
```

3. **Конвертация байтов в uint32_t**:
```c
uint32_t timestamp;
memcpy(&timestamp, &buffer[offset], sizeof(uint32_t));
```

4. **Форматирование времени**:
```c
#include <time.h>
time_t t = (time_t)timestamp;
struct tm *tm_info = gmtime(&t);
strftime(buffer, 26, "%Y-%m-%d %H:%M:%S UTC", tm_info);
```

5. **Проверка GPS-координат**:
```c
// Ваша квартира: 55.7413° N, 37.6253° E
if (latitude >= 55.74 && latitude <= 55.75 &&
    longitude >= 37.62 && longitude <= 37.63) {
    printf("⚠️  YOUR LOCATION!\n");
}
```

---

## ✅ Проверка

```bash
# Сборка промежуточной задачи
gcc -Wall -o array_analyzer artifacts/array_analyzer.c
./array_analyzer

# Сборка основной задачи
make

# Тестирование
make test

# Или вручную
./memory_mapper memory_dump.dat
```

**Критерии успеха**:
- ✅ Промежуточная задача выполнена (array_analyzer)
- ✅ Все структуры данных распознаны правильно
- ✅ Checksum проверяется для каждой структуры
- ✅ Garbage-байты корректно пропускаются
- ✅ GPS-координаты обнаружены и выведено предупреждение
- ✅ Выходной формат соответствует спецификации
- ✅ Программа не падает на некорректных данных

---

## 🎬 DEBRIEFING

```
╔═══════════════════════════════════════════════════════════╗
║      🎯 КАРТА ПАМЯТИ ПОСТРОЕНА! КРИТИЧЕСКИЕ ДАННЫЕ       ║
╠═══════════════════════════════════════════════════════════╣
║                                                           ║
║  ✓ Структуры распознаны: 27 блоков                       ║
║  ✓ Garbage-байты отфильтрованы: 143 байта                ║
║  ✓ Строки извлечены: 8 фрагментов                        ║
║  ✓ Координаты найдены: 5 точек                           ║
║  ✓ Временные метки: 7 записей                            ║
║                                                           ║
║  🚨 КРИТИЧЕСКИЕ ОБНАРУЖЕНИЯ:                             ║
║                                                           ║
║  → GPS: 55.7413° N, 37.6253° E (ВАША КВАРТИРА!)          ║
║  → "Evidence_Z" - координаты: 55.9000° N, 37.8000° E     ║
║  → Временная метка: 2024-10-01 08:00:00 UTC              ║
║  → Дополнительное сообщение: "FOLLOW THE POINTER CHAIN"  ║
║                                                           ║
║  ⏰ ВРЕМЯ ДО ЭВАКУАЦИИ: 4 часа 13 минут                  ║
║                                                           ║
║  📍 Следующий шаг:                                       ║
║     → Координаты Evidence_Z указывают на старый          ║
║       дата-центр на Варшавском шоссе                     ║
║     → Сообщение "POINTER CHAIN" — намёк на Episode 06    ║
║     → Начинайте паковать рюкзак (go-bag)                 ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
```

### 📊 Статистика прохождения:
- ⏱️ Среднее время: 90-120 минут (с промежуточной задачей)
- 🎓 Новые навыки: **Массивы**, **Строки**, **Бинарные данные**
- 🏆 Достижение разблокировано: **"Memory Cartographer"** 

### 🔓 Skill Unlocked: **Array Mastery**
```
[████████████████████] 100%

Вы освоили:
✓ Объявление и инициализацию массивов
✓ Многомерные массивы
✓ Работу со строками (string.h)
✓ Парсинг бинарных структур
✓ Проверку целостности данных (checksum)
✓ sizeof для вычисления длины массивов
✓ Анализ GPS-координат
```

---

## 🎓 КОНТРОЛЬНЫЕ ВОПРОСЫ

> *Проверьте своё понимание материала перед переходом к Episode 06*

### Базовое понимание

1. **Индексация массивов:**
   - Почему первый элемент массива — `arr[0]`, а не `arr[1]`?
   - Дан массив `int data[10]`. Какие индексы валидны? Что произойдёт при обращении к `data[10]`?

2. **sizeof:**
   - Дан массив `int numbers[20]`. Чему равно `sizeof(numbers)`?
   - Почему формула `sizeof(arr) / sizeof(arr[0])` даёт длину массива?
   - Будет ли `sizeof(arr)` работать после передачи массива в функцию?

3. **Строки:**
   - Сколько байт занимает строка `"Hello"`? 5 или 6? Почему?
   - Что произойдёт, если объявить `char name[5] = "Alice"`?
   - Зачем нужен нулевой терминатор `'\0'`?

### Практическое применение

4. **Работа с массивами:**
   - Напишите функцию `find_max(int arr[], int size)`, которая находит максимальный элемент
   - Как проверить, является ли байт printable ASCII (32-126)?

5. **Строки:**
   - В чём опасность функции `strcpy()`?
   - Почему `strncpy()` безопаснее?
   - Как безопасно конкатенировать строки?

6. **Бинарные данные:**
   - Как прочитать float из массива байтов на offset 10?
   - Что делает `memcpy(&value, &buffer[offset], sizeof(float))`?
   - Зачем проверять checksum при парсинге данных?

### Анализ кода

7. **Найдите ошибки:**
```c
char message[10];
strcpy(message, "This is a very long message");
printf("%s\n", message);
```

8. **Что выведет?**
```c
int arr[] = {10, 20, 30, 40};
printf("%zu\n", sizeof(arr));
printf("%zu\n", sizeof(arr[0]));
printf("%d\n", sizeof(arr) / sizeof(arr[0]));
```

9. **Что не так?**
```c
char str[] = {'H', 'e', 'l', 'l', 'o'};
printf("%s\n", str);  // Что произойдёт?
```

### Сюжет и метафоры

10. **Понимание метафор:**
    - Объясните метафору "склад с контейнерами" для массивов
    - Почему строка сравнивается с поездом с красным сигналом?
    - Как метафора помогает понять разницу между `arr[i]` и `*(arr+i)`?

11. **Сюжетный анализ:**
    - Зачем V. прислал дамп памяти именно сейчас?
    - Кто такой Z. и как он узнал ваши координаты?
    - Что означает сообщение "FOLLOW THE POINTER CHAIN"?
    - Куда ведут координаты Evidence_Z?

### Продвинутые вопросы

12. **Память:**
    - Где в памяти хранятся локальные массивы (стек или куча)?
    - Почему массив передаётся в функцию "по указателю"?

13. **Оптимизация:**
    - Что эффективнее: `strlen(str)` в цикле или сохранить в переменную?
    - Почему важно проверять границы массива перед записью?

### Задачи на размышление

14. **Реализуйте функцию:**
```c
// Реверсировать строку на месте (без доп. памяти)
void reverse_string(char *str);
```

15. **Checksum:**
    - Объясните, почему XOR используется для checksum
    - Какие ошибки может НЕ обнаружить простой XOR checksum?

---

### 🎯 Ответы на вопросы

<details>
<summary>Показать ответы</summary>

1. **Индексация с 0**: Потому что индекс = смещение от начала массива. Первый элемент = +0 байт от начала.

2. **sizeof(numbers)**: 80 байт (20 элементов × 4 байта каждый int)

3. **"Hello"**: 6 байт — 5 символов + 1 нулевой терминатор '\0'

4. **Ошибка strcpy**: Переполнение буфера — сообщение длиннее 10 символов!

5. **Реверс строки**:
```c
void reverse_string(char *str) {
    int len = strlen(str);
    for (int i = 0; i < len/2; i++) {
        char temp = str[i];
        str[i] = str[len - 1 - i];
        str[len - 1 - i] = temp;
    }
}
```

</details>

---

## 🎨 Easter Eggs

🔍 **Скрытые детали:**
- Координаты ведут к реальному дата-центру на Варшавском шоссе
- Сообщение "FOLLOW THE POINTER CHAIN" — намёк на Episode 06
- Checksum-алгоритм (XOR) используется в реальных протоколах (TCP, UDP)
- Формат данных похож на структуру PNG/JPEG chunks
- GPS координаты 55.7413° N, 37.6253° E — район Таганки в Москве
- Символ Z. — отсылка к "Zero Cool" из фильма "Хакеры"

🎬 **Отсылки:**
- "Карта памяти" — как в фильме "The Matrix" (memory residuals)
- Дамп памяти — настоящая техника цифровой криминалистики
- ASCII-визуализация — классика reverse engineering
- Deadline 6 часов — паттерн из шпионских триллеров
- SMS от неизвестного — как в "Jason Bourne"

---

## 🎁 Артефакт

После выполнения миссии вы получите:
- **Навык**: работа с массивами и строками на уровне профессионала
- **Инструмент**: `memory_mapper` — парсер бинарных данных
- **Инструмент**: `array_analyzer` — анализатор массивов
- **Знание**: понимание layout данных в памяти (memory layout)
- **Сюжет**: GPS-координаты убежища и предупреждение о слежке

**Эти инструменты критически важны для Episode 06!**

---

## 🔗 Навигация

- [← Episode 04: First Tool](../../season-1-foundations/episode-04-first-tool/README.md)
- [→ Episode 06: Pointer Game](../episode-06-pointer-game/README.md)
- [📋 Season 2: Memory & Pointers](../README.md)
- [🏠 Главная страница](../../README.md)

---

> *"Arrays and strings are the alphabet of systems programming. Learn to read memory like a book — your life may depend on it."* — V.

```
// MEMORY MAP COMPLETE
// GPS COORDINATES DETECTED: 55.7413° N, 37.6253° E
// DEADLINE: 6 HOURS TO EVACUATION
// POINTER CHAIN LOCATED: 0x7F8A12345000
// NEXT EPISODE UNLOCKED
//
// TIME REMAINING: 04:13:47
// STATUS: COMPROMISED
// NEXT MOVE: FOLLOW THE POINTERS
```
